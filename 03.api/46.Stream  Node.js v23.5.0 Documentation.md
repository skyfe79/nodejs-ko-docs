# Table of Contents

- [스트림(Stream)](#스트림stream)
    - [이 문서의 구성](#이-문서의-구성)
    - [스트림의 종류](#스트림의-종류)
      - [Streams Promises API](#streams-promises-api)
      - [`stream.pipeline(source[, ...transforms], destination[, options])`](#streampipelinesource-transforms-destination-options)
      - [`stream.pipeline(streams[, options])`](#streampipelinestreams-options)
      - [`stream.finished(stream[, options])`](#streamfinishedstream-options)
      - [객체 모드](#객체-모드)
      - [버퍼링](#버퍼링)
    - [스트림 소비자를 위한 API](#스트림-소비자를-위한-api)
      - [쓰기 가능 스트림(Writable Streams)](#쓰기-가능-스트림writable-streams)
    - [클래스: `stream.Writable`](#클래스-streamwritable)
      - [이벤트: `'close'`](#이벤트-close)
      - [이벤트: `'drain'`](#이벤트-drain)
      - [이벤트: `'error'`](#이벤트-error)
      - [이벤트: `'finish'`](#이벤트-finish)
      - [이벤트: `'pipe'`](#이벤트-pipe)
      - [이벤트: `'unpipe'`](#이벤트-unpipe)
      - [`writable.cork()`](#writablecork)
      - [`writable.destroy([error])`](#writabledestroyerror)
      - [`writable.closed`](#writableclosed)
      - [`writable.destroyed`](#writabledestroyed)
      - [`writable.end([chunk[, encoding]][, callback])`](#writableendchunk-encoding-callback)
      - [`writable.setDefaultEncoding(encoding)`](#writablesetdefaultencodingencoding)
      - [`writable.uncork()`](#writableuncork)
      - [`writable.writable`](#writablewritable)
      - [`writable.writableAborted`](#writablewritableaborted)
      - [`writable.writableEnded`](#writablewritableended)
      - [`writable.writableCorked`](#writablewritablecorked)
      - [`writable.errored`](#writableerrored)
      - [읽기 가능한 스트림(Readable Streams)](#읽기-가능한-스트림readable-streams)
        - [두 가지 읽기 모드](#두-가지-읽기-모드)
        - [세 가지 상태](#세-가지-상태)
    - [클래스: `stream.Readable`](#클래스-streamreadable)
      - [이벤트: `'close'`](#이벤트-close)
      - [이벤트: `'data'`](#이벤트-data)
      - [이벤트: `'end'`](#이벤트-end)
      - [이벤트: `'error'`](#이벤트-error)
      - [이벤트: `'pause'`](#이벤트-pause)
      - [이벤트: `'readable'`](#이벤트-readable)
      - [이벤트: `'resume'`](#이벤트-resume)
      - [`readable.destroy([error])`](#readabledestroyerror)
      - [`readable.closed`](#readableclosed)
      - [`readable.destroyed`](#readabledestroyed)
      - [`readable.isPaused()`](#readableispaused)
      - [`readable.pause()`](#readablepause)
      - [`readable.pipe(destination[, options])`](#readablepipedestination-options)
      - [`readable.read([size])`](#readablereadsize)
      - [Duplex and transform streams](#duplex-and-transform-streams)
    - [클래스: `stream.Duplex`](#클래스-streamduplex)
      - [`duplex.allowHalfOpen`](#duplexallowhalfopen)
        - [클래스: `stream.Transform`](#클래스-streamtransform)
        - [`stream.duplexPair([options])`](#streamduplexpairoptions)
      - [`stream.finished(stream[, options], callback)`](#streamfinishedstream-options-callback)
      - [`stream.pipeline(source[, ...transforms], destination, callback)`](#streampipelinesource-transforms-destination-callback)
      - [`stream.pipeline(streams, callback)`](#streampipelinestreams-callback)
      - [`stream.compose(...streams)`](#streamcomposestreams)
      - [`stream.Readable.from(iterable[, options])`](#streamreadablefromiterable-options)
      - [`stream.Readable.fromWeb(readableStream[, options])`](#streamreadablefromwebreadablestream-options)
      - [`stream.Readable.isDisturbed(stream)`](#streamreadableisdisturbedstream)
      - [`stream.isErrored(stream)`](#streamiserroredstream)
      - [`stream.isReadable(stream)`](#streamisreadablestream)
      - [`stream.Readable.toWeb(streamReadable[, options])`](#streamreadabletowebstreamreadable-options)
      - [`stream.Writable.fromWeb(writableStream[, options])`](#streamwritablefromwebwritablestream-options)
      - [`stream.Writable.toWeb(streamWritable)`](#streamwritabletowebstreamwritable)
      - [`stream.Duplex.from(src)`](#streamduplexfromsrc)
      - [`stream.Duplex.fromWeb(pair[, options])`](#streamduplexfromwebpair-options)
      - [`stream.Duplex.toWeb(streamDuplex)`](#streamduplextowebstreamduplex)
      - [`stream.addAbortSignal(signal, stream)`](#streamaddabortsignalsignal-stream)
      - [`stream.getDefaultHighWaterMark(objectMode)`](#streamgetdefaulthighwatermarkobjectmode)
      - [`stream.setDefaultHighWaterMark(objectMode, value)`](#streamsetdefaulthighwatermarkobjectmode-value)
    - [스트림 구현자를 위한 API](#스트림-구현자를-위한-api)
      - [간단한 생성 방법](#간단한-생성-방법)
      - [쓰기 가능한 스트림 구현하기](#쓰기-가능한-스트림-구현하기)
        - [`new stream.Writable([options])`](#new-streamwritableoptions)
        - [`writable._construct(callback)`](#writable_constructcallback)
        - [`writable._write(chunk, encoding, callback)`](#writable_writechunk-encoding-callback)
        - [`writable._writev(chunks, callback)`](#writable_writevchunks-callback)
        - [`writable._destroy(err, callback)`](#writable_destroyerr-callback)
        - [`writable._final(callback)`](#writable_finalcallback)
        - [쓰기 작업 중 발생하는 오류](#쓰기-작업-중-발생하는-오류)
        - [쓰기 가능한 스트림 예제](#쓰기-가능한-스트림-예제)
        - [Writable 스트림에서 버퍼 디코딩하기](#writable-스트림에서-버퍼-디코딩하기)
      - [읽기 가능한 스트림 구현하기](#읽기-가능한-스트림-구현하기)
        - [`new stream.Readable([options])`](#new-streamreadableoptions)
        - [`readable._construct(callback)`](#readable_constructcallback)
        - [`readable._read(size)`](#readable_readsize)
        - [`readable._destroy(err, callback)`](#readable_destroyerr-callback)
        - [`readable.push(chunk[, encoding])`](#readablepushchunk-encoding)
        - [읽기 중 발생하는 오류](#읽기-중-발생하는-오류)
        - [카운팅 스트림 예제](#카운팅-스트림-예제)
      - [듀플렉스 스트림 구현하기](#듀플렉스-스트림-구현하기)
        - [`new stream.Duplex(options)`](#new-streamduplexoptions)
        - [Duplex 스트림 예제](#duplex-스트림-예제)
        - [객체 모드 듀플렉스 스트림](#객체-모드-듀플렉스-스트림)
      - [Transform 스트림 구현하기](#transform-스트림-구현하기)
    - [`new stream.Transform([options])`](#new-streamtransformoptions)
        - [이벤트: `'end'`](#이벤트-end)
        - [이벤트: `'finish'`](#이벤트-finish)
    - [`transform._flush(callback)`](#transform_flushcallback)
        - [`transform._transform(chunk, encoding, callback)`](#transform_transformchunk-encoding-callback)
    - [클래스: `stream.PassThrough`](#클래스-streampassthrough)
    - [Additional notes](#additional-notes)
      - [스트림과 비동기 제너레이터 및 비동기 이터레이터의 호환성](#스트림과-비동기-제너레이터-및-비동기-이터레이터의-호환성)
        - [async iterators를 사용하여 Readable 스트림 소비하기](#async-iterators를-사용하여-readable-스트림-소비하기)
        - [async generator를 사용하여 읽기 가능한 스트림 만들기](#async-generator를-사용하여-읽기-가능한-스트림-만들기)
        - [비동기 이터레이터에서 쓰기 가능한 스트림으로 파이핑하기](#비동기-이터레이터에서-쓰기-가능한-스트림으로-파이핑하기)
      - [이전 Node.js 버전과의 호환성](#이전-nodejs-버전과의-호환성)
      - [`readable.read(0)`](#readableread0)
      - [`readable.push('')`](#readablepush)
      - [`readable.setEncoding()` 호출 후 `highWaterMark` 차이점](#readablesetencoding-호출-후-highwatermark-차이점)

# 스트림(Stream)

**소스 코드:** [lib/stream.js](https://github.com/nodejs/node/blob/v23.5.0/lib/stream.js)

스트림은 Node.js에서 스트리밍 데이터를 다루기 위한 추상 인터페이스입니다. `node:stream` 모듈은 이 스트림 인터페이스를 구현하기 위한 API를 제공합니다.

Node.js는 다양한 스트림 객체를 제공합니다. 예를 들어, [HTTP 서버에 대한 요청](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)과 [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout)은 모두 스트림 인스턴스입니다.

스트림은 읽기 가능, 쓰기 가능, 또는 둘 다 가능한 형태로 존재합니다. 모든 스트림은 [`EventEmitter`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)의 인스턴스입니다.

`node:stream` 모듈에 접근하려면 다음과 같이 작성합니다:

```js
const stream = require('node:stream');
```

`node:stream` 모듈은 새로운 타입의 스트림 인스턴스를 생성할 때 유용합니다. 일반적으로 스트림을 사용하기 위해 이 모듈을 직접 사용할 필요는 없습니다.


### 이 문서의 구성

이 문서는 두 개의 주요 섹션과 추가적인 노트 섹션으로 구성되어 있습니다. 첫 번째 섹션에서는 애플리케이션 내에서 기존 스트림을 사용하는 방법을 설명합니다. 두 번째 섹션에서는 새로운 타입의 스트림을 만드는 방법을 다룹니다.


### 스트림의 종류

Node.js에는 네 가지 기본 스트림 타입이 있습니다:

-   [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable): 데이터를 쓸 수 있는 스트림입니다. 예를 들어, [`fs.createWriteStream()`](https://nodejs.org/docs/latest/api/fs.html#fscreatewritestreampath-options)이 있습니다.
-   [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable): 데이터를 읽을 수 있는 스트림입니다. 예를 들어, [`fs.createReadStream()`](https://nodejs.org/docs/latest/api/fs.html#fscreatereadstreampath-options)이 있습니다.
-   [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex): 데이터를 읽고 쓸 수 있는 스트림입니다. 예를 들어, [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)이 있습니다.
-   [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform): 데이터를 읽고 쓰는 동안 데이터를 수정하거나 변환할 수 있는 `Duplex` 스트림입니다. 예를 들어, [`zlib.createDeflate()`](https://nodejs.org/docs/latest/api/zlib.html#zlibcreatedeflateoptions)이 있습니다.

또한, 이 모듈에는 다음과 같은 유틸리티 함수들이 포함되어 있습니다: [`stream.duplexPair()`](https://nodejs.org/docs/latest/api/stream.html#streamduplexpairoptions), [`stream.pipeline()`](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-callback), [`stream.finished()`](https://nodejs.org/docs/latest/api/stream.html#streamfinishedstream-options-callback), [`stream.Readable.from()`](https://nodejs.org/docs/latest/api/stream.html#streamreadablefromiterable-options), 그리고 [`stream.addAbortSignal()`](https://nodejs.org/docs/latest/api/stream.html#streamaddabortsignalsignal-stream).


#### Streams Promises API[#](https://nodejs.org/docs/latest/api/stream.html#streams-promises-api)

추가된 버전: v15.0.0

`stream/promises` API는 콜백 대신 `Promise` 객체를 반환하는 스트림을 위한 비동기 유틸리티 함수 세트를 제공합니다. 이 API는 `require('node:stream/promises')` 또는 `require('node:stream').promises`를 통해 접근할 수 있습니다.


#### `stream.pipeline(source[, ...transforms], destination[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-options)





#### `stream.pipeline(streams[, options])`

- `streams` [`<Stream\[\]>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Iterable\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable\[\]>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
- `source` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Iterable>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  - 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
- `...transforms` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  - `source` [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
  - 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
- `destination` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  - `source` [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
  - 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 파이프라인 옵션
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)
  - `end` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 소스 스트림이 끝나면 대상 스트림도 종료합니다. 변환 스트림은 이 값이 `false`여도 항상 종료됩니다. **기본값:** `true`.
- 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 파이프라인이 완료되면 이행됩니다.

```javascript
import { pipeline } from 'node:stream/promises';
import { createReadStream, createWriteStream } from 'node:fs';
import { createGzip } from 'node:zlib';

await pipeline(
  createReadStream('archive.tar'),
  createGzip(),
  createWriteStream('archive.tar.gz'),
);

console.log('Pipeline succeeded.');
```

`AbortSignal`을 사용하려면 옵션 객체 안에 마지막 인자로 전달합니다. 신호가 중단되면 파이프라인의 기본 `destroy`가 호출되고 `AbortError`가 발생합니다.

```javascript
import { pipeline } from 'node:stream/promises';
import { createReadStream, createWriteStream } from 'node:fs';
import { createGzip } from 'node:zlib';

const ac = new AbortController();
const { signal } = ac;

setImmediate(() => ac.abort());

try {
  await pipeline(
    createReadStream('archive.tar'),
    createGzip(),
    createWriteStream('archive.tar.gz'),
    { signal },
  );
} catch (err) {
  console.error(err); // AbortError
}
```

`pipeline` API는 비동기 제너레이터도 지원합니다.

```javascript
import { pipeline } from 'node:stream/promises';
import { createReadStream, createWriteStream } from 'node:fs';

await pipeline(
  createReadStream('lowercase.txt'),
  async function* (source, { signal }) {
    source.setEncoding('utf8'); // `Buffer` 대신 문자열로 작업합니다.
    for await (const chunk of source) {
      yield await processChunk(chunk, { signal });
    }
  },
  createWriteStream('uppercase.txt'),
);

console.log('Pipeline succeeded.');
```

비동기 제너레이터에 전달된 `signal` 인자를 처리하는 것을 잊지 마세요. 특히 비동기 제너레이터가 파이프라인의 소스(즉, 첫 번째 인자)인 경우, 이를 처리하지 않으면 파이프라인이 완료되지 않을 수 있습니다.

```javascript
import { pipeline } from 'node:stream/promises';
import fs from 'node:fs';

await pipeline(
  async function* ({ signal }) {
    await someLongRunningfn({ signal });
    yield 'asd';
  },
  fs.createWriteStream('uppercase.txt'),
);

console.log('Pipeline succeeded.');
```

`pipeline` API는 [콜백 버전](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-callback)도 제공합니다.


#### `stream.finished(stream[, options])`

- `stream` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)  
  읽기 가능하거나 쓰기 가능한 스트림/웹스트림입니다.

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
  - `error` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  - `readable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  - `writable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  - `cleanup` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
    `true`로 설정하면, Promise가 완료되기 전에 이 함수가 등록한 리스너를 제거합니다. **기본값:** `false`.

- 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)  
  스트림이 더 이상 읽기 또는 쓰기 가능하지 않을 때 이행됩니다.

```javascript
import { finished } from 'node:stream/promises';
import { createReadStream } from 'node:fs';

const rs = createReadStream('archive.tar');

async function run() {
    await finished(rs);
    console.log('Stream is done reading.');
}

run().catch(console.error);
rs.resume(); // 스트림을 비웁니다.
```

`finished` API는 [콜백 버전](https://nodejs.org/docs/latest/api/stream.html#streamfinishedstream-options-callback)도 제공합니다.

`stream.finished()`는 반환된 Promise가 이행되거나 거부된 후에도 이벤트 리스너(특히 `'error'`, `'end'`, `'finish'`, `'close'`)를 남겨둡니다. 이는 잘못된 스트림 구현으로 인해 예기치 않은 `'error'` 이벤트가 발생해도 예상치 못한 충돌을 일으키지 않도록 하기 위함입니다. 이 동작이 원치 않는다면 `options.cleanup`을 `true`로 설정하면 됩니다.

```javascript
await finished(rs, { cleanup: true });
```


#### 객체 모드

Node.js API로 생성된 모든 스트림은 문자열, [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer), [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), 그리고 [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 객체만을 처리합니다.

-   `문자열`과 `버퍼`는 스트림과 함께 사용되는 가장 일반적인 타입입니다.
-   `TypedArray`와 `DataView`는 `Int32Array`나 `Uint8Array`와 같은 타입으로 바이너리 데이터를 다룰 수 있게 해줍니다. TypedArray나 DataView를 스트림에 쓰면, Node.js는 원시 바이트를 처리합니다.

그러나 스트림 구현체가 `null`을 제외한 다른 자바스크립트 값도 처리할 수 있습니다. (`null`은 스트림 내에서 특별한 목적으로 사용됩니다.) 이러한 스트림은 "객체 모드"에서 동작한다고 간주됩니다.

스트림 인스턴스는 생성 시 `objectMode` 옵션을 사용해 객체 모드로 전환됩니다. 이미 생성된 스트림을 객체 모드로 전환하려는 시도는 안전하지 않습니다.


#### 버퍼링

[`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)과 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림은 모두 데이터를 내부 버퍼에 저장합니다.

버퍼링될 수 있는 데이터의 양은 스트림 생성자에 전달된 `highWaterMark` 옵션에 따라 결정됩니다. 일반적인 스트림의 경우, `highWaterMark` 옵션은 [총 바이트 수](https://nodejs.org/docs/latest/api/stream.html#highwatermark-discrepancy-after-calling-readablesetencoding)를 지정합니다. 객체 모드로 동작하는 스트림의 경우, `highWaterMark`는 총 객체 수를 지정합니다. 문자열을 처리하지만 디코딩하지 않는 스트림의 경우, `highWaterMark`는 총 UTF-16 코드 단위 수를 지정합니다.

`Readable` 스트림에서 데이터는 구현체가 [`stream.push(chunk)`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding)를 호출할 때 버퍼링됩니다. 스트림의 소비자가 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)를 호출하지 않으면, 데이터는 소비될 때까지 내부 큐에 남아 있습니다.

내부 읽기 버퍼의 총 크기가 `highWaterMark`로 지정된 임계값에 도달하면, 스트림은 현재 버퍼링된 데이터가 소비될 때까지 기본 리소스에서 데이터를 읽는 것을 일시적으로 중단합니다. 즉, 스트림은 읽기 버퍼를 채우는 데 사용되는 내부 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드 호출을 중단합니다.

`Writable` 스트림에서 데이터는 [`writable.write(chunk)`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback) 메서드가 반복적으로 호출될 때 버퍼링됩니다. 내부 쓰기 버퍼의 총 크기가 `highWaterMark`로 설정된 임계값보다 낮은 동안, `writable.write()` 호출은 `true`를 반환합니다. 내부 버퍼의 크기가 `highWaterMark`에 도달하거나 초과하면, `false`가 반환됩니다.

`stream` API, 특히 [`stream.pipe()`](https://nodejs.org/docs/latest/api/stream.html#readablepipedestination-options) 메서드의 주요 목표는 데이터 버퍼링을 허용 가능한 수준으로 제한하여, 서로 다른 속도의 소스와 목적지가 사용 가능한 메모리를 초과하지 않도록 하는 것입니다.

`highWaterMark` 옵션은 임계값이며, 제한이 아닙니다. 이는 스트림이 더 많은 데이터를 요청하기 전에 버퍼링할 데이터의 양을 결정합니다. 일반적으로 엄격한 메모리 제한을 강제하지는 않습니다. 특정 스트림 구현체는 더 엄격한 제한을 적용할 수 있지만, 이는 선택 사항입니다.

[`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)와 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림은 모두 `Readable`과 `Writable`이므로, 각각 읽기와 쓰기를 위한 *두 개*의 별도 내부 버퍼를 유지합니다. 이를 통해 각 측면이 독립적으로 동작하면서도 적절하고 효율적인 데이터 흐름을 유지할 수 있습니다. 예를 들어, [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 인스턴스는 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림으로, `Readable` 측면은 소켓에서 받은 데이터를 소비할 수 있게 하고, `Writable` 측면은 소켓에 데이터를 쓸 수 있게 합니다. 데이터가 소켓에 쓰여지는 속도가 받는 속도보다 빠르거나 느릴 수 있으므로, 각 측면은 독립적으로 동작(및 버퍼링)해야 합니다.

내부 버퍼링의 메커니즘은 내부 구현 세부 사항이며 언제든지 변경될 수 있습니다. 그러나 특정 고급 구현의 경우, 내부 버퍼는 `writable.writableBuffer` 또는 `readable.readableBuffer`를 사용하여 검색할 수 있습니다. 이러한 문서화되지 않은 속성의 사용은 권장되지 않습니다.


### 스트림 소비자를 위한 API[#](https://nodejs.org/docs/latest/api/stream.html#api-for-stream-consumers)

거의 모든 Node.js 애플리케이션은 간단한 경우에도 스트림을 어떤 식으로든 사용합니다. 다음은 HTTP 서버를 구현한 Node.js 애플리케이션에서 스트림을 사용하는 예제입니다:

```js
const http = require('node:http');

const server = http.createServer((req, res) => {
    // `req`는 http.IncomingMessage로, 읽기 가능한 스트림입니다.
    // `res`는 http.ServerResponse로, 쓰기 가능한 스트림입니다.
    let body = '';

    // 데이터를 utf8 문자열로 가져옵니다.
    // 인코딩이 설정되지 않으면 Buffer 객체를 받게 됩니다.
    req.setEncoding('utf8');

    // 읽기 가능한 스트림은 리스너가 추가되면 'data' 이벤트를 발생시킵니다.
    req.on('data', (chunk) => {
        body += chunk;
    });

    // 'end' 이벤트는 전체 본문이 수신되었음을 나타냅니다.
    req.on('end', () => {
        try {
            const data = JSON.parse(body);
            // 사용자에게 흥미로운 내용을 다시 씁니다:
            res.write(typeof data);
            res.end();
        } catch (er) {
            // 잘못된 JSON 처리
            res.statusCode = 400;
            return res.end(`error: ${er.message}`);
        }
    });
});

server.listen(1337);

// $ curl localhost:1337 -d "{}" // object
// $ curl localhost:1337 -d "\"foo\"" // string
// $ curl localhost:1337 -d "not json" // error: Unexpected token 'o', "not json" is not valid JSON
```

[`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림(예제의 `res`와 같은)은 `write()` 및 `end()`와 같은 메서드를 제공하여 스트림에 데이터를 씁니다.

[`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림은 [`EventEmitter`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) API를 사용하여 애플리케이션 코드에 데이터를 읽을 수 있음을 알립니다. 이 데이터는 여러 가지 방법으로 스트림에서 읽을 수 있습니다.

[`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 및 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림은 모두 [`EventEmitter`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) API를 다양한 방식으로 사용하여 스트림의 현재 상태를 전달합니다.

[`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 및 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림은 모두 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 및 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림입니다.

스트림에 데이터를 쓰거나 스트림에서 데이터를 소비하는 애플리케이션은 스트림 인터페이스를 직접 구현할 필요가 없으며, 일반적으로 `require('node:stream')`을 호출할 이유가 없습니다.

새로운 타입의 스트림을 구현하려는 개발자는 [스트림 구현자를 위한 API](https://nodejs.org/docs/latest/api/stream.html#api-for-stream-implementers) 섹션을 참조해야 합니다.


#### 쓰기 가능 스트림(Writable Streams)

쓰기 가능 스트림은 데이터가 기록되는 *대상*을 추상화한 개념입니다.

[`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림의 예시는 다음과 같습니다:

-   [클라이언트 측의 HTTP 요청](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)
-   [서버 측의 HTTP 응답](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)
-   [파일 시스템 쓰기 스트림](https://nodejs.org/docs/latest/api/fs.html#class-fswritestream)
-   [zlib 스트림](https://nodejs.org/docs/latest/api/zlib.html)
-   [암호화 스트림](https://nodejs.org/docs/latest/api/crypto.html)
-   [TCP 소켓](https://nodejs.org/docs/latest/api/net.html#class-netsocket)
-   [자식 프로세스의 표준 입력](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdin)
-   [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout), [`process.stderr`](https://nodejs.org/docs/latest/api/process.html#processstderr)

이 중 일부는 실제로 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림이지만, [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 인터페이스를 구현하고 있습니다.

모든 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림은 `stream.Writable` 클래스에 정의된 인터페이스를 구현합니다.

각각의 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림 인스턴스는 다양한 차이점이 있을 수 있지만, 모든 `Writable` 스트림은 아래 예제와 같은 기본적인 사용 패턴을 따릅니다:

```js
const myStream = getWritableStreamSomehow();
myStream.write('some data');
myStream.write('some more data');
myStream.end('done writing data');
```


### 클래스: `stream.Writable`

추가된 버전: v0.9.4

#### 이벤트: `'close'`

`'close'` 이벤트는 스트림과 그 하위 리소스(예: 파일 디스크립터)가 닫혔을 때 발생합니다. 이 이벤트는 더 이상 이벤트가 발생하지 않고 추가적인 계산도 이루어지지 않음을 나타냅니다.

`Writable` 스트림은 `emitClose` 옵션과 함께 생성된 경우 항상 `'close'` 이벤트를 발생시킵니다.

#### 이벤트: `'drain'`

추가된 버전: v0.9.4

[`stream.write(chunk)`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback) 호출이 `false`를 반환하면, 스트림에 데이터를 다시 쓸 수 있을 때 `'drain'` 이벤트가 발생합니다.

```js
// 제공된 쓰기 가능한 스트림에 데이터를 백만 번 씁니다. 백프레셔에 주의하세요.
function writeOneMillionTimes(writer, data, encoding, callback) {
    let i = 1000000;
    write();
    function write() {
        let ok = true;
        do {
            i--;
            if (i === 0) {
                // 마지막!
                writer.write(data, encoding, callback);
            } else {
                // 계속할지, 기다릴지 확인합니다.
                // 아직 끝나지 않았으므로 콜백을 전달하지 않습니다.
                ok = writer.write(data, encoding);
            }
        } while (i > 0 && ok);
        if (i > 0) {
            // 일찍 멈춰야 함!
            // drain 이벤트가 발생하면 더 씁니다.
            writer.once('drain', write);
        }
    }
}
```

#### 이벤트: `'error'`

추가된 버전: v0.9.4

-   [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)

데이터를 쓰거나 파이핑하는 동안 오류가 발생하면 `'error'` 이벤트가 발생합니다. 리스너 콜백은 호출될 때 단일 `Error` 인자를 받습니다.

스트림은 `'error'` 이벤트가 발생하면 닫히며, 스트림 생성 시 [`autoDestroy`](https://nodejs.org/docs/latest/api/stream.html#new-streamwritableoptions) 옵션이 `false`로 설정된 경우는 예외입니다.

`'error'` 이후에는 `'close'` 이벤트를 제외한 다른 이벤트(다른 `'error'` 이벤트 포함)가 발생하지 않아야 합니다.

#### 이벤트: `'finish'`

추가된 버전: v0.9.4

`'finish'` 이벤트는 [`stream.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback) 메서드가 호출되고 모든 데이터가 하위 시스템으로 플러시된 후에 발생합니다.

```js
const writer = getWritableStreamSomehow();
for (let i = 0; i < 100; i++) {
    writer.write(`hello, #${i}!\n`);
}
writer.end('This is the end\n');
writer.on('finish', () => {
    console.log('모든 쓰기가 완료되었습니다.');
});
```

#### 이벤트: `'pipe'`

추가된 버전: v0.9.4

-   `src` [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 이 쓰기 가능한 스트림으로 파이핑되는 소스 스트림

`'pipe'` 이벤트는 읽기 가능한 스트림에서 [`stream.pipe()`](https://nodejs.org/docs/latest/api/stream.html#readablepipedestination-options) 메서드가 호출되어 이 쓰기 가능한 스트림이 목적지로 추가될 때 발생합니다.

```js
const writer = getWritableStreamSomehow();
const reader = getReadableStreamSomehow();
writer.on('pipe', (src) => {
    console.log('어떤 것이 writer로 파이핑되고 있습니다.');
    assert.equal(src, reader);
});
reader.pipe(writer);
```

#### 이벤트: `'unpipe'`

추가된 버전: v0.9.4

-   `src` [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 이 쓰기 가능한 스트림에서 파이프를 해제한 소스 스트림

`'unpipe'` 이벤트는 읽기 가능한 스트림에서 [`stream.unpipe()`](https://nodejs.org/docs/latest/api/stream.html#readableunpipedestination) 메서드가 호출되어 이 쓰기 가능한 스트림이 목적지에서 제거될 때 발생합니다.

이 이벤트는 읽기 가능한 스트림이 이 쓰기 가능한 스트림으로 파이핑될 때 오류가 발생한 경우에도 발생합니다.

```js
const writer = getWritableStreamSomehow();
const reader = getReadableStreamSomehow();
writer.on('unpipe', (src) => {
    console.log('어떤 것이 writer로 파이핑을 멈췄습니다.');
    assert.equal(src, reader);
});
reader.pipe(writer);
reader.unpipe(writer);
```

#### `writable.cork()`

추가된 버전: v0.11.2

`writable.cork()` 메서드는 모든 쓰기 데이터를 메모리에 버퍼링하도록 강제합니다. 버퍼링된 데이터는 [`stream.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork) 또는 [`stream.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback) 메서드가 호출될 때 플러시됩니다.

`writable.cork()`의 주요 목적은 여러 작은 청크가 빠르게 연속적으로 스트림에 쓰여지는 상황을 수용하는 것입니다. `writable.cork()`는 모든 청크를 `writable.uncork()`가 호출될 때까지 버퍼링하며, `writable._writev()`가 있는 경우 이를 통해 모든 청크를 전달합니다. 이는 첫 번째 작은 청크가 처리되기를 기다리는 동안 데이터가 버퍼링되는 헤드오브라인 블로킹 상황을 방지합니다. 그러나 `writable._writev()`를 구현하지 않고 `writable.cork()`를 사용하면 처리량에 부정적인 영향을 미칠 수 있습니다.

참고: [`writable.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork), [`writable._writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback).

#### `writable.destroy([error])`

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 선택 사항, `'error'` 이벤트와 함께 발생시킬 오류
-   반환: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

스트림을 파괴합니다. 선택적으로 `'error'` 이벤트를 발생시키고, `'close'` 이벤트를 발생시킵니다(`emitClose`가 `false`로 설정된 경우는 제외). 이 호출 이후 쓰기 가능한 스트림은 종료되며, 이후 `write()` 또는 `end()` 호출은 `ERR_STREAM_DESTROYED` 오류를 발생시킵니다. 이는 스트림을 즉시 파괴하는 파괴적이고 즉각적인 방법입니다. 이전 `write()` 호출이 드레인되지 않았을 수 있으며, `ERR_STREAM_DESTROYED` 오류를 발생시킬 수 있습니다. 데이터를 닫기 전에 플러시해야 한다면 `end()`를 사용하거나, 스트림을 파괴하기 전에 `'drain'` 이벤트를 기다리세요.

```js
const { Writable } = require('node:stream');
const myStream = new Writable();
const fooErr = new Error('foo error');
myStream.destroy(fooErr);
myStream.on('error', (fooErr) => console.error(fooErr.message)); // foo error
```

```js
const { Writable } = require('node:stream');
const myStream = new Writable();
myStream.destroy();
myStream.on('error', function wontHappen() {});
```

```js
const { Writable } = require('node:stream');
const myStream = new Writable();
myStream.destroy();
myStream.write('foo', (error) => console.error(error.code)); // ERR_STREAM_DESTROYED
```

`destroy()`가 호출된 후에는 추가 호출이 무시되며, `_destroy()`에서 발생한 오류를 제외한 다른 오류는 `'error'` 이벤트로 발생하지 않습니다.

구현자는 이 메서드를 재정의하지 말고, 대신 [`writable._destroy()`](https://nodejs.org/docs/latest/api/stream.html#writable_destroyerr-callback)를 구현해야 합니다.

#### `writable.closed`

추가된 버전: v18.0.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`'close'` 이벤트가 발생한 후 `true`가 됩니다.

#### `writable.destroyed`

추가된 버전: v8.0.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`writable.destroy()`](https://nodejs.org/docs/latest/api/stream.html#writabledestroyerror)가 호출된 후 `true`가 됩니다.

```js
const { Writable } = require('node:stream');
const myStream = new Writable();
console.log(myStream.destroyed); // false
myStream.destroy();
console.log(myStream.destroyed); // true
```

#### `writable.end([chunk[, encoding]][, callback])`

-   `chunk` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 쓸 데이터. 객체 모드가 아닌 스트림의 경우 `chunk`는 [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type), [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer), [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 또는 [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)여야 합니다. 객체 모드 스트림의 경우 `chunk`는 `null`이 아닌 모든 JavaScript 값일 수 있습니다.
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `chunk`가 문자열일 경우의 인코딩
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 스트림이 완료되었을 때의 콜백
-   반환: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

`writable.end()` 메서드를 호출하면 더 이상 데이터를 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)에 쓰지 않겠다는 신호를 보냅니다. 선택적 `chunk`와 `encoding` 인자를 사용하면 스트림을 닫기 전에 마지막으로 추가 데이터를 쓸 수 있습니다.

[`stream.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback)를 호출한 후 [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback) 메서드를 호출하면 오류가 발생합니다.

```js
// 'hello, '를 쓰고 'world!'로 끝냅니다.
const fs = require('node:fs');
const file = fs.createWriteStream('example.txt');
file.write('hello, ');
file.end('world!'); // 이제 더 이상 쓰기를 허용하지 않습니다!
```

#### `writable.setDefaultEncoding(encoding)`

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 새로운 기본 인코딩
-   반환: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

`writable.setDefaultEncoding()` 메서드는 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림의 기본 `encoding`을 설정합니다.

#### `writable.uncork()`

추가된 버전: v0.11.2

`writable.uncork()` 메서드는 [`stream.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork)가 호출된 이후 버퍼링된 모든 데이터를 플러시합니다.

[`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork)와 `writable.uncork()`를 사용하여 스트림에 쓰기를 버퍼링할 때, `process.nextTick()`을 사용하여 `writable.uncork()` 호출을 지연시키세요. 이렇게 하면 주어진 Node.js 이벤트 루프 단계 내에서 발생하는 모든 `writable.write()` 호출을 일괄 처리할 수 있습니다.

```js
stream.cork();
stream.write('some ');
stream.write('data ');
process.nextTick(() => stream.uncork());
```

[`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork) 메서드가 스트림에서 여러 번 호출된 경우, 버퍼링된 데이터를 플러시하려면 동일한 횟수만큼 `writable.uncork()`를 호출해야 합니다.

```js
stream.cork();
stream.write('some ');
stream.cork();
stream.write('data ');
process.nextTick(() => {
    stream.uncork(); // 두 번째 uncork()가 호출될 때까지 데이터가 플러시되지 않습니다.
    stream.uncork();
});
```

참고: [`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork).

#### `writable.writable`

추가된 버전: v11.4.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`writable.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)를 호출해도 안전한 경우 `true`입니다. 이는 스트림이 파괴되거나 오류가 발생하거나 종료되지 않았음을 의미합니다.

#### `writable.writableAborted`

추가된 버전: v18.0.0, v16.17.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

스트림이 `'finish'` 이벤트를 발생시키기 전에 파괴되었거나 오류가 발생했는지 여부를 반환합니다.

#### `writable.writableEnded`

추가된 버전: v12.9.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`writable.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback)가 호출된 후 `true`입니다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않으며, 이를 확인하려면 [`writable.writableFinished`](https://nodejs.org/docs/latest/api/stream.html#writablewritablefinished)를 사용하세요.

#### `writable.writableCorked`

추가된 버전: v13.2.0, v12.16.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

스트림을 완전히 언코크하기 위해 [`writable.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork)를 호출해야 하는 횟수입니다.

#### `writable.errored`

추가된 버전: v18.0.0

-   [`<Error>`](https://developer.mozilla.org/en-US/docs


#### 읽기 가능한 스트림(Readable Streams)

읽기 가능한 스트림은 데이터를 소비하는 *소스*를 추상화한 개념입니다.

`Readable` 스트림의 예시는 다음과 같습니다:

-   [클라이언트 측의 HTTP 응답](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   [서버 측의 HTTP 요청](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   [파일 시스템 읽기 스트림](https://nodejs.org/docs/latest/api/fs.html#class-fsreadstream)
-   [zlib 스트림](https://nodejs.org/docs/latest/api/zlib.html)
-   [암호화 스트림](https://nodejs.org/docs/latest/api/crypto.html)
-   [TCP 소켓](https://nodejs.org/docs/latest/api/net.html#class-netsocket)
-   [자식 프로세스의 stdout과 stderr](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdout)
-   [`process.stdin`](https://nodejs.org/docs/latest/api/process.html#processstdin)

모든 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림은 `stream.Readable` 클래스에 정의된 인터페이스를 구현합니다.


##### 두 가지 읽기 모드[#](https://nodejs.org/docs/latest/api/stream.html#two-reading-modes)

`Readable` 스트림은 크게 두 가지 모드로 동작합니다: **흐름 모드(flowing mode)**와 **일시 정지 모드(paused mode)**. 이 모드들은 [객체 모드(object mode)](https://nodejs.org/docs/latest/api/stream.html#object-mode)와는 별개입니다. `Readable` 스트림은 흐름 모드나 일시 정지 모드에 상관없이 객체 모드일 수도 있고, 아닐 수도 있습니다.

- **흐름 모드**에서는 데이터가 자동으로 시스템에서 읽혀지며, [`EventEmitter`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) 인터페이스를 통해 이벤트로 애플리케이션에 최대한 빠르게 제공됩니다.
  
- **일시 정지 모드**에서는 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize) 메서드를 명시적으로 호출해야 스트림에서 데이터 청크를 읽을 수 있습니다.

모든 `Readable` 스트림은 기본적으로 일시 정지 모드로 시작하지만, 다음 방법 중 하나를 통해 흐름 모드로 전환할 수 있습니다:

- [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트 핸들러를 추가하는 방법
- [`stream.resume()`](https://nodejs.org/docs/latest/api/stream.html#readableresume) 메서드를 호출하는 방법
- [`stream.pipe()`](https://nodejs.org/docs/latest/api/stream.html#readablepipedestination-options) 메서드를 호출하여 데이터를 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림으로 보내는 방법

`Readable` 스트림은 다음 방법 중 하나를 통해 다시 일시 정지 모드로 전환할 수 있습니다:

- 파이프 대상이 없는 경우, [`stream.pause()`](https://nodejs.org/docs/latest/api/stream.html#readablepause) 메서드를 호출하는 방법
- 파이프 대상이 있는 경우, 모든 파이프 대상을 제거하는 방법. 여러 파이프 대상을 제거하려면 [`stream.unpipe()`](https://nodejs.org/docs/latest/api/stream.html#readableunpipedestination) 메서드를 호출하면 됩니다.

중요한 개념은 `Readable` 스트림이 데이터를 소비하거나 무시할 메커니즘이 제공되지 않으면 데이터를 생성하지 않는다는 점입니다. 데이터 소비 메커니즘이 비활성화되거나 제거되면, `Readable` 스트림은 데이터 생성을 *중단하려고 시도*합니다.

하위 호환성을 위해, [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트 핸들러를 제거해도 스트림이 자동으로 일시 정지되지는 않습니다. 또한, 파이프 대상이 있는 경우 [`stream.pause()`](https://nodejs.org/docs/latest/api/stream.html#readablepause)를 호출해도 해당 대상이 데이터를 소비하고 더 많은 데이터를 요청하면 스트림이 *계속 일시 정지 상태를 유지*하지 않을 수 있습니다.

`Readable` 스트림이 흐름 모드로 전환되었는데 데이터를 처리할 소비자가 없으면 데이터는 손실됩니다. 예를 들어, `readable.resume()` 메서드를 호출했는데 `'data'` 이벤트에 리스너가 연결되어 있지 않거나, `'data'` 이벤트 핸들러가 스트림에서 제거된 경우에 이런 상황이 발생할 수 있습니다.

[`'readable'`](https://nodejs.org/docs/latest/api/stream.html#event-readable) 이벤트 핸들러를 추가하면 스트림이 자동으로 흐름을 멈추고, 데이터는 [`readable.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)를 통해 소비되어야 합니다. 만약 [`'readable'`](https://nodejs.org/docs/latest/api/stream.html#event-readable) 이벤트 핸들러가 제거되고, [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트 핸들러가 있다면 스트림은 다시 흐름 모드로 전환됩니다.


##### 세 가지 상태

`Readable` 스트림의 "두 가지 모드"는 `Readable` 스트림 구현 내부에서 발생하는 복잡한 상태 관리를 단순화한 추상화입니다.

구체적으로, 특정 시점에서 모든 `Readable` 스트림은 다음 세 가지 상태 중 하나에 있습니다:

- `readable.readableFlowing === null`
- `readable.readableFlowing === false`
- `readable.readableFlowing === true`

`readable.readableFlowing`이 `null`일 때는 스트림의 데이터를 소비할 수 있는 메커니즘이 제공되지 않습니다. 따라서 스트림은 데이터를 생성하지 않습니다. 이 상태에서 `'data'` 이벤트 리스너를 추가하거나, `readable.pipe()` 메서드를 호출하거나, `readable.resume()` 메서드를 호출하면 `readable.readableFlowing`이 `true`로 변경됩니다. 이로 인해 `Readable` 스트림이 데이터를 생성하면서 이벤트를 활발히 발생시키기 시작합니다.

`readable.pause()`를 호출하거나, `readable.unpipe()`를 호출하거나, 백프레셔(backpressure)를 받게 되면 `readable.readableFlowing`이 `false`로 설정됩니다. 이는 이벤트의 흐름을 일시적으로 중단하지만, 데이터 생성을 멈추지는 않습니다. 이 상태에서 `'data'` 이벤트 리스너를 추가해도 `readable.readableFlowing`이 `true`로 변경되지 않습니다.

```js
const { PassThrough, Writable } = require('node:stream');
const pass = new PassThrough();
const writable = new Writable();

pass.pipe(writable);
pass.unpipe(writable); // readableFlowing은 이제 false입니다.
pass.on('data', (chunk) => {
    console.log(chunk.toString());
}); // readableFlowing은 여전히 false입니다.
pass.write('ok'); // 'data' 이벤트를 발생시키지 않습니다.
pass.resume(); // 스트림이 'data' 이벤트를 발생시키려면 이 메서드를 호출해야 합니다.
// readableFlowing은 이제 true입니다.
```

`readable.readableFlowing`이 `false`인 동안, 데이터는 스트림의 내부 버퍼에 축적될 수 있습니다.


`Readable` 스트림 API는 여러 Node.js 버전에 걸쳐 발전했으며, 스트림 데이터를 소비하는 다양한 방법을 제공합니다. 일반적으로 개발자는 데이터를 소비하는 방법 중 *하나*를 선택해야 하며, 단일 스트림에서 여러 방법을 동시에 사용해서는 *안 됩니다*. 특히, `on('data')`, `on('readable')`, `pipe()`, 또는 비동기 이터레이터를 조합하여 사용하면 예상치 못한 동작이 발생할 수 있습니다.


### 클래스: `stream.Readable`

추가된 버전: v0.9.4

#### 이벤트: `'close'`

`'close'` 이벤트는 스트림과 그 하위 리소스(예: 파일 디스크립터)가 닫힐 때 발생합니다. 이 이벤트는 더 이상 이벤트가 발생하지 않고 추가적인 계산이 이루어지지 않음을 나타냅니다.

`Readable` 스트림은 `emitClose` 옵션과 함께 생성된 경우 항상 `'close'` 이벤트를 발생시킵니다.

#### 이벤트: `'data'`

추가된 버전: v0.9.4

- `chunk` `<Buffer>` | `<string>` | `<any>` 데이터 청크. 객체 모드가 아닌 스트림의 경우 청크는 문자열 또는 `Buffer`입니다. 객체 모드 스트림의 경우 청크는 `null`이 아닌 모든 JavaScript 값이 될 수 있습니다.

`'data'` 이벤트는 스트림이 데이터 청크의 소유권을 소비자에게 넘길 때마다 발생합니다. 이는 `readable.pipe()`, `readable.resume()`을 호출하거나 `'data'` 이벤트에 리스너 콜백을 연결하여 스트림이 흐름 모드로 전환될 때 발생할 수 있습니다. 또한 `readable.read()` 메서드가 호출되고 반환할 데이터 청크가 있을 때도 `'data'` 이벤트가 발생합니다.

명시적으로 일시 정지되지 않은 스트림에 `'data'` 이벤트 리스너를 연결하면 스트림이 흐름 모드로 전환됩니다. 데이터는 사용 가능한 즉시 전달됩니다.

리스너 콜백은 `readable.setEncoding()` 메서드를 사용하여 스트림에 기본 인코딩이 지정된 경우 문자열로 데이터 청크를 전달받습니다. 그렇지 않으면 데이터는 `Buffer`로 전달됩니다.

```js
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) => {
    console.log(`Received ${chunk.length} bytes of data.`);
});
```

#### 이벤트: `'end'`

추가된 버전: v0.9.4

`'end'` 이벤트는 스트림에서 소비할 데이터가 더 이상 없을 때 발생합니다.

데이터가 완전히 소비되지 않으면 `'end'` 이벤트가 **발생하지 않습니다**. 이는 스트림을 흐름 모드로 전환하거나 모든 데이터가 소비될 때까지 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)를 반복적으로 호출하여 달성할 수 있습니다.

```js
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) => {
    console.log(`Received ${chunk.length} bytes of data.`);
});
readable.on('end', () => {
    console.log('There will be no more data.');
});
```

#### 이벤트: `'error'`

추가된 버전: v0.9.4

- `<Error>`

`'error'` 이벤트는 `Readable` 구현체가 언제든지 발생시킬 수 있습니다. 일반적으로 이는 기본 스트림이 내부 오류로 인해 데이터를 생성할 수 없거나 스트림 구현체가 유효하지 않은 데이터 청크를 푸시하려고 할 때 발생할 수 있습니다.

리스너 콜백은 단일 `Error` 객체를 전달받습니다.

#### 이벤트: `'pause'`

추가된 버전: v0.9.4

`'pause'` 이벤트는 [`stream.pause()`](https://nodejs.org/docs/latest/api/stream.html#readablepause)가 호출되고 `readableFlowing`이 `false`가 아닐 때 발생합니다.

#### 이벤트: `'readable'`

`'readable'` 이벤트는 스트림에서 읽을 수 있는 데이터가 있을 때, 설정된 high water mark(`state.highWaterMark`)까지 발생합니다. 이는 스트림의 버퍼 내에 새로운 정보가 있음을 나타냅니다. 이 버퍼 내에 데이터가 있으면 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)를 호출하여 해당 데이터를 검색할 수 있습니다. 또한 스트림의 끝에 도달했을 때도 `'readable'` 이벤트가 발생할 수 있습니다.

```js
const readable = getReadableStreamSomehow();
readable.on('readable', function() {
    // 이제 읽을 데이터가 있습니다.
    let data;
    while ((data = this.read()) !== null) {
        console.log(data);
    }
});
```

스트림의 끝에 도달하면 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)를 호출하면 `null`을 반환하고 `'end'` 이벤트를 발생시킵니다. 읽을 데이터가 전혀 없었던 경우에도 마찬가지입니다. 예를 들어, 다음 예제에서 `foo.txt`는 빈 파일입니다:

```js
const fs = require('node:fs');
const rr = fs.createReadStream('foo.txt');
rr.on('readable', () => {
    console.log(`readable: ${rr.read()}`);
});
rr.on('end', () => {
    console.log('end');
});
```

이 스크립트를 실행한 출력은 다음과 같습니다:

```console
$ node test.js
readable: null
end
```

일부 경우, `'readable'` 이벤트에 리스너를 연결하면 일부 데이터가 내부 버퍼로 읽혀질 수 있습니다.

일반적으로 `readable.pipe()`와 `'data'` 이벤트 메커니즘이 `'readable'` 이벤트보다 이해하기 쉽습니다. 그러나 `'readable'`을 처리하면 처리량이 증가할 수 있습니다.

`'readable'`과 [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data)를 동시에 사용하면 `'readable'`이 흐름을 제어하는 데 우선순위를 가지며, 즉 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)가 호출될 때만 `'data'` 이벤트가 발생합니다. `readableFlowing` 속성은 `false`가 됩니다. `'readable'`이 제거될 때 `'data'` 리스너가 있으면 스트림이 흐르기 시작하며, 즉 `.resume()`을 호출하지 않고도 `'data'` 이벤트가 발생합니다.

#### 이벤트: `'resume'`

추가된 버전: v0.9.4

`'resume'` 이벤트는 [`stream.resume()`](https://nodejs.org/docs/latest/api/stream.html#readableresume)가 호출되고 `readableFlowing`이 `true`가 아닐 때 발생합니다.

#### `readable.destroy([error])`

- `error` `<Error>` `'error'` 이벤트에서 페이로드로 전달될 오류
- 반환: `<this>`

스트림을 파괴합니다. 선택적으로 `'error'` 이벤트를 발생시키고 `'close'` 이벤트를 발생시킵니다(`emitClose`가 `false`로 설정되지 않은 경우). 이 호출 후, 읽기 가능한 스트림은 모든 내부 리소스를 해제하고 이후 `push()` 호출은 무시됩니다.

`destroy()`가 호출된 후 추가 호출은 아무 작업도 수행하지 않으며 `_destroy()`에서 발생한 오류를 제외하고 더 이상 오류가 발생하지 않습니다.

구현자는 이 메서드를 재정의하지 말고 대신 [`readable._destroy()`](https://nodejs.org/docs/latest/api/stream.html#readable_destroyerr-callback)를 구현해야 합니다.

#### `readable.closed`

추가된 버전: v18.0.0

- `<boolean>`

`'close'` 이벤트가 발생한 후 `true`입니다.

#### `readable.destroyed`

추가된 버전: v8.0.0

- `<boolean>`

[`readable.destroy()`](https://nodejs.org/docs/latest/api/stream.html#readabledestroyerror)가 호출된 후 `true`입니다.

#### `readable.isPaused()`

추가된 버전: v0.11.14

- 반환: `<boolean>`

`readable.isPaused()` 메서드는 `Readable`의 현재 운영 상태를 반환합니다. 이는 주로 `readable.pipe()` 메서드의 기반이 되는 메커니즘에서 사용됩니다. 대부분의 일반적인 경우에는 이 메서드를 직접 사용할 이유가 없습니다.

```js
const readable = new stream.Readable();
readable.isPaused(); // === false
readable.pause();
readable.isPaused(); // === true
readable.resume();
readable.isPaused(); // === false
```

#### `readable.pause()`

추가된 버전: v0.9.4

- 반환: `<this>`

`readable.pause()` 메서드는 흐름 모드의 스트림이 [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트를 발생시키지 않도록 하고 흐름 모드에서 벗어나게 합니다. 사용 가능한 데이터는 내부 버퍼에 남아 있습니다.

```js
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) => {
    console.log(`Received ${chunk.length} bytes of data.`);
    readable.pause();
    console.log('There will be no additional data for 1 second.');
    setTimeout(() => {
        console.log('Now data will start flowing again.');
        readable.resume();
    }, 1000);
});
```

`'readable'` 이벤트 리스너가 있으면 `readable.pause()` 메서드는 아무 효과가 없습니다.

#### `readable.pipe(destination[, options])`

추가된 버전: v0.9.4

- `destination` `<stream.Writable>` 데이터를 쓸 대상
- `options` `<Object>` 파이프 옵션
    - `end` `<boolean>` 리더가 끝나면 라이터를 종료합니다. **기본값:** `true`.
- 반환: `<stream.Writable>` 대상, [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 또는 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림인 경우 파이프 체인을 허용합니다.

`readable.pipe()` 메서드는 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림을 `readable`에 연결하여 자동으로 흐름 모드로 전환하고 모든 데이터를 연결된 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)로 푸시합니다. 데이터 흐름은 대상 `Writable` 스트림이 더 빠른 `Readable` 스트림에 압도되지 않도록 자동으로 관리됩니다.

다음 예제는 `readable`의 모든 데이터를 `file.txt`라는 파일로 파이프합니다:

```js
const fs = require('node:fs');
const readable = getReadableStreamSomehow();
const writable = fs.createWriteStream('file.txt');
// readable의 모든 데이터가 'file.txt'로 들어갑니다.
readable.pipe(writable);
```

단일 `Readable` 스트림에 여러 `Writable` 스트림을 연결할 수 있습니다.

`readable.pipe()` 메서드는 대상 스트림에 대한 참조를 반환하여 파이프된 스트림 체인을 설정할 수 있게 합니다:

```js
const fs = require('node:fs');
const zlib = require('node:zlib');
const r = fs.createReadStream('file.txt');
const z = zlib.createGzip();
const w = fs.createWriteStream('file.txt.gz');
r.pipe(z).pipe(w);
```

기본적으로, 소스 `Readable` 스트림이 [`'end'`](https://nodejs.org/docs/latest/api/stream.html#event-end) 이벤트를 발생시키면 대상 `Writable` 스트림에서 [`stream.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback)가 호출되어 대상이 더 이상 쓰기 가능하지 않게 됩니다. 이 기본 동작을 비활성화하려면 `end` 옵션을 `false`로 전달하여 대상 스트림이 열린 상태로 유지되도록 할 수 있습니다:

```js
reader.pipe(writer, { end: false });
reader.on('end', () => {
    writer.end('Goodbye\n');
});
```

중요한 주의사항은 `Readable` 스트림이 처리 중 오류를 발생시키면 `Writable` 대상이 **자동으로 닫히지 않는다**는 것입니다. 오류가 발생하면 메모리 누수를 방지하기 위해 각 스트림을 **수동으로** 닫아야 합니다.

[`process.stderr`](https://nodejs.org/docs/latest/api/process.html#processstderr)와 [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout) `Writable` 스트림은 지정된 옵션에 관계없이 Node.js 프로세스가 종료될 때까지 닫히지 않습니다.

#### `readable.read([size])`

추가된 버전: v0.9.4

- `size` `<number>` 읽을 데이터 양을 지정하는 선택적 인수
- 반환: `<string>` | `<Buffer>` | `<null>` | `<any>`

`readable.read()` 메서드는 내부 버퍼에서 데이터를 읽어 반환합니다. 읽을 데이터가 없으면 `null`을 반환합니다. 기본적으로 데이터는 `readable.setEncoding()` 메서드를 사용하여 인코딩이 지정되지 않았거나 스트림이 객체 모드에서 작동하지 않는 한 `Buffer` 객체로 반환됩니다.

선택적 `size` 인수는 읽을 특정 바이트 수를 지정합니다. `size` 바이트를 읽을 수 없으면 `null`이 반환됩니다. 단, 스트림이 끝난 경우 내부 버퍼에 남아 있는 모든 데이터가 반환됩니다.

`size` 인수가 지정되지 않으면 내부 버퍼에 포함된 모든 데이터가 반환됩니다.

`size` 인수는 1 GiB 이하여야 합니다.

`readable.read()` 메서드는 일시 정지 모드에서 작동하는 `Readable` 스트림에서만 호출해야 합니다. 흐름 모드에서는 내부 버퍼가 완전히 비워질 때까지 `readable.read()`가 자동으로 호출됩니다.

```js
const readable = getReadableStreamSomehow();
// 'readable'은 데이터가 버퍼에 들어올 때 여러 번 트리거될 수 있습니다.
readable.on('readable', () => {
    let chunk;
    console.log('Stream is readable (new data received in buffer)');
    // 현재 사용 가능한 모든 데이터를 읽기 위해 루프를 사용합니다.
    while (null !== (chunk = readable.read())) {
        console.log(`Read ${chunk.length} bytes of data...`);
    }
});
// 'end'는 더 이상 데이터가 없을 때 한 번 트리거됩니다.
readable.on('end', () => {
    console.log('Reached end of stream.');
});
```

`readable.read()`를 호출할 때마다 데이터 청크 또는 `null`이 반환되며, 이는 해당 시점에 더 이상 읽을 데이터가 없음을 나타냅니다. 이러한 청크는 자동으로 연결되지 않습니다. 단일 `read()` 호출이 모든 데이터를 반환하지 않으므로 모든 데이터를 검색할 때까지 청크를 계속 읽기 위해 while 루프가 필요할 수 있습니다. 큰 파일을 읽을 때 `.read()`는 일시적으로 `null`을 반환할 수 있으며, 이는 버퍼링된 모든 콘텐츠를 소비했지만 아직 버퍼링되지 않은 데이터가 더 있을 수 있음을 나타냅니다. 이러한 경우 버퍼에 더 많은 데이터가 있으면 새로운 `'readable'` 이벤트가 발생하고, `'end'` 이벤트는 데이터 전송의 끝을 나타냅니다.

따라서 `readable`에서 파일의 전체 내용을 읽으려면 여러 `'readable'` 이벤트에 걸쳐 청크를 수집해야 합니다:

```js
const chunks = [];
readable.on('readable', () => {
    let chunk;
    while (null !== (chunk = readable.read())) {
        chunks.push(chunk);
    }
});
readable.on('end', () => {
    const content = chunks.join('');
});
```

객체 모드의 `Readable` 스트림은 [`readable.read(size)`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize) 호출에서 항상 단일 항목을 반환하며, `size` 인수의 값에 관계없이 반환됩니다.

`readable.read()` 메서드가 데이터 청크를 반환하면 `'data'` 이벤트도 발생합니다.

[`'end'`](https://nodejs.org/docs/latest/api/stream.html#event-end) 이벤트가 발생한 후 [`stream.read([size])`](https://node


#### Duplex and transform streams[#](https://nodejs.org/docs/latest/api/stream.html#duplex-and-transform-streams)





### 클래스: `stream.Duplex`

`Duplex` 스트림은 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)과 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 인터페이스를 모두 구현한 스트림입니다.

`Duplex` 스트림의 예시는 다음과 같습니다:

-   [TCP 소켓](https://nodejs.org/docs/latest/api/net.html#class-netsocket)
-   [zlib 스트림](https://nodejs.org/docs/latest/api/zlib.html)
-   [crypto 스트림](https://nodejs.org/docs/latest/api/crypto.html)

#### `duplex.allowHalfOpen`

추가된 버전: v0.9.4

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 값이 `false`로 설정되면, 스트림은 읽기 가능한 쪽이 끝나면 쓰기 가능한 쪽도 자동으로 종료합니다. 이 값은 `allowHalfOpen` 생성자 옵션에 의해 초기화되며, 기본값은 `true`입니다.

이 값을 수동으로 변경하여 기존 `Duplex` 스트림 인스턴스의 반쪽 열림(half-open) 동작을 변경할 수 있습니다. 단, `'end'` 이벤트가 발생하기 전에 변경해야 합니다.


##### 클래스: `stream.Transform`[#](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform)

추가된 버전: v0.9.4

`Transform` 스트림은 출력이 입력과 어떤 방식으로든 관련이 있는 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림입니다. 모든 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림과 마찬가지로, `Transform` 스트림은 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)과 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 인터페이스를 모두 구현합니다.

`Transform` 스트림의 예시로는 다음과 같은 것들이 있습니다:

-   [zlib 스트림](https://nodejs.org/docs/latest/api/zlib.html)
-   [crypto 스트림](https://nodejs.org/docs/latest/api/crypto.html)

###### `transform.destroy([error])`[#](https://nodejs.org/docs/latest/api/stream.html#transformdestroyerror)

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

스트림을 파괴하고, 선택적으로 `'error'` 이벤트를 발생시킵니다. 이 호출 이후, `Transform` 스트림은 내부 리소스를 해제합니다. 구현자는 이 메서드를 오버라이드하지 말고, 대신 [`readable._destroy()`](https://nodejs.org/docs/latest/api/stream.html#readable_destroyerr-callback)를 구현해야 합니다. `Transform`의 `_destroy()` 기본 구현은 `emitClose`가 false로 설정되지 않은 한 `'close'` 이벤트도 발생시킵니다.

`destroy()`가 호출된 후에는 추가 호출이 무시되며, `_destroy()`에서 발생한 오류를 제외하고는 더 이상 `'error'` 이벤트가 발생하지 않습니다.


##### `stream.duplexPair([options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamduplexpairoptions)

추가된 버전: v22.6.0, v20.17.0

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 두 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 생성자에 전달할 값으로, 버퍼링과 같은 옵션을 설정할 수 있습니다.
-   반환값: [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) 두 개의 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 인스턴스를 포함한 배열.

`duplexPair` 유틸리티 함수는 두 개의 항목을 가진 배열을 반환합니다. 각 항목은 서로 연결된 `Duplex` 스트림입니다:

```js
const [ sideA, sideB ] = duplexPair();
```

한 스트림에 쓰여진 데이터는 다른 스트림에서 읽을 수 있습니다. 이는 네트워크 연결과 유사한 동작을 제공합니다. 클라이언트가 쓴 데이터는 서버에서 읽을 수 있고, 그 반대도 마찬가지입니다.

`Duplex` 스트림은 대칭적입니다. 어느 한쪽을 사용해도 동작에 차이가 없습니다.


#### `stream.finished(stream[, options], callback)`[#](https://nodejs.org/docs/latest/api/stream.html#streamfinishedstream-options-callback)

-   `stream` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream) 읽기 가능하거나 쓰기 가능한 스트림 또는 웹 스트림.
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `error` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`로 설정하면 `emit('error', err)` 호출이 완료된 것으로 처리되지 않음. **기본값:** `true`.
    -   `readable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`로 설정하면 스트림이 여전히 읽기 가능한 상태에서도 스트림이 끝나면 콜백이 호출됨. **기본값:** `true`.
    -   `writable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`로 설정하면 스트림이 여전히 쓰기 가능한 상태에서도 스트림이 끝나면 콜백이 호출됨. **기본값:** `true`.
    -   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) 스트림 완료를 기다리는 것을 중단할 수 있음. 신호가 중단되더라도 기본 스트림은 중단되지 않음. 콜백은 `AbortError`와 함께 호출됨. 이 함수에 의해 추가된 모든 등록된 리스너도 제거됨.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 선택적 오류 인자를 받는 콜백 함수.
-   반환값: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 모든 등록된 리스너를 제거하는 정리 함수.

이 함수는 스트림이 더 이상 읽기 가능하지 않거나 쓰기 가능하지 않거나, 오류가 발생했거나, 조기 종료 이벤트가 발생했을 때 알림을 받기 위해 사용됨.

```js
const { finished } = require('node:stream');
const fs = require('node:fs');
const rs = fs.createReadStream('archive.tar');

finished(rs, (err) => {
    if (err) {
        console.error('스트림 실패.', err);
    } else {
        console.log('스트림 읽기 완료.');
    }
});

rs.resume(); // 스트림을 비움.
```

특히, 중단된 HTTP 요청과 같이 스트림이 조기 종료되어 `'end'`나 `'finish'` 이벤트를 발생시키지 않는 오류 처리 시나리오에서 유용함.

`finished` API는 [Promise 버전](https://nodejs.org/docs/latest/api/stream.html#streamfinishedstream-options)도 제공함.

`stream.finished()`는 콜백이 호출된 후에도 `'error'`, `'end'`, `'finish'`, `'close'`와 같은 이벤트 리스너를 남겨둠. 이는 잘못된 스트림 구현으로 인해 예기치 않은 `'error'` 이벤트가 예기치 않은 충돌을 일으키지 않도록 하기 위함임. 이 동작이 원치 않는다면 콜백에서 반환된 정리 함수를 호출해야 함:

```js
const cleanup = finished(rs, (err) => {
    cleanup();
    // ...
});
```


#### `stream.pipeline(source[, ...transforms], destination, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-callback)





#### `stream.pipeline(streams, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#streampipelinestreams-callback)

-   `streams` [`<Stream\[\]>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Iterable\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable\[\]>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<ReadableStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream) | [`<TransformStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-transformstream)
-   `source` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Iterable>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
    -   반환값: [`<Iterable>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
-   `...transforms` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<TransformStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-transformstream)
    -   `source` [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
    -   반환값: [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
-   `destination` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)
    -   `source` [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface)
    -   반환값: [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 파이프라인이 완전히 끝나면 호출된다.
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `val` `destination`이 반환한 `Promise`의 해결된 값.
-   반환값: [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream)

이 메서드는 스트림과 제너레이터 간에 파이프를 연결하고, 오류를 전달하며, 파이프라인이 완료되면 콜백을 제공한다. 또한 적절한 정리 작업을 수행한다.

```js
const { pipeline } = require('node:stream');
const fs = require('node:fs');
const zlib = require('node:zlib');

// 파이프라인 API를 사용하여 여러 스트림을 쉽게 연결하고,
// 파이프라인이 완전히 끝났을 때 알림을 받을 수 있다.
// 아주 큰 tar 파일을 효율적으로 gzip으로 압축하는 파이프라인:
pipeline(
    fs.createReadStream('archive.tar'),
    zlib.createGzip(),
    fs.createWriteStream('archive.tar.gz'),
    (err) => {
        if (err) {
            console.error('파이프라인 실패.', err);
        } else {
            console.log('파이프라인 성공.');
        }
    }
);
```

`pipeline` API는 [Promise 버전](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-options)도 제공한다.

`stream.pipeline()`은 다음을 제외한 모든 스트림에 대해 `stream.destroy(err)`를 호출한다:

-   `'end'` 또는 `'close'`를 이미 발생시킨 `Readable` 스트림.
-   `'finish'` 또는 `'close'`를 이미 발생시킨 `Writable` 스트림.

`stream.pipeline()`은 콜백이 호출된 후에도 스트림에 이벤트 리스너를 남겨둔다. 실패 후 스트림을 재사용하는 경우, 이로 인해 이벤트 리스너 누수와 오류가 무시될 수 있다. 마지막 스트림이 읽기 가능한 경우, 나중에 소비할 수 있도록 이벤트 리스너가 제거된다.

`stream.pipeline()`은 오류가 발생하면 모든 스트림을 닫는다. `IncomingRequest`와 `pipeline`을 함께 사용하면 예상치 못한 동작이 발생할 수 있다. 이는 예상된 응답을 보내지 않고 소켓을 파괴할 수 있기 때문이다. 아래 예제를 참고하라:

```js
const fs = require('node:fs');
const http = require('node:http');
const { pipeline } = require('node:stream');

const server = http.createServer((req, res) => {
    const fileStream = fs.createReadStream('./fileNotExist.txt');
    pipeline(fileStream, res, (err) => {
        if (err) {
            console.log(err); // 파일이 없음
            // `pipeline`이 이미 소켓을 파괴했기 때문에 이 메시지를 보낼 수 없음
            return res.end('오류!!!');
        }
    });
});
```


#### `stream.compose(...streams)`[#](https://nodejs.org/docs/latest/api/stream.html#streamcomposestreams)

-   `streams` [`<Stream\[\]>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Iterable\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable\[\]>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<ReadableStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream) | [`<TransformStream\[\]>`](https://nodejs.org/docs/latest/api/webstreams.html#class-transformstream) | [`<Duplex\[\]>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

두 개 이상의 스트림을 하나의 `Duplex` 스트림으로 결합합니다. 이 스트림은 첫 번째 스트림에 쓰고 마지막 스트림에서 읽습니다. 제공된 각 스트림은 `stream.pipeline`을 사용해 다음 스트림으로 연결됩니다. 만약 어떤 스트림에서 오류가 발생하면, 모든 스트림이 파괴되며, 외부 `Duplex` 스트림도 포함됩니다.

`stream.compose`는 새로운 스트림을 반환하며, 이 스트림은 다시 다른 스트림으로 연결될 수 있습니다(그리고 연결되어야 합니다). 이는 스트림을 합성할 수 있게 해줍니다. 반면, `stream.pipeline`에 스트림을 전달할 때는 일반적으로 첫 번째 스트림이 읽기 가능한 스트림이고 마지막 스트림이 쓰기 가능한 스트림이어야 하며, 이는 폐쇄된 회로를 형성합니다.

만약 `Function`이 전달되면, 이 함수는 `source` `Iterable`을 인자로 받는 팩토리 메서드여야 합니다.

```js
import { compose, Transform } from 'node:stream';

const removeSpaces = new Transform({
    transform(chunk, encoding, callback) {
        callback(null, String(chunk).replace(' ', ''));
    },
});

async function* toUpper(source) {
    for await (const chunk of source) {
        yield String(chunk).toUpperCase();
    }
}

let res = '';
for await (const buf of compose(removeSpaces, toUpper).end('hello world')) {
    res += buf;
}

console.log(res); // 'HELLOWORLD' 출력
```

`stream.compose`는 비동기 이터러블, 제너레이터, 함수를 스트림으로 변환하는 데 사용할 수 있습니다.

-   `AsyncIterable`은 읽기 가능한 `Duplex`로 변환됩니다. `null`을 반환할 수 없습니다.
-   `AsyncGeneratorFunction`은 읽기/쓰기 가능한 변환 `Duplex`로 변환됩니다. 첫 번째 매개변수로 `source` `AsyncIterable`을 받아야 합니다. `null`을 반환할 수 없습니다.
-   `AsyncFunction`은 쓰기 가능한 `Duplex`로 변환됩니다. `null` 또는 `undefined`를 반환해야 합니다.

```js
import { compose } from 'node:stream';
import { finished } from 'node:stream/promises';

// AsyncIterable을 읽기 가능한 Duplex로 변환
const s1 = compose(async function*() {
    yield 'Hello';
    yield 'World';
}());

// AsyncGenerator를 변환 Duplex로 변환
const s2 = compose(async function*(source) {
    for await (const chunk of source) {
        yield String(chunk).toUpperCase();
    }
});

let res = '';

// AsyncFunction을 쓰기 가능한 Duplex로 변환
const s3 = compose(async function(source) {
    for await (const chunk of source) {
        res += chunk;
    }
});

await finished(compose(s1, s2, s3));
console.log(res); // 'HELLOWORLD' 출력
```

`stream.compose`를 연산자로 사용하는 방법은 [`readable.compose(stream)`](https://nodejs.org/docs/latest/api/stream.html#readablecomposestream-options)를 참고하세요.


#### `stream.Readable.from(iterable[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamreadablefromiterable-options)

추가된 버전: v12.3.0, v10.17.0

-   `iterable` [`<Iterable>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) `Symbol.asyncIterator` 또는 `Symbol.iterator` 이터러블 프로토콜을 구현한 객체. `null` 값이 전달되면 'error' 이벤트를 발생시킨다.
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `new stream.Readable([options])`에 제공되는 옵션. 기본적으로 `Readable.from()`은 `options.objectMode`를 `true`로 설정한다. 단, `options.objectMode`를 `false`로 명시적으로 설정하면 이 동작을 변경할 수 있다.
-   반환값: [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)

이터레이터로부터 읽기 가능한 스트림을 생성하는 유틸리티 메서드이다.

```js
const { Readable } = require('node:stream');

async function* generate() {
    yield 'hello';
    yield 'streams';
}

const readable = Readable.from(generate());

readable.on('data', (chunk) => {
    console.log(chunk);
});
```

성능상의 이유로 `Readable.from(string)` 또는 `Readable.from(buffer)`를 호출하면 문자열이나 버퍼가 이터레이트되지 않는다. 이는 다른 스트림의 의미와 일치시키기 위함이다.

프로미스를 포함한 `Iterable` 객체를 인자로 전달하면, 처리되지 않은 거부(unhandled rejection)가 발생할 수 있다.

```js
const { Readable } = require('node:stream');

Readable.from([
    new Promise((resolve) => setTimeout(resolve('1'), 1500)),
    new Promise((_, reject) => setTimeout(reject(new Error('2')), 1000)), // 처리되지 않은 거부
]);
```


#### `stream.Readable.fromWeb(readableStream[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamreadablefromwebreadablestream-options)

v17.0.0에서 추가됨

-   `readableStream` [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `highWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `objectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)
-   반환값: [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)


#### `stream.Readable.isDisturbed(stream)`[#](https://nodejs.org/docs/latest/api/stream.html#streamreadableisdisturbedstream)

추가된 버전: v16.8.0

-   `stream` [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
-   반환값: `boolean`

스트림이 읽히거나 취소되었는지 여부를 반환합니다.


#### `stream.isErrored(stream)`[#](https://nodejs.org/docs/latest/api/stream.html#streamiserroredstream)

추가된 버전: v17.3.0, v16.14.0

-   `stream` [`<Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`<Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) | [`<Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

스트림이 오류를 만났는지 여부를 반환합니다.


#### `stream.isReadable(stream)`[#](https://nodejs.org/docs/latest/api/stream.html#streamisreadablestream)

추가된 버전: v17.4.0, v16.14.0

-   `stream` [`<Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`<Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

스트림이 읽을 수 있는 상태인지 여부를 반환합니다.


#### `stream.Readable.toWeb(streamReadable[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamreadabletowebstreamreadable-options)

추가된 버전: v17.0.0

-   `streamReadable` [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `strategy` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
        -   `highWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 `ReadableStream`의 내부 큐 최대 크기. 이 값을 초과하면 주어진 `stream.Readable`에서 읽을 때 백프레셔가 적용된다. 값을 제공하지 않으면 주어진 `stream.Readable`에서 값을 가져온다.
        -   `size` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 데이터 청크의 크기를 계산하는 함수. 값을 제공하지 않으면 모든 청크의 크기는 `1`로 설정된다.
            -   `chunk` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
            -   반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   반환값: [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)


#### `stream.Writable.fromWeb(writableStream[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamwritablefromwebwritablestream-options)

**추가된 버전:** v17.0.0

-   `writableStream` [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `decodeStrings` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `highWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `objectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)
-   **반환값:** [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)

이 메서드는 웹 스트림 API의 `WritableStream`을 Node.js의 `stream.Writable`로 변환합니다. `options` 객체를 통해 다양한 설정을 지정할 수 있습니다. `decodeStrings`, `highWaterMark`, `objectMode`, `signal` 등의 옵션을 사용하여 스트림의 동작을 세부적으로 제어할 수 있습니다. 이 메서드는 변환된 `stream.Writable` 인스턴스를 반환합니다.


#### `stream.Writable.toWeb(streamWritable)`[#](https://nodejs.org/docs/latest/api/stream.html#streamwritabletowebstreamwritable)

추가된 버전: v17.0.0

-   `streamWritable` [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)
-   반환값: [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)

이 메서드는 Node.js의 `stream.Writable` 객체를 웹 표준 `WritableStream`으로 변환합니다. 이를 통해 Node.js 스트림을 웹 스트림 API와 호환되게 만들 수 있습니다.

```javascript
const { Writable } = require('stream');
const { WritableStream } = require('stream/web');

const nodeWritable = new Writable({
    write(chunk, encoding, callback) {
        console.log(chunk.toString());
        callback();
    }
});

const webWritableStream = Writable.toWeb(nodeWritable);

// 이제 webWritableStream을 웹 스트림 API와 함께 사용할 수 있습니다.
```

이 예제에서 `nodeWritable`은 Node.js의 `Writable` 스트림입니다. `Writable.toWeb` 메서드를 사용하여 이를 웹 표준 `WritableStream`으로 변환합니다. 변환된 `webWritableStream`은 웹 스트림 API와 함께 사용할 수 있습니다.


#### `stream.Duplex.from(src)`[#](https://nodejs.org/docs/latest/api/stream.html#streamduplexfromsrc)

-   `src` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Iterable>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterable_protocol) | [`<AsyncIterable>`](https://tc39.github.io/ecma262/#sec-asynciterable-interface) | [`<AsyncGeneratorFunction>`](https://tc39.es/proposal-async-iteration/#sec-asyncgeneratorfunction-constructor) | [`<AsyncFunction>`](https://tc39.es/ecma262/#sec-async-function-constructor) | [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) | [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)

이 메서드는 **Duplex 스트림**을 생성하는 유틸리티입니다.

-   `Stream`: 쓰기 가능한 스트림을 `Duplex`로 변환하고, 읽기 가능한 스트림을 `Duplex`로 변환합니다.
-   `Blob`: 읽기 가능한 `Duplex`로 변환됩니다.
-   `string`: 읽기 가능한 `Duplex`로 변환됩니다.
-   `ArrayBuffer`: 읽기 가능한 `Duplex`로 변환됩니다.
-   `AsyncIterable`: 읽기 가능한 `Duplex`로 변환됩니다. `null`을 반환할 수 없습니다.
-   `AsyncGeneratorFunction`: 읽기/쓰기 가능한 변환 `Duplex`로 변환됩니다. 첫 번째 매개변수로 `AsyncIterable`을 받아야 합니다. `null`을 반환할 수 없습니다.
-   `AsyncFunction`: 쓰기 가능한 `Duplex`로 변환됩니다. `null` 또는 `undefined`를 반환해야 합니다.
-   `Object ({ writable, readable })`: `readable`과 `writable`을 `Stream`으로 변환한 후, 이를 `Duplex`로 결합합니다. `Duplex`는 `writable`에 쓰고 `readable`에서 읽습니다.
-   `Promise`: 읽기 가능한 `Duplex`로 변환됩니다. `null` 값은 무시됩니다.
-   `ReadableStream`: 읽기 가능한 `Duplex`로 변환됩니다.
-   `WritableStream`: 쓰기 가능한 `Duplex`로 변환됩니다.
-   반환값: [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

Promise를 포함한 `Iterable` 객체를 인자로 전달하면, 처리되지 않은 **거부(unhandled rejection)**가 발생할 수 있습니다.

```js
const { Duplex } = require('node:stream');

Duplex.from([
    new Promise((resolve) => setTimeout(resolve('1'), 1500)),
    new Promise((_, reject) => setTimeout(reject(new Error('2')), 1000)), // 처리되지 않은 거부
]);
```


#### `stream.Duplex.fromWeb(pair[, options])`[#](https://nodejs.org/docs/latest/api/stream.html#streamduplexfromwebpair-options)

추가된 버전: v17.0.0

-   `pair` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `readable` [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
    -   `writable` [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `allowHalfOpen` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `decodeStrings` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `highWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `objectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
    -   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)
-   반환값: [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

```javascript
import { Duplex } from 'node:stream';
import { ReadableStream, WritableStream } from 'node:stream/web';

const readable = new ReadableStream({
    start(controller) {
        controller.enqueue('world');
    },
});

const writable = new WritableStream({
    write(chunk) {
        console.log('writable', chunk);
    },
});

const pair = { readable, writable };
const duplex = Duplex.fromWeb(pair, {
    encoding: 'utf8',
    objectMode: true,
});

duplex.write('hello');

for await (const chunk of duplex) {
    console.log('readable', chunk);
}
```


#### `stream.Duplex.toWeb(streamDuplex)`[#](https://nodejs.org/docs/latest/api/stream.html#streamduplextowebstreamduplex)

추가된 버전: v17.0.0

-   `streamDuplex` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `readable` [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)
    -   `writable` [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream)

```js
import { Duplex } from 'node:stream';

const duplex = Duplex({
    objectMode: true,
    read() {
        this.push('world');
        this.push(null);
    },
    write(chunk, encoding, callback) {
        console.log('writable', chunk);
        callback();
    },
});

const { readable, writable } = Duplex.toWeb(duplex);

writable.getWriter().write('hello');

const { value } = await readable.getReader().read();
console.log('readable', value);
```


#### `stream.addAbortSignal(signal, stream)`[#](https://nodejs.org/docs/latest/api/stream.html#streamaddabortsignalsignal-stream)

-   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) 취소를 나타내는 신호
-   `stream` [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) | [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream) | [`<WritableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-writablestream) 신호를 연결할 스트림

`AbortSignal`을 읽기 또는 쓰기 가능한 스트림에 연결합니다. 이를 통해 `AbortController`를 사용해 스트림의 종료를 제어할 수 있습니다.

전달된 `AbortSignal`에 해당하는 `AbortController`에서 `abort`를 호출하면, 스트림에서 `.destroy(new AbortError())`를 호출한 것과 동일하게 동작합니다. 웹 스트림의 경우 `controller.error(new AbortError())`와 동일합니다.

```js
const fs = require('node:fs');
const controller = new AbortController();
const read = addAbortSignal(
  controller.signal,
  fs.createReadStream('object.json')
);

// 나중에 스트림을 닫아 작업을 중단
controller.abort();
```

또는 `AbortSignal`을 사용해 읽기 가능한 스트림을 비동기 이터러블로 사용하는 예제:

```js
const controller = new AbortController();
setTimeout(() => controller.abort(), 10_000); // 타임아웃 설정

const stream = addAbortSignal(
  controller.signal,
  fs.createReadStream('object.json')
);

(async () => {
  try {
    for await (const chunk of stream) {
      await process(chunk);
    }
  } catch (e) {
    if (e.name === 'AbortError') {
      // 작업이 취소됨
    } else {
      throw e;
    }
  }
})();
```

또는 `AbortSignal`을 `ReadableStream`과 함께 사용하는 예제:

```js
const controller = new AbortController();
const rs = new ReadableStream({
  start(controller) {
    controller.enqueue('hello');
    controller.enqueue('world');
    controller.close();
  },
});

addAbortSignal(controller.signal, rs);

finished(rs, (err) => {
  if (err) {
    if (err.name === 'AbortError') {
      // 작업이 취소됨
    }
  }
});

const reader = rs.getReader();
reader.read().then(({ value, done }) => {
  console.log(value); // hello
  console.log(done); // false
  controller.abort();
});
```


#### `stream.getDefaultHighWaterMark(objectMode)`[#](https://nodejs.org/docs/latest/api/stream.html#streamgetdefaulthighwatermarkobjectmode)

추가된 버전: v19.9.0, v18.17.0

-   `objectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

스트림에서 사용하는 기본 `highWaterMark` 값을 반환합니다. 기본값은 `65536` (64 KiB)이며, `objectMode`가 활성화된 경우 `16`을 반환합니다.


#### `stream.setDefaultHighWaterMark(objectMode, value)`[#](https://nodejs.org/docs/latest/api/stream.html#streamsetdefaulthighwatermarkobjectmode-value)

추가된 버전: v19.9.0, v18.17.0

-   `objectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) highWaterMark 값

스트림에서 사용할 기본 highWaterMark 값을 설정합니다.


### 스트림 구현자를 위한 API[#](https://nodejs.org/docs/latest/api/stream.html#api-for-stream-implementers)

`node:stream` 모듈의 API는 자바스크립트의 프로토타입 상속 모델을 사용하여 스트림을 쉽게 구현할 수 있도록 설계되었습니다.

먼저, 스트림 개발자는 네 가지 기본 스트림 클래스(`stream.Writable`, `stream.Readable`, `stream.Duplex`, `stream.Transform`) 중 하나를 상속받는 새로운 자바스크립트 클래스를 선언해야 합니다. 이때, 적절한 부모 클래스 생성자를 호출하는 것을 잊지 마세요:

```js
const { Writable } = require('node:stream');

class MyWritable extends Writable {
    constructor({ highWaterMark, ...options }) {
        super({ highWaterMark });
        // ...
    }
}
```

스트림을 확장할 때, 사용자가 제공할 수 있고 제공해야 하는 옵션을 고려한 후 이를 기본 생성자로 전달해야 합니다. 예를 들어, 구현에서 `autoDestroy`와 `emitClose` 옵션에 대해 가정을 한다면, 사용자가 이를 재정의하지 못하도록 해야 합니다. 모든 옵션을 암묵적으로 전달하는 대신, 어떤 옵션을 전달할지 명시적으로 지정하세요.

새로운 스트림 클래스는 생성하는 스트림 타입에 따라 하나 이상의 특정 메서드를 구현해야 합니다. 아래 표에서 자세히 확인할 수 있습니다:

| 사용 사례 | 클래스 | 구현해야 할 메서드 |
| --- | --- | --- |
| 읽기 전용 | [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`_read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) |
| 쓰기 전용 | [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) | [`_write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback), [`_writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback), [`_final()`](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback) |
| 읽기 및 쓰기 | [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) | [`_read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize), [`_write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback), [`_writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback), [`_final()`](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback) |
| 데이터를 쓰고 결과를 읽기 | [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) | [`_transform()`](https://nodejs.org/docs/latest/api/stream.html#transform_transformchunk-encoding-callback), [`_flush()`](https://nodejs.org/docs/latest/api/stream.html#transform_flushcallback), [`_final()`](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback) |

스트림 구현 코드에서는 **절대** 스트림 소비자가 사용하도록 의도된 "공개" 메서드를 호출해서는 안 됩니다. 이는 [스트림 소비자를 위한 API](https://nodejs.org/docs/latest/api/stream.html#api-for-stream-consumers) 섹션에서 설명한 대로, 애플리케이션 코드에서 스트림을 사용할 때 부작용을 일으킬 수 있습니다.

`write()`, `end()`, `cork()`, `uncork()`, `read()`, `destroy()`와 같은 공개 메서드를 재정의하거나, `.emit()`을 통해 `'error'`, `'data'`, `'end'`, `'finish'`, `'close'`와 같은 내부 이벤트를 발생시키는 것을 피하세요. 이는 현재 및 미래의 스트림 불변성을 깨뜨려 다른 스트림, 스트림 유틸리티, 사용자 기대와의 호환성 문제를 일으킬 수 있습니다.


#### 간단한 생성 방법[#](https://nodejs.org/docs/latest/api/stream.html#simplified-construction)

추가된 버전: v1.2.0

많은 간단한 경우에, 상속에 의존하지 않고 스트림을 생성할 수 있습니다. 이는 `stream.Writable`, `stream.Readable`, `stream.Duplex`, 또는 `stream.Transform` 객체의 인스턴스를 직접 생성하고 적절한 메서드를 생성자 옵션으로 전달함으로써 가능합니다.

```js
const { Writable } = require('node:stream');

const myWritable = new Writable({
  construct(callback) {
    // 상태 초기화 및 리소스 로드...
  },
  write(chunk, encoding, callback) {
    // ...
  },
  destroy() {
    // 리소스 해제...
  },
});
```


#### 쓰기 가능한 스트림 구현하기

`stream.Writable` 클래스를 확장하여 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림을 구현할 수 있습니다.

커스텀 `Writable` 스트림은 반드시 `new stream.Writable([options])` 생성자를 호출하고, `writable._write()` 메서드와/또는 `writable._writev()` 메서드를 구현해야 합니다.


##### `new stream.Writable([options])`

- `options` [`<Object>`]
    - `highWaterMark` [`<number>`] [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)가 `false`를 반환하기 시작하는 버퍼 레벨. **기본값:** `65536` (64 KiB), `objectMode` 스트림의 경우 `16`.
    - `decodeStrings` [`<boolean>`] [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)에 전달된 문자열을 [`stream._write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback)로 전달하기 전에 `Buffer`로 인코딩할지 여부. 다른 타입의 데이터는 변환되지 않음(예: `Buffer`는 문자열로 디코딩되지 않음). `false`로 설정하면 문자열 변환이 방지됨. **기본값:** `true`.
    - `defaultEncoding` [`<string>`] [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)에 인코딩이 지정되지 않았을 때 사용되는 기본 인코딩. **기본값:** `'utf8'`.
    - `objectMode` [`<boolean>`] [`stream.write(anyObj)`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)가 유효한 작업인지 여부. 설정하면 문자열, [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer), [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 외의 JavaScript 값을 쓸 수 있음. **기본값:** `false`.
    - `emitClose` [`<boolean>`] 스트림이 파괴된 후 `'close'` 이벤트를 발생시킬지 여부. **기본값:** `true`.
    - `write` [`<Function>`] [`stream._write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback) 메서드의 구현.
    - `writev` [`<Function>`] [`stream._writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback) 메서드의 구현.
    - `destroy` [`<Function>`] [`stream._destroy()`](https://nodejs.org/docs/latest/api/stream.html#writable_destroyerr-callback) 메서드의 구현.
    - `final` [`<Function>`] [`stream._final()`](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback) 메서드의 구현.
    - `construct` [`<Function>`] [`stream._construct()`](https://nodejs.org/docs/latest/api/stream.html#writable_constructcallback) 메서드의 구현.
    - `autoDestroy` [`<boolean>`] 스트림이 종료된 후 자동으로 `.destroy()`를 호출할지 여부. **기본값:** `true`.
    - `signal` [`<AbortSignal>`] 취소 가능성을 나타내는 신호.

```js
const { Writable } = require('node:stream');

class MyWritable extends Writable {
    constructor(options) {
        // stream.Writable() 생성자를 호출
        super(options);
        // ...
    }
}
```

또는 ES6 이전 스타일의 생성자를 사용할 경우:

```js
const { Writable } = require('node:stream');
const util = require('node:util');

function MyWritable(options) {
    if (!(this instanceof MyWritable)) return new MyWritable(options);
    Writable.call(this, options);
}

util.inherits(MyWritable, Writable);
```

또는 간단한 생성자 접근 방식을 사용할 경우:

```js
const { Writable } = require('node:stream');

const myWritable = new Writable({
    write(chunk, encoding, callback) {
        // ...
    },
    writev(chunks, callback) {
        // ...
    },
});
```

전달된 `AbortSignal`에 해당하는 `AbortController`에서 `abort`를 호출하면 쓰기 가능한 스트림에서 `.destroy(new AbortError())`를 호출하는 것과 동일하게 동작합니다.

```js
const { Writable } = require('node:stream');
const controller = new AbortController();

const myWritable = new Writable({
    write(chunk, encoding, callback) {
        // ...
    },
    writev(chunks, callback) {
        // ...
    },
    signal: controller.signal,
});

// 나중에 스트림을 닫는 작업을 중단
controller.abort();
```


##### `writable._construct(callback)`[#](https://nodejs.org/docs/latest/api/stream.html#writable_constructcallback)

추가된 버전: v15.0.0

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 스트림 초기화가 완료되면 이 함수를 호출합니다. (옵션으로 에러 인자를 전달할 수 있습니다.)

`_construct()` 메서드는 직접 호출해서는 안 됩니다. 이 메서드는 자식 클래스에서 구현할 수 있으며, 만약 구현된다면 내부 `Writable` 클래스 메서드에 의해서만 호출됩니다.

이 선택적 함수는 스트림 생성자가 반환된 후 틱(tick)에서 호출되며, `callback`이 호출될 때까지 `_write()`, `_final()`, `_destroy()` 호출을 지연시킵니다. 이는 스트림을 사용하기 전에 상태를 초기화하거나 비동기적으로 리소스를 초기화하는 데 유용합니다.

```js
const { Writable } = require('node:stream');
const fs = require('node:fs');

class WriteStream extends Writable {
    constructor(filename) {
        super();
        this.filename = filename;
        this.fd = null;
    }

    _construct(callback) {
        fs.open(this.filename, 'w', (err, fd) => {
            if (err) {
                callback(err);
            } else {
                this.fd = fd;
                callback();
            }
        });
    }

    _write(chunk, encoding, callback) {
        fs.write(this.fd, chunk, callback);
    }

    _destroy(err, callback) {
        if (this.fd) {
            fs.close(this.fd, (er) => callback(er || err));
        } else {
            callback(err);
        }
    }
}
```


##### `writable._write(chunk, encoding, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback)

-   `chunk` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
    `stream.write()`에 전달된 `string`에서 변환된 `Buffer`입니다. 스트림의 `decodeStrings` 옵션이 `false`이거나 스트림이 객체 모드로 동작 중이라면, `chunk`는 변환되지 않고 `stream.write()`에 전달된 그대로 유지됩니다.
  
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    `chunk`가 문자열인 경우, `encoding`은 해당 문자열의 문자 인코딩을 나타냅니다. `chunk`가 `Buffer`이거나 스트림이 객체 모드로 동작 중이라면, `encoding`은 무시될 수 있습니다.
  
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
    전달된 `chunk`에 대한 처리가 완료되면 이 함수를 호출합니다. (필요시 에러 인자를 함께 전달할 수 있습니다.)

모든 `Writable` 스트림 구현체는 데이터를 하위 리소스로 전송하기 위해 [`writable._write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback) 및/또는 [`writable._writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback) 메서드를 제공해야 합니다.

[`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림은 [`writable._write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback) 메서드를 자체적으로 구현합니다.

이 함수는 애플리케이션 코드에서 직접 호출해서는 안 됩니다. 자식 클래스에서 구현되어야 하며, 내부 `Writable` 클래스 메서드에 의해서만 호출됩니다.

`callback` 함수는 `writable._write()` 내에서 동기적으로 호출되거나 비동기적으로(즉, 다른 틱에서) 호출되어 쓰기 작업이 성공적으로 완료되었는지 또는 실패했는지를 알려야 합니다. `callback`에 전달되는 첫 번째 인자는 호출이 실패한 경우 `Error` 객체, 쓰기가 성공한 경우 `null`이어야 합니다.

`writable._write()`가 호출되고 `callback`이 호출되는 사이에 발생하는 모든 `writable.write()` 호출은 쓰기 데이터가 버퍼링되도록 합니다. `callback`이 호출되면 스트림은 [`'drain'`](https://nodejs.org/docs/latest/api/stream.html#event-drain) 이벤트를 발생시킬 수 있습니다. 스트림 구현체가 여러 데이터 청크를 한 번에 처리할 수 있다면, `writable._writev()` 메서드를 구현해야 합니다.

생성자 옵션에서 `decodeStrings` 속성이 명시적으로 `false`로 설정된 경우, `chunk`는 `.write()`에 전달된 객체 그대로 유지되며, `Buffer` 대신 문자열일 수 있습니다. 이는 특정 문자열 데이터 인코딩에 대해 최적화된 처리를 지원하기 위함입니다. 이 경우, `encoding` 인자는 문자열의 문자 인코딩을 나타냅니다. 그렇지 않다면, `encoding` 인자는 안전하게 무시할 수 있습니다.

`writable._write()` 메서드는 클래스 내부에서 정의되며 사용자 프로그램에서 직접 호출해서는 안 되기 때문에 언더스코어(`_`)로 시작합니다.


```javascript
##### `writable._writev(chunks, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback)

-   `chunks` [`<Object\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 쓸 데이터입니다. 이 값은 각각 쓸 데이터의 개별 청크를 나타내는 객체 배열입니다. 이 객체의 속성은 다음과 같습니다:
    -   `chunk` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 쓸 데이터를 포함하는 버퍼 인스턴스 또는 문자열입니다. `Writable`이 `decodeStrings` 옵션을 `false`로 설정한 상태로 생성되었고 `write()`에 문자열이 전달된 경우, `chunk`는 문자열이 됩니다.
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `chunk`의 문자 인코딩입니다. `chunk`가 `Buffer`인 경우, `encoding`은 `'buffer'`가 됩니다.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 제공된 청크에 대한 처리가 완료되면 호출될 콜백 함수입니다. (선택적으로 오류 인자를 포함할 수 있습니다.)

이 함수는 애플리케이션 코드에서 직접 호출해서는 안 됩니다. 이 함수는 자식 클래스에서 구현되어야 하며, 내부 `Writable` 클래스 메서드에 의해서만 호출됩니다.

`writable._writev()` 메서드는 한 번에 여러 청크의 데이터를 처리할 수 있는 스트림 구현에서 `writable._write()` 대신 또는 추가적으로 구현될 수 있습니다. 이 메서드가 구현되어 있고 이전 쓰기 작업에서 버퍼링된 데이터가 있는 경우, `_write()` 대신 `_writev()`가 호출됩니다.

`writable._writev()` 메서드는 이를 정의하는 클래스의 내부 메서드이기 때문에 언더스코어(`_`)로 시작하며, 사용자 프로그램에서 직접 호출해서는 안 됩니다.
```


##### `writable._destroy(err, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#writable_destroyerr-callback)

추가된 버전: v8.0.0

-   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 발생할 수 있는 오류
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 선택적 오류 인자를 받는 콜백 함수

`_destroy()` 메서드는 [`writable.destroy()`](https://nodejs.org/docs/latest/api/stream.html#writabledestroyerror)에 의해 호출됩니다. 이 메서드는 자식 클래스에서 재정의할 수 있지만, **직접 호출해서는 안 됩니다**.


##### `writable._final(callback)`[#](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback)

추가된 버전: v8.0.0

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 남은 데이터를 모두 작성한 후 이 함수를 호출합니다. (선택적으로 에러 인자를 전달할 수 있습니다.)

`_final()` 메서드는 **직접 호출해서는 안 됩니다**. 이 메서드는 자식 클래스에서 구현할 수 있으며, 구현된 경우 내부 `Writable` 클래스 메서드에 의해서만 호출됩니다.

이 선택적 함수는 스트림이 닫히기 전에 호출되며, `callback`이 호출될 때까지 `'finish'` 이벤트를 지연시킵니다. 이는 스트림이 종료되기 전에 리소스를 닫거나 버퍼링된 데이터를 작성하는 데 유용합니다.


##### 쓰기 작업 중 발생하는 오류

[`writable._write()`](https://nodejs.org/docs/latest/api/stream.html#writable_writechunk-encoding-callback), [`writable._writev()`](https://nodejs.org/docs/latest/api/stream.html#writable_writevchunks-callback), 그리고 [`writable._final()`](https://nodejs.org/docs/latest/api/stream.html#writable_finalcallback) 메서드 처리 중 발생하는 오류는 콜백을 호출하고 첫 번째 인자로 오류를 전달하여 전파해야 합니다. 이러한 메서드 내에서 `Error`를 던지거나 수동으로 `'error'` 이벤트를 발생시키면 정의되지 않은 동작이 발생할 수 있습니다.

`Writable` 스트림이 오류를 발생시킬 때 `Readable` 스트림이 `Writable` 스트림으로 파이프된 경우, `Readable` 스트림은 파이프에서 해제됩니다.

```js
const { Writable } = require('node:stream');

const myWritable = new Writable({
    write(chunk, encoding, callback) {
        if (chunk.toString().indexOf('a') >= 0) {
            callback(new Error('chunk is invalid'));
        } else {
            callback();
        }
    },
});
```


##### 쓰기 가능한 스트림 예제

아래는 매우 단순하고 특별한 목적이 없는 커스텀 `Writable` 스트림 구현 예제입니다. 이 특정 `Writable` 스트림 인스턴스는 실제로 유용하지 않지만, 커스텀 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 스트림 인스턴스에 필요한 각 요소를 보여줍니다:

```js
const { Writable } = require('node:stream');

class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        if (chunk.toString().indexOf('a') >= 0) {
            callback(new Error('chunk is invalid'));
        } else {
            callback();
        }
    }
}
```


##### Writable 스트림에서 버퍼 디코딩하기

버퍼를 디코딩하는 작업은 문자열을 입력으로 받는 변환기를 사용할 때 흔히 발생합니다. 특히 UTF-8과 같은 멀티바이트 문자 인코딩을 사용할 때는 간단하지 않은 과정입니다. 아래 예제는 `StringDecoder`와 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)을 사용해 멀티바이트 문자열을 디코딩하는 방법을 보여줍니다.

```js
const { Writable } = require('node:stream');
const { StringDecoder } = require('node:string_decoder');

class StringWritable extends Writable {
    constructor(options) {
        super(options);
        this._decoder = new StringDecoder(options?.defaultEncoding);
        this.data = '';
    }

    _write(chunk, encoding, callback) {
        if (encoding === 'buffer') {
            chunk = this._decoder.write(chunk);
        }
        this.data += chunk;
        callback();
    }

    _final(callback) {
        this.data += this._decoder.end();
        callback();
    }
}

const euro = [[0xE2, 0x82], [0xAC]].map(Buffer.from);
const w = new StringWritable();

w.write('currency: ');
w.write(euro[0]);
w.end(euro[1]);

console.log(w.data); // currency: €
```

이 예제에서는 `StringWritable` 클래스를 정의하여 멀티바이트 문자열을 처리합니다. `StringDecoder`를 사용해 버퍼를 문자열로 변환하고, 최종적으로 디코딩된 문자열을 출력합니다. 결과적으로 `currency: €`가 콘솔에 표시됩니다.


#### 읽기 가능한 스트림 구현하기

`stream.Readable` 클래스를 확장하여 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림을 구현할 수 있습니다.

커스텀 `Readable` 스트림은 반드시 `new stream.Readable([options])` 생성자를 호출하고 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드를 구현해야 합니다.


##### `new stream.Readable([options])`

- `options` [`<Object>`]
    - `highWaterMark` [`<number>`] 내부 버퍼에 저장할 최대 바이트 수. 이 값을 초과하면 기본 리소스에서 읽기를 중단한다. **기본값:** `65536` (64 KiB), `objectMode` 스트림의 경우 `16`.
    - `encoding` [`<string>`] 지정된 경우, 버퍼를 해당 인코딩을 사용해 문자열로 디코딩한다. **기본값:** `null`.
    - `objectMode` [`<boolean>`] 이 스트림이 객체 스트림으로 동작할지 여부. [`stream.read(n)`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize)이 `n` 크기의 `Buffer` 대신 단일 값을 반환한다. **기본값:** `false`.
    - `emitClose` [`<boolean>`] 스트림이 파괴된 후 `'close'` 이벤트를 발생시킬지 여부. **기본값:** `true`.
    - `read` [`<Function>`] [`stream._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드의 구현.
    - `destroy` [`<Function>`] [`stream._destroy()`](https://nodejs.org/docs/latest/api/stream.html#readable_destroyerr-callback) 메서드의 구현.
    - `construct` [`<Function>`] [`stream._construct()`](https://nodejs.org/docs/latest/api/stream.html#readable_constructcallback) 메서드의 구현.
    - `autoDestroy` [`<boolean>`] 스트림이 종료된 후 자동으로 `.destroy()`를 호출할지 여부. **기본값:** `true`.
    - `signal` [`<AbortSignal>`] 취소를 나타내는 신호.

```js
const { Readable } = require('node:stream');

class MyReadable extends Readable {
    constructor(options) {
        // stream.Readable(options) 생성자를 호출
        super(options);
        // ...
    }
}
```

또는 ES6 이전 스타일의 생성자를 사용할 경우:

```js
const { Readable } = require('node:stream');
const util = require('node:util');

function MyReadable(options) {
    if (!(this instanceof MyReadable)) return new MyReadable(options);
    Readable.call(this, options);
}

util.inherits(MyReadable, Readable);
```

또는 간단한 생성자 접근 방식을 사용할 경우:

```js
const { Readable } = require('node:stream');

const myReadable = new Readable({
    read(size) {
        // ...
    },
});
```

전달된 `AbortSignal`에 해당하는 `AbortController`에서 `abort`를 호출하면, 생성된 readable에서 `.destroy(new AbortError())`를 호출하는 것과 동일하게 동작한다.

```js
const { Readable } = require('node:stream');
const controller = new AbortController();

const read = new Readable({
    read(size) {
        // ...
    },
    signal: controller.signal,
});

// 이후, 스트림을 닫기 위해 작업을 중단
controller.abort();
```


##### `readable._construct(callback)`[#](https://nodejs.org/docs/latest/api/stream.html#readable_constructcallback)

추가된 버전: v15.0.0

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 스트림 초기화가 완료되면 이 함수를 호출합니다. (옵션으로 에러 인자를 전달할 수 있습니다.)

`_construct()` 메서드는 직접 호출하면 안 됩니다. 이 메서드는 자식 클래스에서 구현할 수 있으며, 구현된 경우 내부 `Readable` 클래스 메서드에 의해서만 호출됩니다.

이 선택적 함수는 스트림 생성자에 의해 다음 틱에 예약되며, `callback`이 호출될 때까지 `_read()`와 `_destroy()` 호출을 지연시킵니다. 이는 스트림을 사용하기 전에 상태를 초기화하거나 비동기적으로 리소스를 초기화할 때 유용합니다.

```js
const { Readable } = require('node:stream');
const fs = require('node:fs');

class ReadStream extends Readable {
    constructor(filename) {
        super();
        this.filename = filename;
        this.fd = null;
    }

    _construct(callback) {
        fs.open(this.filename, (err, fd) => {
            if (err) {
                callback(err);
            } else {
                this.fd = fd;
                callback();
            }
        });
    }

    _read(n) {
        const buf = Buffer.alloc(n);
        fs.read(this.fd, buf, 0, n, null, (err, bytesRead) => {
            if (err) {
                this.destroy(err);
            } else {
                this.push(bytesRead > 0 ? buf.slice(0, bytesRead) : null);
            }
        });
    }

    _destroy(err, callback) {
        if (this.fd) {
            fs.close(this.fd, (er) => callback(er || err));
        } else {
            callback(err);
        }
    }
}
```


##### `readable._read(size)`[#](https://nodejs.org/docs/latest/api/stream.html#readable_readsize)

추가된 버전: v0.9.4

-   `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 비동기적으로 읽을 바이트 수

이 함수는 **애플리케이션 코드에서 직접 호출해서는 안 됩니다.** 이는 자식 클래스에서 구현되어야 하며, 내부 `Readable` 클래스 메서드에 의해서만 호출됩니다.

모든 `Readable` 스트림 구현은 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드를 구현하여 기본 리소스에서 데이터를 가져와야 합니다.

[`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize)가 호출될 때, 리소스에서 데이터를 사용할 수 있다면, 구현은 [`this.push(dataChunk)`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding) 메서드를 사용하여 해당 데이터를 읽기 큐에 푸시하기 시작해야 합니다. 스트림이 더 많은 데이터를 받을 준비가 되면, [`this.push(dataChunk)`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding)를 호출한 후에 `_read()`가 다시 호출됩니다. `_read()`는 리소스에서 데이터를 계속 읽고 푸시할 수 있으며, `readable.push()`가 `false`를 반환할 때까지 이를 반복합니다. `_read()`가 멈춘 후에 다시 호출될 때만 추가 데이터를 큐에 푸시해야 합니다.

[`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드가 한 번 호출되면, [`readable.push()`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding) 메서드를 통해 더 많은 데이터가 푸시될 때까지 다시 호출되지 않습니다. 빈 버퍼나 문자열과 같은 빈 데이터는 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize)를 호출하지 않습니다.

`size` 인자는 **권장 사항**입니다. "읽기"가 데이터를 반환하는 단일 작업인 구현에서는 `size` 인자를 사용하여 얼마나 많은 데이터를 가져올지 결정할 수 있습니다. 다른 구현에서는 이 인자를 무시하고 데이터가 사용 가능할 때마다 단순히 제공할 수도 있습니다. `size` 바이트가 사용 가능해질 때까지 "기다릴" 필요는 없으며, [`stream.push(chunk)`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding)를 호출하면 됩니다.

[`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드는 **언더스코어(_)**로 시작합니다. 이는 해당 클래스 내부에서만 사용되며, 사용자 프로그램에서 직접 호출해서는 안 됩니다.


##### `readable._destroy(err, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#readable_destroyerr-callback)

추가된 버전: v8.0.0

-   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 발생 가능한 오류
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 선택적 오류 인자를 받는 콜백 함수

`_destroy()` 메서드는 [`readable.destroy()`](https://nodejs.org/docs/latest/api/stream.html#readabledestroyerror)에 의해 호출됩니다. 이 메서드는 자식 클래스에서 재정의할 수 있지만, **직접 호출해서는 안 됩니다**.


##### `readable.push(chunk[, encoding])`

- `chunk` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
  읽기 큐에 추가할 데이터 청크입니다. 객체 모드가 아닌 스트림의 경우, `chunk`는 반드시 문자열, Buffer, TypedArray 또는 DataView 타입이어야 합니다. 객체 모드 스트림에서는 `chunk`로 모든 JavaScript 값을 사용할 수 있습니다.

- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  문자열 청크의 인코딩입니다. `'utf8'`이나 `'ascii'`와 같은 유효한 `Buffer` 인코딩이어야 합니다.

- 반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
  추가 데이터 청크를 계속해서 푸시할 수 있으면 `true`, 그렇지 않으면 `false`를 반환합니다.

`chunk`가 Buffer, TypedArray, DataView 또는 문자열인 경우, 데이터 청크는 스트림 사용자가 소비할 수 있도록 내부 큐에 추가됩니다. `chunk`로 `null`을 전달하면 스트림의 끝(EOF)을 나타내며, 이후에는 더 이상 데이터를 쓸 수 없습니다.

`Readable` 스트림이 일시 정지 모드에서 동작 중일 때, `readable.push()`로 추가된 데이터는 [`'readable'`](https://nodejs.org/docs/latest/api/stream.html#event-readable) 이벤트가 발생할 때 [`readable.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize) 메서드를 호출하여 읽을 수 있습니다.

`Readable` 스트림이 흐름 모드에서 동작 중일 때, `readable.push()`로 추가된 데이터는 `'data'` 이벤트를 발생시켜 전달됩니다.

`readable.push()` 메서드는 가능한 한 유연하게 설계되었습니다. 예를 들어, 일시 정지/재개 메커니즘과 데이터 콜백을 제공하는 저수준 소스를 래핑할 때, 커스텀 `Readable` 인스턴스로 저수준 소스를 감쌀 수 있습니다.

```js
// `_source`는 readStop()과 readStart() 메서드를 가지며,
// 데이터가 있을 때 호출되는 `ondata` 멤버와
// 데이터가 끝났을 때 호출되는 `onend` 멤버를 가진 객체입니다.
class SourceWrapper extends Readable {
    constructor(options) {
        super(options);
        this._source = getLowLevelSourceObject();

        // 데이터가 있을 때마다 내부 버퍼에 푸시합니다.
        this._source.ondata = (chunk) => {
            // push()가 false를 반환하면 소스에서 읽기를 중단합니다.
            if (!this.push(chunk)) this._source.readStop();
        };

        // 소스가 끝나면 EOF를 나타내는 `null` 청크를 푸시합니다.
        this._source.onend = () => {
            this.push(null);
        };
    }

    // _read()는 스트림이 더 많은 데이터를 가져오려고 할 때 호출됩니다.
    // 이 경우, 권장 크기 인자는 무시됩니다.
    _read(size) {
        this._source.readStart();
    }
}
```

`readable.push()` 메서드는 내부 버퍼에 콘텐츠를 푸시하는 데 사용됩니다. 이 메서드는 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드에 의해 구동될 수 있습니다.

객체 모드가 아닌 스트림에서 `readable.push()`의 `chunk` 인자가 `undefined`인 경우, 빈 문자열이나 버퍼로 처리됩니다. 자세한 내용은 [`readable.push('')`](https://nodejs.org/docs/latest/api/stream.html#readablepush)를 참조하세요.


##### 읽기 중 발생하는 오류

[`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 처리 중 발생하는 오류는 [`readable.destroy(err)`](https://nodejs.org/docs/latest/api/stream.html#readable_destroyerr-callback) 메서드를 통해 전파되어야 합니다. [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 내부에서 `Error`를 던지거나 수동으로 `'error'` 이벤트를 발생시키면 예측할 수 없는 동작이 발생할 수 있습니다.

```js
const { Readable } = require('node:stream');

const myReadable = new Readable({
  read(size) {
    const err = checkSomeErrorCondition();
    if (err) {
      this.destroy(err);
    } else {
      // 작업 수행
    }
  },
});
```


##### 카운팅 스트림 예제

다음은 1부터 1,000,000까지의 숫자를 오름차순으로 방출한 후 종료하는 기본적인 `Readable` 스트림 예제입니다.

```js
const { Readable } = require('node:stream');

class Counter extends Readable {
  constructor(opt) {
    super(opt);
    this._max = 1000000;
    this._index = 1;
  }

  _read() {
    const i = this._index++;
    if (i > this._max) {
      this.push(null); // 스트림 종료
    } else {
      const str = String(i);
      const buf = Buffer.from(str, 'ascii');
      this.push(buf); // 데이터 방출
    }
  }
}
```


#### 듀플렉스 스트림 구현하기

[`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림은 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)과 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)을 모두 구현한 스트림입니다. 예를 들어 TCP 소켓 연결이 이에 해당합니다.

자바스크립트는 다중 상속을 지원하지 않기 때문에, `stream.Duplex` 클래스를 확장하여 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림을 구현합니다. 이는 `stream.Readable`과 `stream.Writable` 클래스를 동시에 확장하는 것과는 다릅니다.

`stream.Duplex` 클래스는 `stream.Readable`로부터 프로토타입 상속을 받고, `stream.Writable`로부터는 기생적 상속을 받습니다. 하지만 `instanceof`는 `stream.Writable`의 [`Symbol.hasInstance`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance)를 재정의했기 때문에 두 기본 클래스에 대해 정상적으로 작동합니다.

커스텀 `Duplex` 스트림은 반드시 `new stream.Duplex([options])` 생성자를 호출하고, [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize)와 `writable._write()` 메서드를 모두 구현해야 합니다.


##### `new stream.Duplex(options)`

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
  `Writable`과 `Readable` 생성자에 전달되는 옵션 객체입니다. 또한 다음과 같은 필드를 포함합니다:
  - `allowHalfOpen` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    `false`로 설정하면, 읽기 가능한 스트림이 끝날 때 쓰기 가능한 스트림도 자동으로 종료됩니다. **기본값:** `true`.
  - `readable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    `Duplex` 스트림이 읽기 가능한지 설정합니다. **기본값:** `true`.
  - `writable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    `Duplex` 스트림이 쓰기 가능한지 설정합니다. **기본값:** `true`.
  - `readableObjectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    읽기 가능한 스트림의 `objectMode`를 설정합니다. `objectMode`가 `true`인 경우에는 효과가 없습니다. **기본값:** `false`.
  - `writableObjectMode` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    쓰기 가능한 스트림의 `objectMode`를 설정합니다. `objectMode`가 `true`인 경우에는 효과가 없습니다. **기본값:** `false`.
  - `readableHighWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    읽기 가능한 스트림의 `highWaterMark`를 설정합니다. `highWaterMark`가 이미 제공된 경우에는 효과가 없습니다.
  - `writableHighWaterMark` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    쓰기 가능한 스트림의 `highWaterMark`를 설정합니다. `highWaterMark`가 이미 제공된 경우에는 효과가 없습니다.

```javascript
const { Duplex } = require('node:stream');

class MyDuplex extends Duplex {
  constructor(options) {
    super(options);
    // ...
  }
}
```

또는 ES6 이전 스타일의 생성자를 사용할 경우:

```javascript
const { Duplex } = require('node:stream');
const util = require('node:util');

function MyDuplex(options) {
  if (!(this instanceof MyDuplex)) return new MyDuplex(options);
  Duplex.call(this, options);
}

util.inherits(MyDuplex, Duplex);
```

또는 간단한 생성자 접근 방식을 사용할 경우:

```javascript
const { Duplex } = require('node:stream');

const myDuplex = new Duplex({
  read(size) {
    // ...
  },
  write(chunk, encoding, callback) {
    // ...
  },
});
```

`pipeline`을 사용할 경우:

```javascript
const { Transform, pipeline } = require('node:stream');
const fs = require('node:fs');

pipeline(
  fs.createReadStream('object.json').setEncoding('utf8'),
  new Transform({
    decodeStrings: false, // 버퍼 대신 문자열 입력을 허용
    construct(callback) {
      this.data = '';
      callback();
    },
    transform(chunk, encoding, callback) {
      this.data += chunk;
      callback();
    },
    flush(callback) {
      try {
        // 유효한 JSON인지 확인
        JSON.parse(this.data);
        this.push(this.data);
        callback();
      } catch (err) {
        callback(err);
      }
    },
  }),
  fs.createWriteStream('valid-object.json'),
  (err) => {
    if (err) {
      console.error('failed', err);
    } else {
      console.log('completed');
    }
  }
);
```


##### Duplex 스트림 예제

아래는 Node.js 스트림과 호환되지 않는 API를 사용하는 가상의 하위 레벨 소스 객체를 감싸는 `Duplex` 스트림의 간단한 예제입니다. 이 예제는 [`Writable`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) 인터페이스를 통해 들어오는 데이터를 버퍼링하고, [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 인터페이스를 통해 다시 읽어오는 방식을 보여줍니다.

```js
const { Duplex } = require('node:stream');
const kSource = Symbol('source');

class MyDuplex extends Duplex {
    constructor(source, options) {
        super(options);
        this[kSource] = source;
    }

    _write(chunk, encoding, callback) {
        // 하위 소스는 문자열만 처리합니다.
        if (Buffer.isBuffer(chunk)) chunk = chunk.toString();
        this[kSource].writeSomeData(chunk);
        callback();
    }

    _read(size) {
        this[kSource].fetchSomeData(size, (data, encoding) => {
            this.push(Buffer.from(data, encoding));
        });
    }
}
```

`Duplex` 스트림의 가장 중요한 특징은 `Readable`과 `Writable`이 단일 객체 인스턴스 내에 공존하면서도 서로 독립적으로 동작한다는 점입니다.


##### 객체 모드 듀플렉스 스트림

`Duplex` 스트림에서 `readableObjectMode`와 `writableObjectMode` 옵션을 사용하면 `Readable` 또는 `Writable` 측면에 대해 독립적으로 `objectMode`를 설정할 수 있습니다.

예를 들어, 다음 예제에서는 `Writable` 측면이 객체 모드인 새로운 `Transform` 스트림을 생성합니다. 이 스트림은 자바스크립트 숫자를 받아 `Readable` 측면에서 16진수 문자열로 변환합니다.

```js
const { Transform } = require('node:stream'); // 모든 Transform 스트림은 Duplex 스트림입니다.

const myTransform = new Transform({
    writableObjectMode: true,
    transform(chunk, encoding, callback) {
        // 필요하다면 chunk를 숫자로 강제 변환합니다.
        chunk |= 0;

        // chunk를 다른 형태로 변환합니다.
        const data = chunk.toString(16);

        // 데이터를 읽기 가능한 큐에 넣습니다.
        callback(null, '0'.repeat(data.length % 2) + data);
    },
});

myTransform.setEncoding('ascii');
myTransform.on('data', (chunk) => console.log(chunk));

myTransform.write(1);  // 출력: 01
myTransform.write(10); // 출력: 0a
myTransform.write(100); // 출력: 64
```


#### Transform 스트림 구현하기

[`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림은 입력으로부터 계산된 출력을 생성하는 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림입니다. 예를 들어, 데이터를 압축하거나 암호화, 복호화하는 [zlib](https://nodejs.org/docs/latest/api/zlib.html) 스트림이나 [crypto](https://nodejs.org/docs/latest/api/crypto.html) 스트림이 이에 해당합니다.

출력이 입력과 동일한 크기일 필요는 없으며, 동일한 수의 청크로 나뉘거나 동시에 도착할 필요도 없습니다. 예를 들어, `Hash` 스트림은 입력이 끝날 때 단일 청크의 출력만 제공합니다. `zlib` 스트림은 입력보다 훨씬 작거나 큰 출력을 생성할 수 있습니다.

`stream.Transform` 클래스를 확장하여 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림을 구현합니다.

`stream.Transform` 클래스는 `stream.Duplex`로부터 프로토타입 상속을 받으며, `writable._write()`와 [`readable._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 메서드의 자체 버전을 구현합니다. 커스텀 `Transform` 구현체는 반드시 [`transform._transform()`](https://nodejs.org/docs/latest/api/stream.html#transform_transformchunk-encoding-callback) 메서드를 구현해야 하며, 선택적으로 [`transform._flush()`](https://nodejs.org/docs/latest/api/stream.html#transform_flushcallback) 메서드를 구현할 수 있습니다.

`Transform` 스트림을 사용할 때 주의할 점은, `Readable` 측의 출력이 소비되지 않으면 `Writable` 측이 일시 중지될 수 있다는 것입니다.


### `new stream.Transform([options])`

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
  `Writable`과 `Readable` 생성자에 전달되는 옵션 객체입니다. 또한 다음과 같은 필드를 포함합니다:
  - `transform` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
    [`stream._transform()`](https://nodejs.org/docs/latest/api/stream.html#transform_transformchunk-encoding-callback) 메서드를 구현하는 함수입니다.
  - `flush` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
    [`stream._flush()`](https://nodejs.org/docs/latest/api/stream.html#transform_flushcallback) 메서드를 구현하는 함수입니다.

```javascript
const { Transform } = require('node:stream');

class MyTransform extends Transform {
    constructor(options) {
        super(options);
        // ...
    }
}
```

또는 ES6 이전 스타일의 생성자를 사용할 경우:

```javascript
const { Transform } = require('node:stream');
const util = require('node:util');

function MyTransform(options) {
    if (!(this instanceof MyTransform)) return new MyTransform(options);
    Transform.call(this, options);
}

util.inherits(MyTransform, Transform);
```

또는 간단한 생성자 접근 방식을 사용할 경우:

```javascript
const { Transform } = require('node:stream');

const myTransform = new Transform({
    transform(chunk, encoding, callback) {
        // ...
    },
});
```


##### 이벤트: `'end'`

`'end'` 이벤트는 `stream.Readable` 클래스에서 발생합니다. 이 이벤트는 모든 데이터가 출력된 후에 발생하며, 이는 [`transform._flush()`](https://nodejs.org/docs/latest/api/stream.html#transform_flushcallback)의 콜백이 호출된 이후에 일어납니다. 오류가 발생한 경우에는 `'end'` 이벤트가 발생하지 않아야 합니다.


##### 이벤트: `'finish'`[#](https://nodejs.org/docs/latest/api/stream.html#event-finish_1)

`'finish'` 이벤트는 `stream.Writable` 클래스에서 발생합니다. 이 이벤트는 [`stream.end()`](https://nodejs.org/docs/latest/api/stream.html#writableendchunk-encoding-callback)가 호출되고, 모든 데이터 청크가 [`stream._transform()`](https://nodejs.org/docs/latest/api/stream.html#transform_transformchunk-encoding-callback)에 의해 처리된 후에 발생합니다. 오류가 발생한 경우에는 `'finish'` 이벤트가 발생하지 않습니다.


### `transform._flush(callback)`

- **`callback`** [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function): 남은 데이터가 플러시(flush)된 후 호출될 콜백 함수. 에러 인자와 데이터를 선택적으로 포함할 수 있다.

이 함수는 **애플리케이션 코드에서 직접 호출해서는 안 됩니다.** 자식 클래스에서 구현되어야 하며, 내부 `Readable` 클래스 메서드에 의해서만 호출됩니다.

일부 경우에는, 스트림이 끝날 때 추가적인 데이터를 내보내야 할 수 있습니다. 예를 들어, `zlib` 압축 스트림은 출력을 최적으로 압축하기 위해 내부 상태를 저장합니다. 그러나 스트림이 끝나면, 압축된 데이터가 완전해지도록 이 추가 데이터를 플러시해야 합니다.

커스텀 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 구현체는 `transform._flush()` 메서드를 **구현할 수 있습니다.** 이 메서드는 더 이상 소비할 데이터가 없지만, [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 스트림의 끝을 알리는 [`'end'`](https://nodejs.org/docs/latest/api/stream.html#event-end) 이벤트가 발생하기 전에 호출됩니다.

`transform._flush()` 구현 내에서는, 필요에 따라 `transform.push()` 메서드를 0번 이상 호출할 수 있습니다. 플러시 작업이 완료되면 반드시 `callback` 함수를 호출해야 합니다.

`transform._flush()` 메서드는 앞에 언더스코어(`_`)가 붙어 있습니다. 이는 해당 클래스 내부에서만 사용되며, 사용자 프로그램에서 직접 호출되어서는 안 된다는 것을 의미합니다.


##### `transform._transform(chunk, encoding, callback)`[#](https://nodejs.org/docs/latest/api/stream.html#transform_transformchunk-encoding-callback)

-   `chunk` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
    변환될 `Buffer`로, [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)에 전달된 `string`에서 변환됩니다. 스트림의 `decodeStrings` 옵션이 `false`이거나 스트림이 객체 모드로 동작 중이라면, `chunk`는 변환되지 않고 [`stream.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)에 전달된 그대로 유지됩니다.

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    `chunk`가 문자열인 경우, 이는 인코딩 타입입니다. `chunk`가 버퍼라면, 이 값은 특수한 값 `'buffer'`가 됩니다. 이 경우에는 무시해도 됩니다.

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
    제공된 `chunk`가 처리된 후 호출될 콜백 함수입니다. (옵션으로 에러 인자와 데이터를 포함할 수 있습니다.)

이 함수는 애플리케이션 코드에서 직접 호출해서는 안 됩니다. 자식 클래스에서 구현되어야 하며, 내부 `Readable` 클래스 메서드에 의해서만 호출됩니다.

모든 `Transform` 스트림 구현은 입력을 받아 출력을 생성하기 위해 `_transform()` 메서드를 제공해야 합니다. `transform._transform()` 구현은 기록되는 바이트를 처리하고, 출력을 계산한 후, 그 출력을 `transform.push()` 메서드를 사용해 읽을 수 있는 부분으로 전달합니다.

`transform.push()` 메서드는 단일 입력 `chunk`에서 출력을 생성하기 위해 0번 이상 호출될 수 있습니다. 이는 `chunk`의 결과로 얼마나 많은 출력이 생성될지에 따라 달라집니다.

입력 데이터의 특정 `chunk`에서 출력이 전혀 생성되지 않을 수도 있습니다.

`callback` 함수는 현재 `chunk`가 완전히 소비된 후에만 호출되어야 합니다. 입력 처리 중 에러가 발생했다면, `callback`에 전달되는 첫 번째 인자는 `Error` 객체여야 합니다. 그렇지 않으면 `null`이어야 합니다. `callback`에 두 번째 인자가 전달되면, 이는 `transform.push()` 메서드로 전달됩니다. 단, 첫 번째 인자가 falsy 값인 경우에만 가능합니다. 즉, 다음 두 코드는 동일합니다:

```js
transform.prototype._transform = function(data, encoding, callback) {
    this.push(data);
    callback();
};

transform.prototype._transform = function(data, encoding, callback) {
    callback(null, data);
};
```

`transform._transform()` 메서드는 클래스 내부에서 정의되며, 사용자 프로그램에서 직접 호출되어서는 안 되기 때문에 언더스코어(`_`)로 시작합니다.

`transform._transform()`은 병렬로 호출되지 않습니다. 스트림은 큐 메커니즘을 구현하며, 다음 `chunk`를 받기 위해서는 `callback`이 동기적 또는 비동기적으로 호출되어야 합니다.


### 클래스: `stream.PassThrough`

`stream.PassThrough` 클래스는 입력된 바이트를 그대로 출력으로 전달하는 간단한 [`Transform`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform) 스트림 구현체입니다. 주로 예제나 테스트 용도로 사용되지만, 새로운 종류의 스트림을 구성하는 기본 요소로 유용한 경우도 있습니다.


### Additional notes[#](https://nodejs.org/docs/latest/api/stream.html#additional-notes)





#### 스트림과 비동기 제너레이터 및 비동기 이터레이터의 호환성

JavaScript에서 비동기 제너레이터와 이터레이터를 지원함에 따라, 비동기 제너레이터는 이제 언어 수준의 퍼스트클래스 스트림 구조로 자리 잡았습니다.

아래는 Node.js 스트림을 비동기 제너레이터 및 비동기 이터레이터와 함께 사용하는 일반적인 상호 운용 사례입니다.


##### async iterators를 사용하여 Readable 스트림 소비하기

```js
(async function() {
    for await (const chunk of readable) {
        console.log(chunk);
    }
})();
```

async iterators는 스트림에 영구적인 에러 핸들러를 등록하여, 파괴 후 발생하는 처리되지 않은 에러를 방지합니다.


##### async generator를 사용하여 읽기 가능한 스트림 만들기

Node.js에서 `Readable.from()` 유틸리티 메서드를 사용하면 비동기 제너레이터로부터 읽기 가능한 스트림을 생성할 수 있습니다.

```js
const { Readable } = require('node:stream');
const ac = new AbortController();
const signal = ac.signal;

async function* generate() {
    yield 'a';
    await someLongRunningFn({ signal });
    yield 'b';
    yield 'c';
}

const readable = Readable.from(generate());

readable.on('close', () => {
    ac.abort();
});

readable.on('data', (chunk) => {
    console.log(chunk);
});
```

이 예제에서는 `generate`라는 비동기 제너레이터 함수를 정의했습니다. 이 함수는 'a', 'b', 'c' 값을 순차적으로 생성하며, `someLongRunningFn`이라는 긴 작업을 수행하는 동안 중단 신호(`signal`)를 사용할 수 있습니다. `Readable.from()`을 통해 이 제너레이터로부터 읽기 가능한 스트림을 생성하고, 스트림이 닫히면 `ac.abort()`를 호출하여 작업을 중단합니다. 스트림에서 데이터를 읽을 때마다 `console.log`를 통해 데이터를 출력합니다.


##### 비동기 이터레이터에서 쓰기 가능한 스트림으로 파이핑하기

비동기 이터레이터에서 쓰기 가능한 스트림으로 데이터를 쓸 때, **백프레셔**와 **에러**를 올바르게 처리해야 합니다. [`stream.pipeline()`](https://nodejs.org/docs/latest/api/stream.html#streampipelinesource-transforms-destination-callback)을 사용하면 백프레셔와 관련된 에러 처리를 간단히 할 수 있습니다.

```js
const fs = require('node:fs');
const { pipeline } = require('node:stream');
const { pipeline: pipelinePromise } = require('node:stream/promises');

const writable = fs.createWriteStream('./file');
const ac = new AbortController();
const signal = ac.signal;
const iterator = createIterator({ signal });

// 콜백 패턴
pipeline(iterator, writable, (err, value) => {
    if (err) {
        console.error(err);
    } else {
        console.log(value, 'value returned');
    }
}).on('close', () => {
    ac.abort();
});

// Promise 패턴
pipelinePromise(iterator, writable)
    .then((value) => {
        console.log(value, 'value returned');
    })
    .catch((err) => {
        console.error(err);
        ac.abort();
    });
```

이 예제에서는 `stream.pipeline()`을 사용해 비동기 이터레이터에서 쓰기 가능한 스트림으로 데이터를 안전하게 전달합니다. 콜백 패턴과 Promise 패턴 두 가지 방식으로 구현할 수 있습니다.


#### 이전 Node.js 버전과의 호환성

Node.js 0.10 이전 버전에서는 `Readable` 스트림 인터페이스가 더 단순했지만, 기능이 부족하고 유용성도 떨어졌습니다.

-   [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize) 메서드 호출을 기다리지 않고, [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트가 즉시 발생했습니다. 데이터를 처리하는 방법을 결정하기 위해 추가 작업이 필요한 애플리케이션은 데이터가 손실되지 않도록 읽은 데이터를 버퍼에 저장해야 했습니다.
-   [`stream.pause()`](https://nodejs.org/docs/latest/api/stream.html#readablepause) 메서드는 권고 사항일 뿐, 보장되지 않았습니다. 이는 스트림이 일시 중지된 상태에서도 [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트를 받을 준비가 필요하다는 것을 의미했습니다.

Node.js 0.10에서는 [`Readable`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) 클래스가 추가되었습니다. 이전 Node.js 프로그램과의 호환성을 위해, `Readable` 스트림은 [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트 핸들러가 추가되거나 [`stream.resume()`](https://nodejs.org/docs/latest/api/stream.html#readableresume) 메서드가 호출될 때 "흐름 모드(flowing mode)"로 전환됩니다. 이로 인해 새로운 [`stream.read()`](https://nodejs.org/docs/latest/api/stream.html#readablereadsize) 메서드와 [`'readable'`](https://nodejs.org/docs/latest/api/stream.html#event-readable) 이벤트를 사용하지 않더라도 [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 청크가 손실될 걱정을 할 필요가 없어졌습니다.

대부분의 애플리케이션은 정상적으로 작동하지만, 다음과 같은 조건에서 예외적인 경우가 발생할 수 있습니다:

-   [`'data'`](https://nodejs.org/docs/latest/api/stream.html#event-data) 이벤트 리스너가 추가되지 않음.
-   [`stream.resume()`](https://nodejs.org/docs/latest/api/stream.html#readableresume) 메서드가 호출되지 않음.
-   스트림이 쓰기 가능한 목적지로 파이프되지 않음.

예를 들어, 다음 코드를 살펴보세요:

```js
// 주의! 문제가 있는 코드!
net.createServer((socket) => {
    // 'end' 리스너를 추가하지만 데이터를 소비하지 않음.
    socket.on('end', () => {
        // 이 부분에 도달하지 못함.
        socket.end('The message was received but was not processed.\n');
    });
}).listen(1337);
```

Node.js 0.10 이전 버전에서는 들어오는 메시지 데이터가 단순히 버려졌습니다. 그러나 Node.js 0.10 이상 버전에서는 소켓이 영원히 일시 중지된 상태로 남아 있습니다.

이 상황에서의 해결 방법은 [`stream.resume()`](https://nodejs.org/docs/latest/api/stream.html#readableresume) 메서드를 호출하여 데이터 흐름을 시작하는 것입니다:

```js
// 해결 방법.
net.createServer((socket) => {
    socket.on('end', () => {
        socket.end('The message was received but was not processed.\n');
    });
    // 데이터 흐름을 시작하고, 데이터를 버림.
    socket.resume();
}).listen(1337);
```

새로운 `Readable` 스트림이 흐름 모드로 전환되는 것 외에도, 0.10 이전 스타일의 스트림은 [`readable.wrap()`](https://nodejs.org/docs/latest/api/stream.html#readablewrapstream) 메서드를 사용하여 `Readable` 클래스로 감쌀 수 있습니다.


#### `readable.read(0)`[#](https://nodejs.org/docs/latest/api/stream.html#readableread0)

데이터를 실제로 소비하지 않고도, 읽기 가능한 스트림의 내부 메커니즘을 새로고침해야 하는 경우가 있습니다. 이럴 때 `readable.read(0)`을 호출할 수 있으며, 이 메서드는 항상 `null`을 반환합니다.

내부 읽기 버퍼가 `highWaterMark`보다 낮고, 스트림이 현재 읽기 작업을 수행하고 있지 않다면, `stream.read(0)`을 호출하면 저수준의 [`stream._read()`](https://nodejs.org/docs/latest/api/stream.html#readable_readsize) 호출이 트리거됩니다.

대부분의 애플리케이션에서는 이 기능을 거의 사용할 일이 없지만, Node.js 내부에서는 특히 `Readable` 스트림 클래스에서 이런 작업이 수행되는 경우가 있습니다.


#### `readable.push('')`[#](https://nodejs.org/docs/latest/api/stream.html#readablepush)

`readable.push('')` 사용은 권장되지 않습니다.

스트림이 객체 모드가 아닐 때, 0바이트의 [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type), [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer), [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 또는 [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)를 스트림에 푸시하면 흥미로운 부작용이 발생합니다. 이는 [`readable.push()`](https://nodejs.org/docs/latest/api/stream.html#readablepushchunk-encoding) 호출이기 때문에 읽기 프로세스를 종료합니다. 그러나 인자가 빈 문자열이기 때문에 읽기 가능한 버퍼에 데이터가 추가되지 않아 사용자가 소비할 수 있는 것이 없습니다.


#### `readable.setEncoding()` 호출 후 `highWaterMark` 차이점

`readable.setEncoding()`을 사용하면 **non-object 모드**에서 `highWaterMark`의 동작 방식이 바뀝니다.

일반적으로 현재 버퍼의 크기는 `highWaterMark`와 *바이트* 단위로 비교됩니다. 하지만 `setEncoding()`을 호출한 후에는 버퍼의 크기를 *문자* 단위로 측정하기 시작합니다.

이 동작은 `latin1`이나 `ascii`와 같은 일반적인 경우에는 문제가 되지 않습니다. 하지만 **멀티바이트 문자**를 포함할 수 있는 문자열을 다룰 때는 이 점을 유의해야 합니다.


