# Worker 스레드

**소스 코드:** [lib/worker_threads.js](https://github.com/nodejs/node/blob/v23.5.0/lib/worker_threads.js)

`node:worker_threads` 모듈은 JavaScript를 병렬로 실행할 수 있는 스레드를 사용할 수 있게 해줍니다. 이 모듈을 사용하려면 다음과 같이 접근합니다:

```js
const worker = require('node:worker_threads');
```

Worker(스레드)는 CPU 집약적인 JavaScript 작업을 수행할 때 유용합니다. 하지만 I/O 집약적인 작업에는 큰 도움이 되지 않습니다. Node.js의 내장 비동기 I/O 작업이 Worker보다 더 효율적입니다.

`child_process`나 `cluster`와 달리, `worker_threads`는 메모리를 공유할 수 있습니다. `ArrayBuffer` 인스턴스를 전송하거나 `SharedArrayBuffer` 인스턴스를 공유하는 방식으로 이를 구현합니다.

```js
const { Worker, isMainThread, parentPort, workerData } = require('node:worker_threads');

if (isMainThread) {
    module.exports = function parseJSAsync(script) {
        return new Promise((resolve, reject) => {
            const worker = new Worker(__filename, {
                workerData: script,
            });
            worker.on('message', resolve);
            worker.on('error', reject);
            worker.on('exit', (code) => {
                if (code !== 0) reject(new Error(`Worker stopped with exit code ${code}`));
            });
        });
    };
} else {
    const { parse } = require('some-js-parsing-library');
    const script = workerData;
    parentPort.postMessage(parse(script));
}
```

위 예제는 `parseJSAsync()` 호출마다 Worker 스레드를 생성합니다. 실제로는 이런 종류의 작업에 Worker 풀을 사용하는 것이 좋습니다. 그렇지 않으면 Worker를 생성하는 오버헤드가 이점을 초과할 가능성이 있습니다.

Worker 풀을 구현할 때는 [`AsyncResource`](https://nodejs.org/docs/latest/api/async_hooks.html#class-asyncresource) API를 사용하여 작업과 그 결과 간의 상관 관계를 진단 도구(예: 비동기 스택 트레이스 제공)에 알려주세요. 예제 구현은 `async_hooks` 문서의 ["Using `AsyncResource` for a `Worker` thread pool"](https://nodejs.org/docs/latest/api/async_context.html#using-asyncresource-for-a-worker-thread-pool)을 참고하세요.

Worker 스레드는 기본적으로 프로세스에 특정되지 않은 옵션을 상속받습니다. Worker 스레드 옵션을 커스터마이징하는 방법, 특히 `argv`와 `execArgv` 옵션에 대해서는 [`Worker constructor options`](https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options)를 참고하세요.


### `worker.getEnvironmentData(key)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workergetenvironmentdatakey)

-   `key` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) 키로 사용할 수 있는 임의의 복제 가능한 자바스크립트 값
-   반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

워커 스레드 내에서 `worker.getEnvironmentData()`는 생성 스레드의 `worker.setEnvironmentData()`에 전달된 데이터의 복제본을 반환합니다. 모든 새로운 `Worker`는 자동으로 환경 데이터의 복사본을 받습니다.

```js
const { Worker, isMainThread, setEnvironmentData, getEnvironmentData } = require('node:worker_threads');

if (isMainThread) {
    setEnvironmentData('Hello', 'World!');
    const worker = new Worker(__filename);
} else {
    console.log(getEnvironmentData('Hello')); // 'World!'를 출력합니다.
}
```


### `worker.isMainThread`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerismainthread)

추가된 버전: v10.5.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 코드가 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 스레드 내부에서 실행되지 않으면 `true`를 반환합니다.

```js
const { Worker, isMainThread } = require('node:worker_threads');

if (isMainThread) {
    // 현재 파일을 Worker 인스턴스 내부에서 다시 로드합니다.
    new Worker(__filename);
} else {
    console.log('Worker 내부입니다!');
    console.log(isMainThread); // 'false'를 출력합니다.
}
```


### `worker.markAsUntransferable(object)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workermarkasuntransferableobject)

추가된 버전: v14.5.0, v12.19.0

-   `object` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 임의의 JavaScript 값.

객체를 전송 불가능한 상태로 표시합니다. 만약 `object`가 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist) 호출의 전송 목록에 포함되면, 에러가 발생합니다. `object`가 기본형(primitive) 값인 경우 이 함수는 아무런 동작을 하지 않습니다.

특히, 이 기능은 전송 대신 복제될 수 있는 객체에 유용합니다. 이러한 객체는 전송 측에서 다른 객체에 의해 사용될 수 있습니다. 예를 들어, Node.js는 [`Buffer` 풀](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)에 사용되는 `ArrayBuffer`를 이 함수로 표시합니다.

이 작업은 되돌릴 수 없습니다.

```js
const { MessageChannel, markAsUntransferable } = require('node:worker_threads');
const pooledBuffer = new ArrayBuffer(8);
const typedArray1 = new Uint8Array(pooledBuffer);
const typedArray2 = new Float64Array(pooledBuffer);

markAsUntransferable(pooledBuffer);

const { port1 } = new MessageChannel();

try {
    // pooledBuffer가 전송 불가능하므로 에러가 발생합니다.
    port1.postMessage(typedArray1, [ typedArray1.buffer ]);
} catch (error) {
    // error.name === 'DataCloneError'
}

// 다음 줄은 typedArray1의 내용을 출력합니다. 
// 이 객체는 여전히 메모리를 소유하고 있으며 전송되지 않았습니다.
// `markAsUntransferable()`을 사용하지 않았다면, 이 코드는 빈 Uint8Array를 출력하고
// postMessage 호출은 성공했을 것입니다.
// typedArray2도 그대로 유지됩니다.
console.log(typedArray1);
console.log(typedArray2);
```

브라우저에는 이 API와 동일한 기능이 없습니다.


### `worker.isMarkedAsUntransferable(object)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerismarkedasuntransferableobject)

추가된 버전: v21.0.0

-   `object` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 모든 자바스크립트 값
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`markAsUntransferable()`](https://nodejs.org/docs/latest/api/worker_threads.html#workermarkasuntransferableobject)를 사용해 객체가 전송 불가능으로 표시되었는지 확인합니다.

```js
const { markAsUntransferable, isMarkedAsUntransferable } = require('node:worker_threads');
const pooledBuffer = new ArrayBuffer(8);
markAsUntransferable(pooledBuffer);
isMarkedAsUntransferable(pooledBuffer); // true 반환
```

이 API는 브라우저에서 동등한 기능을 제공하지 않습니다.


### `worker.markAsUncloneable(object)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workermarkasuncloneableobject)

추가된 버전: v23.0.0

-   `object` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 임의의 JavaScript 값.

객체를 복제할 수 없도록 표시합니다. 만약 `object`가 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist) 호출에서 [`message`](https://nodejs.org/docs/latest/api/worker_threads.html#event-message)로 사용되면, 에러가 발생합니다. `object`가 기본 값(primitive value)인 경우 이 함수는 아무런 동작을 하지 않습니다.

이 함수는 `ArrayBuffer`나 `Buffer`와 같은 객체에는 영향을 미치지 않습니다.

이 작업은 되돌릴 수 없습니다.

```js
const { markAsUncloneable } = require('node:worker_threads');
const anyObject = { foo: 'bar' };

markAsUncloneable(anyObject);

const { port1 } = new MessageChannel();

try {
    // anyObject가 복제할 수 없으므로 에러가 발생합니다.
    port1.postMessage(anyObject);
} catch (error) {
    // error.name === 'DataCloneError'
}
```

브라우저에서는 이 API와 동일한 기능이 없습니다.


### `worker.moveMessagePortToContext(port, contextifiedSandbox)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workermovemessageporttocontextport-contextifiedsandbox)

추가된 버전: v11.13.0

-   `port` [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport) 전송할 메시지 포트입니다.
    
-   `contextifiedSandbox` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `vm.createContext()` 메서드가 반환한 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체입니다.
    
-   반환값: [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport)
    

`MessagePort`를 다른 [`vm`](https://nodejs.org/docs/latest/api/vm.html) 컨텍스트로 전송합니다. 원래의 `port` 객체는 더 이상 사용할 수 없게 되며, 반환된 `MessagePort` 인스턴스가 그 자리를 대신합니다.

반환된 `MessagePort`는 대상 컨텍스트 내의 객체이며, 해당 컨텍스트의 전역 `Object` 클래스를 상속받습니다. [`port.onmessage()`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage) 리스너에 전달된 객체들도 대상 컨텍스트에서 생성되며, 해당 컨텍스트의 전역 `Object` 클래스를 상속받습니다.

하지만 생성된 `MessagePort`는 더 이상 [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget)을 상속받지 않으며, [`port.onmessage()`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort/onmessage)만을 사용하여 이벤트를 수신할 수 있습니다.


### `worker.parentPort`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerparentport)

추가된 버전: v10.5.0

-   [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport)

현재 스레드가 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker)인 경우, 이는 부모 스레드와 통신할 수 있는 [`MessagePort`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport)입니다. `parentPort.postMessage()`를 사용해 보낸 메시지는 부모 스레드에서 `worker.on('message')`로 받을 수 있습니다. 반대로 부모 스레드에서 `worker.postMessage()`를 사용해 보낸 메시지는 현재 스레드에서 `parentPort.on('message')`로 받을 수 있습니다.

```js
const { Worker, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
    const worker = new Worker(__filename);
    worker.once('message', (message) => {
        console.log(message); // 'Hello, world!'를 출력합니다.
    });
    worker.postMessage('Hello, world!');
} else {
    // 부모 스레드에서 메시지를 받으면 다시 보냅니다.
    parentPort.once('message', (message) => {
        parentPort.postMessage(message);
    });
}
```


### `worker.postMessageToThread(threadId, value[, transferList][, timeout])`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagetothreadthreadid-value-transferlist-timeout)

추가된 버전: v22.5.0

-   `threadId` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    대상 스레드의 ID. 스레드 ID가 유효하지 않으면 [`ERR_WORKER_MESSAGING_FAILED`](https://nodejs.org/docs/latest/api/errors.html#err_worker_messaging_failed) 오류가 발생합니다. 대상 스레드 ID가 현재 스레드 ID와 같다면 [`ERR_WORKER_MESSAGING_SAME_THREAD`](https://nodejs.org/docs/latest/api/errors.html#err_worker_messaging_same_thread) 오류가 발생합니다.
  
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
    전송할 값.

-   `transferList` [`<Object\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
    `value`에 `MessagePort`와 유사한 객체가 포함된 경우, 해당 항목에 대해 `transferList`가 필요합니다. 그렇지 않으면 [`ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST`](https://nodejs.org/docs/latest/api/errors.html#err_missing_message_port_in_transfer_list) 오류가 발생합니다. 자세한 내용은 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 참조하세요.

-   `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    메시지가 전달될 때까지 기다릴 시간(밀리초 단위). 기본값은 `undefined`로, 무한히 기다립니다. 작업이 시간 초과되면 [`ERR_WORKER_MESSAGING_TIMEOUT`](https://nodejs.org/docs/latest/api/errors.html#err_worker_messaging_timeout) 오류가 발생합니다.

-   반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)  
    메시지가 대상 스레드에서 성공적으로 처리되면 이행되는 Promise입니다.

이 메서드는 스레드 ID로 식별된 다른 워커에게 값을 전송합니다.

대상 스레드에 `workerMessage` 이벤트에 대한 리스너가 없으면 [`ERR_WORKER_MESSAGING_FAILED`](https://nodejs.org/docs/latest/api/errors.html#err_worker_messaging_failed) 오류가 발생합니다.

대상 스레드가 `workerMessage` 이벤트를 처리하는 도중 오류가 발생하면 [`ERR_WORKER_MESSAGING_ERRORED`](https://nodejs.org/docs/latest/api/errors.html#err_worker_messaging_errored) 오류가 발생합니다.

이 메서드는 대상 스레드가 현재 스레드의 직접적인 부모 또는 자식이 아닌 경우에 사용해야 합니다. 두 스레드가 부모-자식 관계라면 [`require('node:worker_threads').parentPort.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist)와 [`worker.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist)를 사용하여 스레드 간 통신을 수행하세요.

아래 예제는 `postMessageToThread`의 사용법을 보여줍니다. 10개의 중첩된 스레드를 생성하고, 마지막 스레드가 메인 스레드와 통신을 시도합니다.

```js
import { fileURLToPath } from 'node:url';
import process from 'node:process';
import { postMessageToThread, threadId, workerData, Worker } from 'node:worker_threads';

const channel = new BroadcastChannel('sync');
const level = workerData?.level ?? 0;

if (level < 10) {
    const worker = new Worker(fileURLToPath(import.meta.url), {
        workerData: { level: level + 1 }
    });

    worker.on('workerMessage', (value, source) => {
        console.log(`${source} -> ${threadId}:`, value);
        postMessageToThread(source, { message: 'pong' });
    });
} else if (level === 10) {
    process.on('workerMessage', (value, source) => {
        console.log(`${source} -> ${threadId}:`, value);
        channel.postMessage('done');
        channel.close();
    });

    await postMessageToThread(0, { message: 'ping' });
}

channel.onmessage = channel.close;
```


### `worker.receiveMessageOnPort(port)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerreceivemessageonportport)

-   `port` [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport) | [`<BroadcastChannel>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-broadcastchannel-extends-eventtarget)
    
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)
    

주어진 `MessagePort`에서 단일 메시지를 받습니다. 사용 가능한 메시지가 없으면 `undefined`를 반환하고, 그렇지 않으면 `MessagePort`의 큐에 있는 가장 오래된 메시지에 해당하는 메시지 페이로드를 포함하는 `message` 속성을 가진 객체를 반환합니다.

```js
const { MessageChannel, receiveMessageOnPort } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();
port1.postMessage({ hello: 'world' });
console.log(receiveMessageOnPort(port2)); // 출력: { message: { hello: 'world' } }
console.log(receiveMessageOnPort(port2)); // 출력: undefined
```

이 함수를 사용하면 `'message'` 이벤트가 발생하지 않고 `onmessage` 리스너도 호출되지 않습니다.


### `worker.resourceLimits`

추가된 버전: v13.2.0, v12.16.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `maxYoungGenerationSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `maxOldGenerationSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `codeRangeSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `stackSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

이 Worker 스레드 내부의 JS 엔진 리소스 제약 조건을 제공합니다. 만약 `resourceLimits` 옵션이 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 생성자에 전달되었다면, 이 값은 그 설정과 일치합니다.

이 기능이 메인 스레드에서 사용되면, 그 값은 빈 객체입니다.


### `worker.SHARE_ENV`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workershare_env)

추가된 버전: v11.14.0

-   [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)

`SHARE_ENV`는 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 생성자의 `env` 옵션으로 전달할 수 있는 특별한 값입니다. 이 값을 사용하면 현재 스레드와 Worker 스레드가 동일한 환경 변수 집합에 대해 읽기 및 쓰기 접근을 공유하게 됩니다.

```js
const { Worker, SHARE_ENV } = require('node:worker_threads');

new Worker('process.env.SET_IN_WORKER = "foo"', { 
    eval: true, 
    env: SHARE_ENV 
}).on('exit', () => { 
    console.log(process.env.SET_IN_WORKER); // 'foo'를 출력합니다. 
});
```


### `worker.setEnvironmentData(key[, value])`

- `key` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
  [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)의 키로 사용할 수 있는 복제 가능한 임의의 자바스크립트 값입니다.
  
- `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
  모든 새로운 `Worker` 인스턴스에 자동으로 복제되어 전달될 임의의 복제 가능한 자바스크립트 값입니다. `value`가 `undefined`로 전달되면, 해당 `key`에 대해 이전에 설정된 값이 삭제됩니다.

`worker.setEnvironmentData()` API는 현재 스레드와 현재 컨텍스트에서 생성된 모든 새로운 `Worker` 인스턴스에서 `worker.getEnvironmentData()`의 내용을 설정합니다.


### `worker.threadId`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid)

추가된 버전: v10.5.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

현재 스레드의 정수 식별자입니다. 해당 워커 객체가 존재하는 경우, 이 값은 [`worker.threadId`](https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid_1)로 접근할 수 있습니다. 이 값은 단일 프로세스 내에서 각 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 인스턴스마다 고유합니다.


### `worker.workerData`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerworkerdata)

추가된 버전: v10.5.0

이 값은 `Worker` 생성자에 전달된 데이터의 복제본을 포함하는 임의의 JavaScript 값입니다.

데이터는 [`postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 사용한 것처럼 [HTML 구조화된 복제 알고리즘](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)에 따라 복제됩니다.

```js
const { Worker, isMainThread, workerData } = require('node:worker_threads');

if (isMainThread) {
    const worker = new Worker(__filename, {
        workerData: 'Hello, world!'
    });
} else {
    console.log(workerData); // 'Hello, world!'를 출력합니다.
}
```


### 클래스: `BroadcastChannel extends EventTarget`

`BroadcastChannel` 인스턴스는 동일한 채널 이름에 바인딩된 모든 다른 `BroadcastChannel` 인스턴스와 비동기적으로 일대다 통신을 가능하게 합니다.

```javascript
'use strict';
const { isMainThread, BroadcastChannel, Worker } = require('node:worker_threads');

const bc = new BroadcastChannel('hello');

if (isMainThread) {
    let c = 0;
    bc.onmessage = (event) => {
        console.log(event.data);
        if (++c === 10) bc.close();
    };
    for (let n = 0; n < 10; n++) new Worker(__filename);
} else {
    bc.postMessage('hello from every worker');
    bc.close();
}
```


#### `new BroadcastChannel(name)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#new-broadcastchannelname)

추가된 버전: v15.4.0

- `name` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 연결할 채널의 이름입니다. `` `${name}` ``을 사용해 문자열로 변환할 수 있는 모든 JavaScript 값이 허용됩니다.


#### `broadcastChannel.close()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelclose)

추가된 버전: v15.4.0

`BroadcastChannel` 연결을 닫습니다.


#### `broadcastChannel.onmessage`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelonmessage)

추가된 버전: v15.4.0

-   타입: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
    메시지를 받았을 때 `MessageEvent` 인자를 하나 받아 호출되는 함수입니다.


#### `broadcastChannel.onmessageerror`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelonmessageerror)

추가된 버전: v15.4.0

- 타입: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
  메시지를 역직렬화할 수 없을 때 호출됩니다.


#### `broadcastChannel.postMessage(message)`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelpostmessagemessage)

추가된 버전: v15.4.0

- `message` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 복제 가능한 모든 JavaScript 값.

`broadcastChannel.postMessage(message)` 메서드는 `BroadcastChannel`을 통해 메시지를 전송합니다. 이 메서드는 복제 가능한 모든 JavaScript 값을 인자로 받아, 해당 채널을 구독하고 있는 모든 수신자에게 메시지를 전달합니다. 이 기능은 여러 워커 스레드 간에 메시지를 브로드캐스트할 때 유용하게 사용됩니다.


#### `broadcastChannel.ref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelref)

추가된 버전: v15.4.0

`unref()`의 반대 기능입니다. 이전에 `unref()`가 호출된 BroadcastChannel에서 `ref()`를 호출해도, 프로그램이 종료되지 않도록 하는 기본 동작을 되돌리지 않습니다. 만약 포트가 이미 `ref()` 상태라면, `ref()`를 다시 호출해도 아무런 효과가 없습니다.


#### `broadcastChannel.unref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#broadcastchannelunref)

추가된 버전: v15.4.0

`BroadcastChannel`에서 `unref()`를 호출하면, 이벤트 시스템에서 이 핸들만 활성 상태일 때 스레드가 종료될 수 있도록 합니다. 만약 `BroadcastChannel`이 이미 `unref()` 상태라면, 다시 `unref()`를 호출해도 아무런 효과가 없습니다.


### 클래스: `MessageChannel`[#](https://nodejs.org/docs/latest/api/worker_threads.html#class-messagechannel)

추가된 버전: v10.5.0

`worker.MessageChannel` 클래스의 인스턴스는 비동기적이고 양방향 통신 채널을 나타냅니다. `MessageChannel`은 자체적인 메서드를 가지고 있지 않습니다. `new MessageChannel()`을 호출하면 `port1`과 `port2` 속성을 가진 객체가 반환됩니다. 이 속성들은 연결된 [`MessagePort`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport) 인스턴스를 참조합니다.

```js
const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();

port1.on('message', (message) => console.log('received', message));
port2.postMessage({ foo: 'bar' });

// 출력: received { foo: 'bar' } from the `port1.on('message')` listener
```


### 클래스: `MessagePort`[#](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport)

-   상속: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)

`worker.MessagePort` 클래스의 인스턴스는 비동기적이고 양방향 통신 채널의 한쪽 끝을 나타냅니다. 이 클래스는 서로 다른 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 간에 구조화된 데이터, 메모리 영역, 그리고 다른 `MessagePort`를 전송하는 데 사용할 수 있습니다.

이 구현은 [브라우저의 `MessagePort`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort)와 일치합니다.


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-close)

추가된 버전: v10.5.0

`'close'` 이벤트는 채널의 어느 한쪽이 연결이 끊어졌을 때 발생합니다.

```js
const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();

// 출력:
// foobar
// closed!
port2.on('message', (message) => console.log(message));
port2.on('close', () => console.log('closed!'));
port1.postMessage('foobar');
port1.close();
```


#### 이벤트: `'message'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-message)

추가된 버전: v10.5.0

-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 전송된 값

`'message'` 이벤트는 들어오는 모든 메시지에 대해 발생하며, [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)의 복제된 입력을 포함합니다.

이 이벤트의 리스너는 `postMessage()`에 전달된 `value` 매개변수의 복제본을 받으며, 추가 인자는 전달되지 않습니다.


#### 이벤트: `'messageerror'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-messageerror)

추가된 버전: v14.5.0, v12.19.0

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) Error 객체

`'messageerror'` 이벤트는 메시지를 역직렬화하는 데 실패했을 때 발생합니다.

현재, 이 이벤트는 수신 측에서 전달된 JS 객체를 인스턴스화하는 과정에서 오류가 발생할 때 발생합니다. 이러한 상황은 드물지만, 예를 들어 특정 Node.js API 객체가 `vm.Context`에서 수신될 때 발생할 수 있습니다. (`vm.Context`에서는 현재 Node.js API를 사용할 수 없습니다.)


#### `port.close()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#portclose)

추가된 버전: v10.5.0

이 메서드는 연결 양쪽에서 더 이상 메시지를 보내지 못하도록 비활성화합니다. `MessagePort`를 통해 더 이상 통신이 이루어지지 않을 때 이 메서드를 호출할 수 있습니다.

채널의 일부인 두 `MessagePort` 인스턴스에서 [`'close'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-close)가 발생합니다.


#### `port.postMessage(value[, transferList])`

- `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
- `transferList` [`<Object\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 메서드는 채널의 수신 측으로 JavaScript 값을 전송합니다. `value`는 [HTML 구조화 복제 알고리즘](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)과 호환되는 방식으로 전송됩니다.

특히, `JSON`과의 주요 차이점은 다음과 같습니다:

- `value`는 순환 참조를 포함할 수 있습니다.
- `value`는 `RegExp`, `BigInt`, `Map`, `Set` 등과 같은 내장 JS 타입의 인스턴스를 포함할 수 있습니다.
- `value`는 `ArrayBuffer`와 `SharedArrayBuffer`를 사용한 타입 배열을 포함할 수 있습니다.
- `value`는 [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) 인스턴스를 포함할 수 있습니다.
- `value`는 다음을 제외한 네이티브(C++ 기반) 객체를 포함할 수 없습니다:
    - [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey),
    - [`<FileHandle>`](https://nodejs.org/docs/latest/api/fs.html#class-filehandle),
    - [`<Histogram>`](https://nodejs.org/docs/latest/api/perf_hooks.html#class-histogram),
    - [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject),
    - [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport),
    - [`<net.BlockList>`](https://nodejs.org/docs/latest/api/net.html#class-netblocklist),
    - [`<net.SocketAddress>`](https://nodejs.org/docs/latest/api/net.html#class-netsocketaddress),
    - [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate).

```js
const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();
port1.on('message', (message) => console.log(message));
const circularData = {};
circularData.foo = circularData; // 출력: { foo: [Circular] }
port2.postMessage(circularData);
```

`transferList`는 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`MessagePort`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport), [`FileHandle`](https://nodejs.org/docs/latest/api/fs.html#class-filehandle) 객체의 목록일 수 있습니다. 전송 후에는 채널의 송신 측에서 더 이상 사용할 수 없습니다(`value`에 포함되지 않더라도). [자식 프로세스](https://nodejs.org/docs/latest/api/child_process.html)와 달리, 네트워크 소켓과 같은 핸들을 전송하는 것은 현재 지원되지 않습니다.

`value`가 [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) 인스턴스를 포함하는 경우, 이는 어느 스레드에서든 접근 가능합니다. 하지만 `transferList`에 포함될 수 없습니다.

`value`는 `transferList`에 포함되지 않은 `ArrayBuffer` 인스턴스를 포함할 수 있습니다. 이 경우, 기본 메모리는 이동되지 않고 복사됩니다.

```js
const { MessageChannel } = require('node:worker_threads');
const { port1, port2 } = new MessageChannel();
port1.on('message', (message) => console.log(message));
const uint8Array = new Uint8Array([1, 2, 3, 4]);
// `uint8Array`의 복사본을 전송합니다:
port2.postMessage(uint8Array);
// 데이터를 복사하지 않고 `uint8Array`를 사용 불가능하게 만듭니다:
port2.postMessage(uint8Array, [uint8Array.buffer]);
// `sharedUint8Array`의 메모리는 원본과 `.on('message')`에서 받은 복사본 모두에서 접근 가능합니다:
const sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));
port2.postMessage(sharedUint8Array);
// 새로 생성된 메시지 포트를 수신자에게 전송합니다.
// 예를 들어, 동일한 부모 스레드의 자식인 여러 `Worker` 스레드 간의 통신 채널을 생성하는 데 사용할 수 있습니다.
const otherChannel = new MessageChannel();
port2.postMessage({ port: otherChannel.port1 }, [otherChannel.port1]);
```

메시지 객체는 즉시 복제되며, 전송 후 수정해도 부작용이 없습니다.

이 API의 직렬화 및 역직렬화 메커니즘에 대한 자세한 내용은 [`node:v8` 모듈의 직렬화 API](https://nodejs.org/docs/latest/api/v8.html#serialization-api)를 참조하세요.


##### TypedArray와 Buffer 전송 시 고려사항

모든 `TypedArray`와 `Buffer` 인스턴스는 기본 `ArrayBuffer`를 기반으로 한 뷰(view)입니다. 즉, 실제 데이터는 `ArrayBuffer`에 저장되고, `TypedArray`와 `Buffer` 객체는 이 데이터를 보거나 조작하는 방법을 제공합니다. 동일한 `ArrayBuffer` 인스턴스 위에 여러 뷰가 생성되는 경우가 흔합니다. `ArrayBuffer`를 전송 리스트를 사용해 전송할 때는 특히 주의해야 합니다. 이렇게 하면 동일한 `ArrayBuffer`를 공유하는 모든 `TypedArray`와 `Buffer` 인스턴스가 사용 불가능 상태가 되기 때문입니다.

```js
const ab = new ArrayBuffer(10);
const u1 = new Uint8Array(ab);
const u2 = new Uint16Array(ab);

console.log(u2.length); // 5 출력
port.postMessage(u1, [u1.buffer]);
console.log(u2.length); // 0 출력
```

특히 `Buffer` 인스턴스의 경우, 기본 `ArrayBuffer`가 전송될 수 있는지 또는 복제될 수 있는지는 인스턴스가 어떻게 생성되었는지에 따라 결정됩니다. 이는 종종 신뢰할 수 있는 방법으로 확인하기 어렵습니다.

`ArrayBuffer`는 [`markAsUntransferable()`](https://nodejs.org/docs/latest/api/worker_threads.html#workermarkasuntransferableobject)을 사용해 항상 복제되어야 하고 전송되지 않아야 함을 표시할 수 있습니다.

`Buffer` 인스턴스가 어떻게 생성되었는지에 따라, 기본 `ArrayBuffer`를 소유할 수도 있고 그렇지 않을 수도 있습니다. `Buffer` 인스턴스가 `ArrayBuffer`를 소유하고 있다는 것이 확실하지 않은 경우, `ArrayBuffer`를 전송해서는 안 됩니다. 특히 내부 `Buffer` 풀에서 생성된 `Buffer`(예: `Buffer.from()` 또는 `Buffer.allocUnsafe()`를 사용한 경우)는 전송할 수 없으며 항상 복제됩니다. 이 경우 전체 `Buffer` 풀의 복사본이 전송됩니다. 이 동작은 의도치 않은 높은 메모리 사용량과 보안 문제를 초래할 수 있습니다.

`Buffer` 풀링에 대한 자세한 내용은 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)를 참고하세요.

`Buffer.alloc()` 또는 `Buffer.allocUnsafeSlow()`을 사용해 생성된 `Buffer` 인스턴스의 `ArrayBuffer`는 항상 전송할 수 있습니다. 하지만 이렇게 하면 해당 `ArrayBuffer`의 다른 모든 기존 뷰가 사용 불가능 상태가 됩니다.


##### 프로토타입, 클래스, 접근자를 가진 객체를 복제할 때 고려할 사항

객체 복제는 [HTML 구조화된 복제 알고리즘](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)을 사용하기 때문에, 열거할 수 없는 속성, 속성 접근자, 객체 프로토타입은 보존되지 않습니다. 특히, [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) 객체는 수신 측에서 일반 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)로 읽히며, JavaScript 클래스의 인스턴스는 일반 JavaScript 객체로 복제됩니다.

```js
const b = Symbol('b');
class Foo {
    #a = 1;
    constructor() {
        this[b] = 2;
        this.c = 3;
    }
    get d() {
        return 4;
    }
}
const { port1, port2 } = new MessageChannel();
port1.onmessage = ({ data }) => console.log(data);
port2.postMessage(new Foo());
// 출력: { c: 3 }
```

이 제한은 전역 `URL` 객체와 같은 많은 내장 객체에도 적용됩니다:

```js
const { port1, port2 } = new MessageChannel();
port1.onmessage = ({ data }) => console.log(data);
port2.postMessage(new URL('https://example.org'));
// 출력: { }
```


#### `port.hasRef()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#porthasref)

추가된 버전: v18.1.0, v16.17.0

-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 값이 `true`이면, `MessagePort` 객체가 Node.js 이벤트 루프를 활성 상태로 유지합니다.


#### `port.ref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#portref)

추가된 버전: v10.5.0

`unref()`의 반대 기능입니다. 이전에 `unref()`된 포트에서 `ref()`를 호출해도 프로그램이 종료되지 않습니다(기본 동작). 포트가 `ref()`된 상태에서 다시 `ref()`를 호출해도 아무런 효과가 없습니다.

`.on('message')`를 사용하여 리스너를 추가하거나 제거하면, 이벤트에 대한 리스너가 존재하는지 여부에 따라 포트가 자동으로 `ref()`되거나 `unref()`됩니다.


#### `port.start()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#portstart)

추가된 버전: v10.5.0

이 `MessagePort`에서 메시지 수신을 시작합니다. 이 포트를 이벤트 에미터로 사용할 때, `'message'` 리스너가 연결되면 자동으로 호출됩니다.

이 메서드는 웹 `MessagePort` API와의 일관성을 위해 존재합니다. Node.js에서는 이벤트 리스너가 없을 때 메시지를 무시하는 데만 유용합니다. Node.js는 `.onmessage` 처리 방식에서도 차이가 있습니다. `.onmessage`를 설정하면 자동으로 `.start()`가 호출되지만, 해제하면 새로운 핸들러가 설정되거나 포트가 폐기될 때까지 메시지가 큐에 쌓입니다.


#### `port.unref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#portunref)

추가된 버전: v10.5.0

`unref()`를 호출하면 이벤트 시스템에서 이 포트가 유일한 활성 핸들일 경우, 스레드가 종료될 수 있도록 합니다. 이미 `unref()`가 호출된 포트에서 다시 `unref()`를 호출해도 아무런 효과가 없습니다.

`.on('message')`를 사용하여 리스너를 추가하거나 제거하면, 이벤트에 대한 리스너가 존재하는지 여부에 따라 포트가 자동으로 `ref()`되거나 `unref()`됩니다.


### 클래스: `Worker`[#](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker)

추가된 버전: v10.5.0

-   상속: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`Worker` 클래스는 독립적인 자바스크립트 실행 스레드를 나타냅니다. 대부분의 Node.js API가 이 안에서 사용 가능합니다.

Worker 환경에서 주목할 만한 차이점은 다음과 같습니다:

-   [`process.stdin`](https://nodejs.org/docs/latest/api/process.html#processstdin), [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout), [`process.stderr`](https://nodejs.org/docs/latest/api/process.html#processstderr) 스트림은 부모 스레드에 의해 리디렉션될 수 있습니다.
-   [`require('node:worker_threads').isMainThread`](https://nodejs.org/docs/latest/api/worker_threads.html#workerismainthread) 속성은 `false`로 설정됩니다.
-   [`require('node:worker_threads').parentPort`](https://nodejs.org/docs/latest/api/worker_threads.html#workerparentport) 메시지 포트가 사용 가능합니다.
-   [`process.exit()`](https://nodejs.org/docs/latest/api/process.html#processexitcode)는 전체 프로그램을 멈추지 않고 단일 스레드만 멈추며, [`process.abort()`](https://nodejs.org/docs/latest/api/process.html#processabort)는 사용할 수 없습니다.
-   [`process.chdir()`](https://nodejs.org/docs/latest/api/process.html#processchdirdirectory)와 그룹 또는 사용자 ID를 설정하는 `process` 메서드는 사용할 수 없습니다.
-   [`process.env`](https://nodejs.org/docs/latest/api/process.html#processenv)는 부모 스레드의 환경 변수 복사본입니다. 단, [`worker.SHARE_ENV`](https://nodejs.org/docs/latest/api/worker_threads.html#workershare_env)가 `env` 옵션으로 전달되지 않은 경우에 한합니다. 한 복사본의 변경 사항은 다른 스레드에서 보이지 않으며, 네이티브 애드온에서도 보이지 않습니다. Windows에서는 메인 스레드와 달리 환경 변수 복사본이 대소문자를 구분합니다.
-   [`process.title`](https://nodejs.org/docs/latest/api/process.html#processtitle)은 수정할 수 없습니다.
-   신호는 [`process.on('...')`](https://nodejs.org/docs/latest/api/process.html#signal-events)를 통해 전달되지 않습니다.
-   [`worker.terminate()`](https://nodejs.org/docs/latest/api/worker_threads.html#workerterminate)가 호출되면 실행이 언제든지 중단될 수 있습니다.
-   부모 프로세스의 IPC 채널에 접근할 수 없습니다.
-   [`trace_events`](https://nodejs.org/docs/latest/api/tracing.html) 모듈은 지원되지 않습니다.
-   네이티브 애드온은 [특정 조건](https://nodejs.org/docs/latest/api/addons.html#worker-support)을 충족할 경우에만 여러 스레드에서 로드할 수 있습니다.

다른 `Worker` 내부에서 `Worker` 인스턴스를 생성하는 것도 가능합니다.

[Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)와 [`node:cluster` 모듈](https://nodejs.org/docs/latest/api/cluster.html)과 마찬가지로, 스레드 간 메시지 전달을 통해 양방향 통신이 가능합니다. 내부적으로 `Worker`는 생성될 때 이미 서로 연결된 [`MessagePort`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport) 쌍을 가지고 있습니다. 부모 측의 `MessagePort` 객체는 직접 노출되지 않지만, 그 기능은 [`worker.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist)와 부모 스레드의 `Worker` 객체에서 [`worker.on('message')`](https://nodejs.org/docs/latest/api/worker_threads.html#event-message_1) 이벤트를 통해 노출됩니다.

기본 글로벌 채널을 사용하는 대신 커스텀 메시징 채널을 생성하는 것이 권장됩니다. 이는 관심사의 분리를 촉진하기 때문입니다. 사용자는 어느 스레드에서든 `MessageChannel` 객체를 생성하고, 그 `MessageChannel`의 `MessagePort` 중 하나를 기존 채널(예: 글로벌 채널)을 통해 다른 스레드로 전달할 수 있습니다.

메시지가 어떻게 전달되고, 어떤 종류의 자바스크립트 값이 스레드 장벽을 통해 성공적으로 전송될 수 있는지에 대한 자세한 내용은 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 참조하세요.

```js
const assert = require('node:assert');
const { Worker, MessageChannel, MessagePort, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
    const worker = new Worker(__filename);
    const subChannel = new MessageChannel();
    worker.postMessage({ hereIsYourPort: subChannel.port1 }, [subChannel.port1]);
    subChannel.port2.on('message', (value) => {
        console.log('received:', value);
    });
} else {
    parentPort.once('message', (value) => {
        assert(value.hereIsYourPort instanceof MessagePort);
        value.hereIsYourPort.postMessage('the worker is sending this');
        value.hereIsYourPort.close();
    });
}
```


#### `new Worker(filename[, options])`

- `filename` [`<string>`] | [`<URL>`]  
  Worker의 메인 스크립트나 모듈 경로입니다. 절대 경로나 `./` 또는 `../`로 시작하는 상대 경로, 또는 `file:`이나 `data:` 프로토콜을 사용하는 WHATWG `URL` 객체여야 합니다. [`data:` URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)을 사용할 경우, 데이터는 MIME 타입에 따라 [ECMAScript 모듈 로더](https://nodejs.org/docs/latest/api/esm.html#data-imports)를 통해 해석됩니다. `options.eval`이 `true`인 경우, 이 값은 경로가 아닌 실행할 JavaScript 코드를 포함한 문자열입니다.

- `options` [`<Object>`]
  - `argv` [`<any[]>`]  
    Worker 내부의 `process.argv`에 추가될 인자 목록입니다. `workerData`와 유사하지만, 이 값들은 CLI 옵션으로 전달된 것처럼 전역 `process.argv`에서 사용 가능합니다.
  
  - `env` [`<Object>`]  
    설정된 경우, Worker 스레드 내부의 `process.env` 초기값을 지정합니다. 특별한 값으로 [`worker.SHARE_ENV`](https://nodejs.org/docs/latest/api/worker_threads.html#workershare_env)를 사용하면 부모 스레드와 자식 스레드가 환경 변수를 공유합니다. 이 경우, 한 스레드의 `process.env` 객체를 변경하면 다른 스레드에도 영향을 미칩니다. **기본값:** `process.env`.
  
  - `eval` [`<boolean>`]  
    `true`이고 첫 번째 인자가 `string`인 경우, 첫 번째 인자를 Worker가 온라인 상태일 때 실행할 스크립트로 해석합니다.
  
  - `execArgv` [`<string[]>`]  
    Worker에 전달할 Node.js CLI 옵션 목록입니다. V8 옵션(예: `--max-old-space-size`)이나 프로세스에 영향을 미치는 옵션(예: `--title`)은 지원되지 않습니다. 설정된 경우, 이 값은 Worker 내부의 [`process.execArgv`](https://nodejs.org/docs/latest/api/process.html#processexecargv)로 제공됩니다. 기본적으로 부모 스레드의 옵션을 상속받습니다.
  
  - `stdin` [`<boolean>`]  
    `true`로 설정된 경우, `worker.stdin`은 Worker 내부의 `process.stdin`으로 나타나는 쓰기 가능한 스트림을 제공합니다. 기본적으로 데이터는 제공되지 않습니다.
  
  - `stdout` [`<boolean>`]  
    `true`로 설정된 경우, `worker.stdout`은 부모의 `process.stdout`으로 자동으로 파이프되지 않습니다.
  
  - `stderr` [`<boolean>`]  
    `true`로 설정된 경우, `worker.stderr`은 부모의 `process.stderr`으로 자동으로 파이프되지 않습니다.
  
  - `workerData` [`<any>`]  
    복제되어 [`require('node:worker_threads').workerData`](https://nodejs.org/docs/latest/api/worker_threads.html#workerworkerdata)로 사용 가능한 JavaScript 값입니다. 복제는 [HTML 구조화 복제 알고리즘](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)에 따라 이루어지며, 복제할 수 없는 객체(예: `function` 포함)인 경우 에러가 발생합니다.
  
  - `trackUnmanagedFds` [`<boolean>`]  
    `true`로 설정된 경우, Worker는 [`fs.open()`](https://nodejs.org/docs/latest/api/fs.html#fsopenpath-flags-mode-callback)과 [`fs.close()`](https://nodejs.org/docs/latest/api/fs.html#fsclosefd-callback)를 통해 관리되는 파일 디스크립터를 추적하고, Worker가 종료될 때 이를 닫습니다. 이 옵션은 모든 중첩된 `Worker`에 자동으로 상속됩니다. **기본값:** `true`.
  
  - `transferList` [`<Object[]>`]  
    `workerData`에 `MessagePort`와 유사한 객체가 전달된 경우, 이 항목들에 대해 `transferList`가 필요합니다. 그렇지 않으면 [`ERR_MISSING_MESSAGE_PORT_IN_TRANSFER_LIST`](https://nodejs.org/docs/latest/api/errors.html#err_missing_message_port_in_transfer_list) 에러가 발생합니다. 자세한 내용은 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 참고하세요.
  
  - `resourceLimits` [`<Object>`]  
    새로운 JS 엔진 인스턴스에 대한 리소스 제한 옵션입니다. 이 제한에 도달하면 `Worker` 인스턴스가 종료됩니다. 이 제한은 JS 엔진에만 영향을 미치며, `ArrayBuffer`와 같은 외부 데이터에는 영향을 주지 않습니다. 이 제한이 설정되어 있어도, 전역 메모리 부족 상황에서 프로세스가 중단될 수 있습니다.
    - `maxOldGenerationSizeMb` [`<number>`]  
      메인 힙의 최대 크기(MB)입니다. 커맨드라인 인수 [`--max-old-space-size`](https://nodejs.org/docs/latest/api/cli.html#--max-old-space-sizesize-in-mib)가 설정된 경우, 이 설정을 덮어씁니다.
    - `maxYoungGenerationSizeMb` [`<number>`]  
      최근 생성된 객체를 위한 힙 공간의 최대 크기입니다. 커맨드라인 인수 [`--max-semi-space-size`](https://nodejs.org/docs/latest/api/cli.html#--max-semi-space-sizesize-in-mib)가 설정된 경우, 이 설정을 덮어씁니다.
    - `codeRangeSizeMb` [`<number>`]  
      생성된 코드를 위해 미리 할당된 메모리 범위의 크기입니다.
    - `stackSizeMb` [`<number>`]  
      스레드의 기본 최대 스택 크기입니다. 작은 값은 Worker 인스턴스를 사용할 수 없게 만들 수 있습니다. **기본값:** `4`.
  
  - `name` [`<string>`]  
    디버깅/식별을 위해 Worker 제목에 추가할 이름입니다. 최종 제목은 `[worker ${id}] ${name}` 형태가 됩니다. **기본값:** `''`.


#### 이벤트: `'error'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-error)

추가된 버전: v10.5.0

-   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)

워커 스레드에서 잡히지 않은 예외가 발생하면 `'error'` 이벤트가 발생합니다. 이 경우, 해당 워커는 종료됩니다.


#### 이벤트: `'exit'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-exit)

추가된 버전: v10.5.0

-   `exitCode` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`'exit'` 이벤트는 워커가 멈춘 후에 한 번 발생합니다. 워커가 [`process.exit()`](https://nodejs.org/docs/latest/api/process.html#processexitcode)를 호출하여 종료된 경우, `exitCode` 매개변수는 전달된 종료 코드입니다. 워커가 강제로 종료된 경우, `exitCode` 매개변수는 `1`입니다.

이 이벤트는 모든 `Worker` 인스턴스에서 발생하는 마지막 이벤트입니다.


#### 이벤트: `'message'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-message_1)

추가된 버전: v10.5.0

-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 전송된 값

`'message'` 이벤트는 워커 스레드가 [`require('node:worker_threads').parentPort.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist)를 호출했을 때 발생합니다. 자세한 내용은 [`port.on('message')`](https://nodejs.org/docs/latest/api/worker_threads.html#event-message) 이벤트를 참고하세요.

워커 스레드에서 보낸 모든 메시지는 `Worker` 객체에서 [`'exit'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-exit)가 발생하기 전에 전송됩니다.


#### 이벤트: `'messageerror'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-messageerror_1)

추가된 버전: v14.5.0, v12.19.0

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) Error 객체

`'messageerror'` 이벤트는 메시지 역직렬화가 실패했을 때 발생합니다.


#### 이벤트: `'online'`[#](https://nodejs.org/docs/latest/api/worker_threads.html#event-online)

추가된 버전: v10.5.0

`'online'` 이벤트는 워커 스레드가 자바스크립트 코드 실행을 시작했을 때 발생합니다.


#### `worker.getHeapSnapshot([options])`

- `options` [`<Object>`]
  - `exposeInternals` [`<boolean>`] 내부 구조를 힙 스냅샷에 노출할지 여부. **기본값:** `false`.
  - `exposeNumericValues` [`<boolean>`] 숫자 값을 인공 필드에 노출할지 여부. **기본값:** `false`.
- 반환값: [`<Promise>`] V8 힙 스냅샷을 포함하는 Readable Stream에 대한 Promise

현재 Worker의 상태에 대한 V8 스냅샷을 읽을 수 있는 스트림을 반환합니다. 자세한 내용은 [`v8.getHeapSnapshot()`](https://nodejs.org/docs/latest/api/v8.html#v8getheapsnapshotoptions)을 참고하세요.

Worker 스레드가 더 이상 실행 중이 아닌 경우(예: [`'exit'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-exit)가 발생하기 전), 반환된 `Promise`는 즉시 [`ERR_WORKER_NOT_RUNNING`](https://nodejs.org/docs/latest/api/errors.html#err_worker_not_running) 오류와 함께 거부됩니다.


#### `worker.performance`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerperformance)

추가된 버전: v15.1.0, v14.17.0, v12.22.0

`worker.performance`는 워커 인스턴스에서 성능 정보를 조회할 수 있는 객체입니다. 이 객체는 [`perf_hooks.performance`](https://nodejs.org/docs/latest/api/perf_hooks.html#perf_hooksperformance)와 유사한 기능을 제공합니다.


##### `performance.eventLoopUtilization([utilization1[, utilization2]])`[#](https://nodejs.org/docs/latest/api/worker_threads.html#performanceeventlooputilizationutilization1-utilization2)

추가된 버전: v15.1.0, v14.17.0, v12.22.0

-   `utilization1` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 이전에 호출된 `eventLoopUtilization()`의 결과.
-   `utilization2` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `utilization1` 이전에 호출된 `eventLoopUtilization()`의 결과.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `idle` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `active` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `utilization` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

이 함수는 [`perf_hooks`의 `eventLoopUtilization()`](https://nodejs.org/docs/latest/api/perf_hooks.html#performanceeventlooputilizationutilization1-utilization2)와 동일하지만, 워커 인스턴스의 값을 반환합니다.

한 가지 차이점은 메인 스레드와 달리 워커 내부의 부트스트래핑이 이벤트 루프 내에서 이루어진다는 것입니다. 따라서 워커 스크립트가 실행을 시작하면 이벤트 루프 사용률을 즉시 확인할 수 있습니다.

`idle` 시간이 증가하지 않는다고 해서 워커가 부트스트랩에 갇혀 있다는 의미는 아닙니다. 아래 예제는 워커의 전체 수명 동안 `idle` 시간이 누적되지 않지만 여전히 메시지를 처리할 수 있음을 보여줍니다.

```js
const { Worker, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
    const worker = new Worker(__filename);
    setInterval(() => {
        worker.postMessage('hi');
        console.log(worker.performance.eventLoopUtilization());
    }, 100).unref();
    return;
}

parentPort.on('message', () => console.log('msg')).unref();

(function r(n) {
    if (--n < 0) return;
    const t = Date.now();
    while (Date.now() - t < 300);
    setImmediate(r, n);
})(10);
```

워커의 이벤트 루프 사용률은 [`'online'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-online)가 발생한 후에만 확인할 수 있습니다. 이 이벤트 전이나 [`'exit'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-exit) 이후에 호출하면 모든 속성 값이 `0`이 됩니다.


#### `worker.postMessage(value[, transferList])`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerpostmessagevalue-transferlist)

추가된 버전: v10.5.0

-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
-   `transferList` [`<Object\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

워커에게 메시지를 보냅니다. 이 메시지는 [`require('node:worker_threads').parentPort.on('message')`](https://nodejs.org/docs/latest/api/worker_threads.html#event-message)를 통해 수신됩니다. 자세한 내용은 [`port.postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 참고하세요.


#### `worker.ref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerref)

추가된 버전: v10.5.0

`unref()`의 반대 기능입니다. 이전에 `unref()`된 워커에 `ref()`를 호출하면, 해당 워커가 유일한 활성 핸들일 때 프로그램이 종료되지 않습니다(기본 동작). 워커가 이미 `ref()`된 상태에서 다시 `ref()`를 호출해도 아무런 효과가 없습니다.


#### `worker.resourceLimits`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerresourcelimits_1)

추가된 버전: v13.2.0, v12.16.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `maxYoungGenerationSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `maxOldGenerationSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `codeRangeSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `stackSizeMb` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

이 Worker 스레드에 대한 JS 엔진 리소스 제약 조건을 제공합니다. 만약 `resourceLimits` 옵션이 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 생성자에 전달되었다면, 이 값은 그 옵션과 일치합니다.

Worker가 중지된 경우, 반환 값은 빈 객체입니다.


#### `worker.stderr`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerstderr)

추가된 버전: v10.5.0

-   [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)

이것은 워커 스레드 내부에서 [`process.stderr`](https://nodejs.org/docs/latest/api/process.html#processstderr)에 쓰여진 데이터를 포함하는 읽기 가능한 스트림입니다. 만약 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 생성자에 `stderr: true`가 전달되지 않았다면, 데이터는 부모 스레드의 [`process.stderr`](https://nodejs.org/docs/latest/api/process.html#processstderr) 스트림으로 전달됩니다.


#### `worker.stdin`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerstdin)

추가된 버전: v10.5.0

- [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)

`Worker` 생성자에 `stdin: true`를 전달했다면, 이는 쓰기 가능한 스트림입니다. 이 스트림에 쓰여진 데이터는 워커 스레드에서 [`process.stdin`](https://nodejs.org/docs/latest/api/process.html#processstdin)으로 사용할 수 있습니다.


#### `worker.stdout`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerstdout)

추가된 버전: v10.5.0

-   [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)

이것은 워커 스레드 내부에서 [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout)에 쓰여진 데이터를 포함하는 읽기 가능한 스트림입니다. 만약 [`Worker`](https://nodejs.org/docs/latest/api/worker_threads.html#class-worker) 생성자에 `stdout: true`가 전달되지 않았다면, 데이터는 부모 스레드의 [`process.stdout`](https://nodejs.org/docs/latest/api/process.html#processstdout) 스트림으로 전달됩니다.


#### `worker.terminate()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerterminate)

-   반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

워커 스레드에서 가능한 한 빨리 모든 자바스크립트 실행을 중단합니다. [`'exit'` 이벤트](https://nodejs.org/docs/latest/api/worker_threads.html#event-exit)가 발생할 때 이행되는 종료 코드를 담은 Promise를 반환합니다.


#### `worker.threadId`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid_1)

추가된 버전: v10.5.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

참조된 스레드의 정수 식별자입니다. 워커 스레드 내부에서는 [`require('node:worker_threads').threadId`](https://nodejs.org/docs/latest/api/worker_threads.html#workerthreadid)로 접근할 수 있습니다. 이 값은 단일 프로세스 내에서 각 `Worker` 인스턴스마다 고유합니다.


#### `worker.unref()`[#](https://nodejs.org/docs/latest/api/worker_threads.html#workerunref)

추가된 버전: v10.5.0

`unref()`를 호출하면 이벤트 시스템에서 해당 워커가 유일한 활성 핸들일 경우, 스레드가 종료될 수 있도록 허용합니다. 이미 `unref()`가 호출된 워커에 다시 `unref()`를 호출해도 아무런 효과가 없습니다.


### Notes[#](https://nodejs.org/docs/latest/api/worker_threads.html#notes)





#### stdio의 동기적 블로킹[#](https://nodejs.org/docs/latest/api/worker_threads.html#synchronous-blocking-of-stdio)

`Worker`는 `stdio`와의 상호작용을 구현하기 위해 [`<MessagePort>`](https://nodejs.org/docs/latest/api/worker_threads.html#class-messageport)를 통해 메시지 전달을 사용합니다. 이는 `Worker`에서 발생한 `stdio` 출력이 Node.js 이벤트 루프를 블로킹하는 동기 코드에 의해 차단될 수 있음을 의미합니다.

```js
import { Worker, isMainThread } from 'node:worker_threads';

if (isMainThread) {
    new Worker(new URL(import.meta.url));
    for (let n = 0; n < 1e10; n++) {
        // 작업을 시뮬레이션하기 위한 루프
    }
} else {
    // 이 출력은 메인 스레드의 for 루프에 의해 차단됩니다.
    console.log('foo');
}
```


#### preload 스크립트에서 worker 스레드 실행하기

preload 스크립트(`-r` 커맨드라인 플래그를 사용해 로드되고 실행되는 스크립트)에서 worker 스레드를 실행할 때 주의해야 합니다. `execArgv` 옵션을 명시적으로 설정하지 않으면, 새로운 Worker 스레드는 실행 중인 프로세스의 커맨드라인 플래그를 자동으로 상속받고, 메인 스레드와 동일한 preload 스크립트를 사전 로드합니다. 만약 preload 스크립트가 무조건적으로 worker 스레드를 실행한다면, 생성된 모든 스레드가 또 다른 스레드를 생성하게 되어 결국 애플리케이션이 크래시될 수 있습니다.


