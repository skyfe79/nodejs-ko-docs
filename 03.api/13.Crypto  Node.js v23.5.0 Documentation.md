# Table of Contents

- [Crypto](#crypto)
    - [crypto 지원이 불가능한지 확인하기](#crypto-지원이-불가능한지-확인하기)
    - [클래스: `Certificate`](#클래스-certificate)
      - [정적 메서드: `Certificate.exportChallenge(spkac[, encoding])`](#정적-메서드-certificateexportchallengespkac-encoding)
      - [정적 메서드: `Certificate.exportPublicKey(spkac[, encoding])`](#정적-메서드-certificateexportpublickeyspkac-encoding)
      - [정적 메서드: `Certificate.verifySpkac(spkac[, encoding])`](#정적-메서드-certificateverifyspkacspkac-encoding)
      - [레거시 API](#레거시-api)
        - [`new crypto.Certificate()`](#new-cryptocertificate)
        - [`certificate.exportChallenge(spkac[, encoding])`](#certificateexportchallengespkac-encoding)
        - [`certificate.exportPublicKey(spkac[, encoding])`](#certificateexportpublickeyspkac-encoding)
        - [`certificate.verifySpkac(spkac[, encoding])`](#certificateverifyspkacspkac-encoding)
    - [클래스: `Cipher`](#클래스-cipher)
      - [`cipher.final([outputEncoding])`](#cipherfinaloutputencoding)
      - [`cipher.getAuthTag()`](#ciphergetauthtag)
      - [`cipher.setAAD(buffer[, options])`](#ciphersetaadbuffer-options)
      - [`cipher.setAutoPadding([autoPadding])`](#ciphersetautopaddingautopadding)
      - [`cipher.update(data[, inputEncoding][, outputEncoding])`](#cipherupdatedata-inputencoding-outputencoding)
    - [클래스: `Decipher`](#클래스-decipher)
      - [`decipher.final([outputEncoding])`](#decipherfinaloutputencoding)
      - [`decipher.setAAD(buffer[, options])`](#deciphersetaadbuffer-options)
      - [`decipher.setAuthTag(buffer[, encoding])`](#deciphersetauthtagbuffer-encoding)
      - [`decipher.setAutoPadding([autoPadding])`](#deciphersetautopaddingautopadding)
      - [`decipher.update(data[, inputEncoding][, outputEncoding])`](#decipherupdatedata-inputencoding-outputencoding)
    - [클래스: `DiffieHellman`](#클래스-diffiehellman)
      - [`diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])`](#diffiehellmancomputesecretotherpublickey-inputencoding-outputencoding)
      - [`diffieHellman.generateKeys([encoding])`](#diffiehellmangeneratekeysencoding)
      - [`diffieHellman.getGenerator([encoding])`](#diffiehellmangetgeneratorencoding)
      - [`diffieHellman.getPrime([encoding])`](#diffiehellmangetprimeencoding)
      - [`diffieHellman.getPrivateKey([encoding])`](#diffiehellmangetprivatekeyencoding)
      - [`diffieHellman.getPublicKey([encoding])`](#diffiehellmangetpublickeyencoding)
      - [`diffieHellman.setPrivateKey(privateKey[, encoding])`](#diffiehellmansetprivatekeyprivatekey-encoding)
      - [`diffieHellman.setPublicKey(publicKey[, encoding])`](#diffiehellmansetpublickeypublickey-encoding)
      - [`diffieHellman.verifyError`](#diffiehellmanverifyerror)
    - [클래스: `DiffieHellmanGroup`](#클래스-diffiehellmangroup)
    - [클래스: `ECDH`](#클래스-ecdh)
      - [정적 메서드: `ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])`](#정적-메서드-ecdhconvertkeykey-curve-inputencoding-outputencoding-format)
      - [`ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])`](#ecdhcomputesecretotherpublickey-inputencoding-outputencoding)
      - [`ecdh.generateKeys([encoding[, format]])`](#ecdhgeneratekeysencoding-format)
      - [`ecdh.getPrivateKey([encoding])`](#ecdhgetprivatekeyencoding)
      - [`ecdh.getPublicKey([encoding][, format])`](#ecdhgetpublickeyencoding-format)
      - [`ecdh.setPrivateKey(privateKey[, encoding])`](#ecdhsetprivatekeyprivatekey-encoding)
      - [`ecdh.setPublicKey(publicKey[, encoding])`](#ecdhsetpublickeypublickey-encoding)
    - [클래스: `Hash`](#클래스-hash)
      - [`hash.copy([options])`](#hashcopyoptions)
      - [`hash.digest([encoding])`](#hashdigestencoding)
      - [`hash.update(data[, inputEncoding])`](#hashupdatedata-inputencoding)
    - [클래스: `Hmac`](#클래스-hmac)
      - [`hmac.digest([encoding])`](#hmacdigestencoding)
      - [`hmac.update(data[, inputEncoding])`](#hmacupdatedata-inputencoding)
    - [클래스: `KeyObject`](#클래스-keyobject)
      - [정적 메서드: `KeyObject.from(key)`](#정적-메서드-keyobjectfromkey)
      - [`keyObject.asymmetricKeyDetails`](#keyobjectasymmetrickeydetails)
      - [`keyObject.asymmetricKeyType`](#keyobjectasymmetrickeytype)
      - [`keyObject.equals(otherKeyObject)`](#keyobjectequalsotherkeyobject)
      - [`keyObject.export([options])`](#keyobjectexportoptions)
      - [`keyObject.symmetricKeySize`](#keyobjectsymmetrickeysize)
      - [`keyObject.toCryptoKey(algorithm, extractable, keyUsages)`](#keyobjecttocryptokeyalgorithm-extractable-keyusages)
      - [`keyObject.type`](#keyobjecttype)
    - [클래스: `Sign`](#클래스-sign)
      - [`sign.sign(privateKey[, outputEncoding])`](#signsignprivatekey-outputencoding)
      - [`sign.update(data[, inputEncoding])`](#signupdatedata-inputencoding)
    - [클래스: `Verify`](#클래스-verify)
      - [`verify.update(data[, inputEncoding])`](#verifyupdatedata-inputencoding)
      - [`verify.verify(object, signature[, signatureEncoding])`](#verifyverifyobject-signature-signatureencoding)
    - [클래스: `X509Certificate`](#클래스-x509certificate)
      - [`new X509Certificate(buffer)`](#new-x509certificatebuffer)
      - [`x509.ca`](#x509ca)
      - [`x509.checkEmail(email[, options])`](#x509checkemailemail-options)
      - [`x509.checkHost(name[, options])`](#x509checkhostname-options)
      - [`x509.checkIP(ip)`](#x509checkipip)
      - [`x509.checkIssued(otherCert)`](#x509checkissuedothercert)
      - [`x509.checkPrivateKey(privateKey)`](#x509checkprivatekeyprivatekey)
      - [`x509.extKeyUsage`](#x509extkeyusage)
      - [`x509.fingerprint`](#x509fingerprint)
      - [`x509.fingerprint256`](#x509fingerprint256)
      - [`x509.fingerprint512`](#x509fingerprint512)
      - [`x509.infoAccess`](#x509infoaccess)
      - [`x509.issuer`](#x509issuer)
      - [`x509.issuerCertificate`](#x509issuercertificate)
      - [`x509.publicKey`](#x509publickey)
      - [`x509.raw`](#x509raw)
      - [`x509.serialNumber`](#x509serialnumber)
      - [`x509.subject`](#x509subject)
      - [`x509.subjectAltName`](#x509subjectaltname)
      - [`x509.toJSON()`](#x509tojson)
      - [`x509.toLegacyObject()`](#x509tolegacyobject)
      - [`x509.toString()`](#x509tostring)
      - [`x509.validFrom`](#x509validfrom)
      - [`x509.validFromDate`](#x509validfromdate)
      - [`x509.validTo`](#x509validto)
      - [`x509.validToDate`](#x509validtodate)
      - [`x509.verify(publicKey)`](#x509verifypublickey)
    - [`node:crypto` module methods and properties](#nodecrypto-module-methods-and-properties)
      - [`crypto.checkPrime(candidate[, options], callback)`](#cryptocheckprimecandidate-options-callback)
      - [`crypto.checkPrimeSync(candidate[, options])`](#cryptocheckprimesynccandidate-options)
      - [`crypto.constants`](#cryptoconstants)
      - [`crypto.createCipheriv(algorithm, key, iv[, options])`](#cryptocreatecipherivalgorithm-key-iv-options)
      - [`crypto.createDecipheriv(algorithm, key, iv[, options])`](#cryptocreatedecipherivalgorithm-key-iv-options)
      - [`crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])`](#cryptocreatediffiehellmanprime-primeencoding-generator-generatorencoding)
      - [`crypto.createDiffieHellman(primeLength[, generator])`](#cryptocreatediffiehellmanprimelength-generator)
      - [`crypto.createDiffieHellmanGroup(name)`](#cryptocreatediffiehellmangroupname)
      - [`crypto.createECDH(curveName)`](#cryptocreateecdhcurvename)
      - [`crypto.createHash(algorithm[, options])`](#cryptocreatehashalgorithm-options)
      - [`crypto.createHmac(algorithm, key[, options])`](#cryptocreatehmacalgorithm-key-options)
      - [`crypto.createPrivateKey(key)`](#cryptocreateprivatekeykey)
      - [`crypto.createPublicKey(key)`](#cryptocreatepublickeykey)
      - [`crypto.createSecretKey(key[, encoding])`](#cryptocreatesecretkeykey-encoding)
      - [`crypto.createSign(algorithm[, options])`](#cryptocreatesignalgorithm-options)
      - [`crypto.createVerify(algorithm[, options])`](#cryptocreateverifyalgorithm-options)
      - [`crypto.diffieHellman(options)`](#cryptodiffiehellmanoptions)
      - [`crypto.fips`](#cryptofips)
      - [`crypto.generateKey(type, options, callback)`](#cryptogeneratekeytype-options-callback)
      - [`crypto.generateKeyPair(type, options, callback)`](#cryptogeneratekeypairtype-options-callback)
      - [`crypto.generateKeyPairSync(type, options)`](#cryptogeneratekeypairsynctype-options)
      - [`crypto.generateKeySync(type, options)`](#cryptogeneratekeysynctype-options)
      - [`crypto.generatePrime(size[, options[, callback]])`](#cryptogenerateprimesize-options-callback)
      - [`crypto.generatePrimeSync(size[, options])`](#cryptogenerateprimesyncsize-options)
      - [`crypto.getCipherInfo(nameOrNid[, options])`](#cryptogetcipherinfonameornid-options)
      - [`crypto.getCiphers()`](#cryptogetciphers)
      - [`crypto.getCurves()`](#cryptogetcurves)
      - [`crypto.getDiffieHellman(groupName)`](#cryptogetdiffiehellmangroupname)
      - [`crypto.getFips()`](#cryptogetfips)
      - [`crypto.getHashes()`](#cryptogethashes)
      - [`crypto.getRandomValues(typedArray)`](#cryptogetrandomvaluestypedarray)
      - [`crypto.hash(algorithm, data[, outputEncoding])`](#cryptohashalgorithm-data-outputencoding)
      - [`crypto.hkdf(digest, ikm, salt, info, keylen, callback)`](#cryptohkdfdigest-ikm-salt-info-keylen-callback)
      - [`crypto.hkdfSync(digest, ikm, salt, info, keylen)`](#cryptohkdfsyncdigest-ikm-salt-info-keylen)
      - [`crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`](#cryptopbkdf2password-salt-iterations-keylen-digest-callback)
      - [`crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`](#cryptopbkdf2syncpassword-salt-iterations-keylen-digest)
      - [`crypto.privateDecrypt(privateKey, buffer)`](#cryptoprivatedecryptprivatekey-buffer)
      - [`crypto.privateEncrypt(privateKey, buffer)`](#cryptoprivateencryptprivatekey-buffer)
      - [`crypto.publicDecrypt(key, buffer)`](#cryptopublicdecryptkey-buffer)
      - [`crypto.publicEncrypt(key, buffer)`](#cryptopublicencryptkey-buffer)
      - [`crypto.randomBytes(size[, callback])`](#cryptorandombytessize-callback)
      - [`crypto.randomFill(buffer[, offset][, size], callback)`](#cryptorandomfillbuffer-offset-size-callback)
      - [`crypto.randomFillSync(buffer[, offset][, size])`](#cryptorandomfillsyncbuffer-offset-size)
      - [`crypto.randomInt([min, ]max[, callback])`](#cryptorandomintmin-max-callback)
      - [`crypto.randomUUID([options])`](#cryptorandomuuidoptions)
      - [`crypto.scrypt(password, salt, keylen[, options], callback)`](#cryptoscryptpassword-salt-keylen-options-callback)
      - [`crypto.scryptSync(password, salt, keylen[, options])`](#cryptoscryptsyncpassword-salt-keylen-options)
      - [`crypto.secureHeapUsed()`](#cryptosecureheapused)
      - [`crypto.setEngine(engine[, flags])`](#cryptosetengineengine-flags)
      - [`crypto.setFips(bool)`](#cryptosetfipsbool)
      - [`crypto.sign(algorithm, data, key[, callback])`](#cryptosignalgorithm-data-key-callback)
      - [`crypto.subtle`](#cryptosubtle)
      - [`crypto.timingSafeEqual(a, b)`](#cryptotimingsafeequala-b)
      - [`crypto.verify(algorithm, data, key, signature[, callback])`](#cryptoverifyalgorithm-data-key-signature-callback)
      - [`crypto.webcrypto`](#cryptowebcrypto)
    - [Notes](#notes)
      - [암호화 API에서 문자열 입력 사용하기](#암호화-api에서-문자열-입력-사용하기)
      - [레거시 스트림 API (Node.js 0.10 이전)](#레거시-스트림-api-nodejs-010-이전)
      - [취약하거나 문제가 있는 알고리즘 지원](#취약하거나-문제가-있는-알고리즘-지원)
      - [CCM 모드](#ccm-모드)
      - [FIPS 모드](#fips-모드)
- [fips 섹션 이름은 포함된 fipsmodule.cnf 파일 내의 섹션 이름과 일치해야 합니다.](#fips-섹션-이름은-포함된-fipsmodulecnf-파일-내의-섹션-이름과-일치해야-합니다)
- [fips 섹션 이름은 포함된 fipsmodule.cnf 파일 내의 섹션 이름과 일치해야 합니다.](#fips-섹션-이름은-포함된-fipsmodulecnf-파일-내의-섹션-이름과-일치해야-합니다)
    - [암호화 상수](#암호화-상수)
      - [OpenSSL 옵션](#openssl-옵션)
      - [OpenSSL 엔진 상수](#openssl-엔진-상수)
      - [기타 OpenSSL 상수](#기타-openssl-상수)
      - [Node.js crypto 상수](#nodejs-crypto-상수)

# Crypto

**소스 코드:** [lib/crypto.js](https://github.com/nodejs/node/blob/v23.5.0/lib/crypto.js)

`node:crypto` 모듈은 OpenSSL의 해시, HMAC, 암호화, 복호화, 서명 및 검증 기능을 위한 래퍼를 제공합니다.

```js
const { createHmac } = await import('node:crypto');
const secret = 'abcdefg';
const hash = createHmac('sha256', secret)
    .update('I love cupcakes')
    .digest('hex');
console.log(hash);
// 출력:
// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
```


### crypto 지원이 불가능한지 확인하기

Node.js는 `node:crypto` 모듈 지원 없이 빌드될 수 있습니다. 이런 경우, `crypto`에서 `import`를 시도하거나 `require('node:crypto')`를 호출하면 오류가 발생합니다.

CommonJS를 사용할 때는 try/catch를 통해 오류를 잡을 수 있습니다:

```js
let crypto;
try {
    crypto = require('node:crypto');
} catch (err) {
    console.error('crypto 지원이 비활성화되었습니다!');
}
```

ESM의 `import` 키워드를 사용할 때는, 모듈을 로드하기 전에 `process.on('uncaughtException')` 핸들러를 등록해야 오류를 잡을 수 있습니다. 예를 들어, preload 모듈을 사용할 수 있습니다.

ESM을 사용하면서 crypto 지원이 비활성화된 Node.js 빌드에서 코드가 실행될 가능성이 있다면, `import` 키워드 대신 [`import()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) 함수를 사용하는 것을 고려해 보세요:

```js
let crypto;
try {
    crypto = await import('node:crypto');
} catch (err) {
    console.error('crypto 지원이 비활성화되었습니다!');
}
```


### 클래스: `Certificate`[#](https://nodejs.org/docs/latest/api/crypto.html#class-certificate)

추가된 버전: v0.11.8

SPKAC는 원래 Netscape에서 구현된 인증서 서명 요청(Certificate Signing Request) 메커니즘이며, HTML5의 `<keygen>` 엘리먼트의 일부로 공식적으로 명세되었습니다.

`<keygen>`은 [HTML 5.2](https://www.w3.org/TR/html52/changes.html#features-removed)부터 더 이상 사용되지 않으며, 새로운 프로젝트에서는 이 엘리먼트를 사용하지 않는 것이 좋습니다.

`node:crypto` 모듈은 SPKAC 데이터를 다루기 위한 `Certificate` 클래스를 제공합니다. 가장 일반적인 사용 사례는 HTML5 `<keygen>` 엘리먼트에서 생성된 출력을 처리하는 것입니다. Node.js는 내부적으로 [OpenSSL의 SPKAC 구현](https://www.openssl.org/docs/man3.0/man1/openssl-spkac.html)을 사용합니다.


#### 정적 메서드: `Certificate.exportChallenge(spkac[, encoding])`

- `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `spkac` 데이터 구조의 챌린지 부분. 여기에는 공개 키와 챌린지가 포함됩니다.

```js
const { Certificate } = await import('node:crypto');
const spkac = getSpkacSomehow();
const challenge = Certificate.exportChallenge(spkac);
console.log(challenge.toString('utf8')); // 챌린지를 UTF8 문자열로 출력
```


#### 정적 메서드: `Certificate.exportPublicKey(spkac[, encoding])`

- `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `spkac` 데이터 구조의 공개 키 부분. 이는 공개 키와 챌린지를 포함합니다.

```js
const { Certificate } = await import('node:crypto');
const spkac = getSpkacSomehow();
const publicKey = Certificate.exportPublicKey(spkac);
console.log(publicKey); // 공개 키를 출력합니다.
```


#### 정적 메서드: `Certificate.verifySpkac(spkac[, encoding])`

- `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
- 반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 주어진 `spkac` 데이터 구조가 유효하면 `true`, 그렇지 않으면 `false`

```js
import { Buffer } from 'node:buffer';
const { Certificate } = await import('node:crypto');
const spkac = getSpkacSomehow();
console.log(Certificate.verifySpkac(Buffer.from(spkac))); // true 또는 false 출력
```


#### 레거시 API[#](https://nodejs.org/docs/latest/api/crypto.html#legacy-api)

레거시 인터페이스로, 아래 예제와 같이 `crypto.Certificate` 클래스의 새로운 인스턴스를 생성할 수 있습니다.


##### `new crypto.Certificate()`[#](https://nodejs.org/docs/latest/api/crypto.html#new-cryptocertificate)

`Certificate` 클래스의 인스턴스는 `new` 키워드를 사용하거나 `crypto.Certificate()`를 함수로 호출하여 생성할 수 있습니다.

```js
const { Certificate } = await import('node:crypto');
const cert1 = new Certificate();
const cert2 = Certificate();
```


##### `certificate.exportChallenge(spkac[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#certificateexportchallengespkac-encoding)

추가된 버전: v0.11.8

-   `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `spkac` 데이터 구조의 challenge 부분을 반환합니다. 이 부분은 공개 키와 challenge를 포함합니다.

```js
const { Certificate } = await import('node:crypto');
const cert = Certificate();
const spkac = getSpkacSomehow();
const challenge = cert.exportChallenge(spkac);
console.log(challenge.toString('utf8')); // challenge를 UTF8 문자열로 출력
```


##### `certificate.exportPublicKey(spkac[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#certificateexportpublickeyspkac-encoding)

추가된 버전: v0.11.8

-   `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `spkac` 데이터 구조의 공개 키 부분을 반환합니다. 이 데이터 구조는 공개 키와 챌린지를 포함합니다.

```js
const { Certificate } = await import('node:crypto');
const cert = Certificate();
const spkac = getSpkacSomehow();
const publicKey = cert.exportPublicKey(spkac);
console.log(publicKey); // 공개 키를 출력합니다.
```


##### `certificate.verifySpkac(spkac[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#certificateverifyspkacspkac-encoding)

추가된 버전: v0.11.8

-   `spkac` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `spkac` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 주어진 `spkac` 데이터 구조가 유효하면 `true`, 그렇지 않으면 `false`.

```js
import { Buffer } from 'node:buffer';
const { Certificate } = await import('node:crypto');
const cert = Certificate();
const spkac = getSpkacSomehow();
console.log(cert.verifySpkac(Buffer.from(spkac))); // true 또는 false 출력
```


### 클래스: `Cipher`[#](https://nodejs.org/docs/latest/api/crypto.html#class-cipher)

추가된 버전: v0.1.94

-   상속: [`<stream.Transform>`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform)

`Cipher` 클래스의 인스턴스는 데이터를 암호화하는 데 사용됩니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   읽기와 쓰기가 모두 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여, 평문 데이터를 쓰면 암호화된 데이터를 읽을 수 있게 합니다.
-   [`cipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#cipherupdatedata-inputencoding-outputencoding)와 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding) 메서드를 사용하여 암호화된 데이터를 생성합니다.

[`crypto.createCipheriv()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatecipherivalgorithm-key-iv-options) 메서드를 사용하여 `Cipher` 인스턴스를 생성합니다. `Cipher` 객체는 `new` 키워드를 사용하여 직접 생성하지 않습니다.

예제: `Cipher` 객체를 스트림으로 사용하기:

```js
const { scrypt, randomFill, createCipheriv, } = await import('node:crypto');
const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';

// 먼저 키를 생성합니다. 키 길이는 알고리즘에 따라 다릅니다.
// 이 경우 aes192는 24바이트(192비트)입니다.
scrypt(password, 'salt', 24, (err, key) => {
    if (err) throw err;

    // 그런 다음, 랜덤 초기화 벡터를 생성합니다.
    randomFill(new Uint8Array(16), (err, iv) => {
        if (err) throw err;

        // 키와 iv를 얻은 후, 암호화를 생성하고 사용합니다.
        const cipher = createCipheriv(algorithm, key, iv);
        let encrypted = '';
        cipher.setEncoding('hex');
        cipher.on('data', (chunk) => encrypted += chunk);
        cipher.on('end', () => console.log(encrypted));
        cipher.write('some clear text data');
        cipher.end();
    });
});
```

예제: `Cipher`와 파이프라인 스트림 사용하기:

```js
import { createReadStream, createWriteStream, } from 'node:fs';
import { pipeline, } from 'node:stream';
const { scrypt, randomFill, createCipheriv, } = await import('node:crypto');
const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';

// 먼저 키를 생성합니다. 키 길이는 알고리즘에 따라 다릅니다.
// 이 경우 aes192는 24바이트(192비트)입니다.
scrypt(password, 'salt', 24, (err, key) => {
    if (err) throw err;

    // 그런 다음, 랜덤 초기화 벡터를 생성합니다.
    randomFill(new Uint8Array(16), (err, iv) => {
        if (err) throw err;

        const cipher = createCipheriv(algorithm, key, iv);
        const input = createReadStream('test.js');
        const output = createWriteStream('test.enc');
        pipeline(input, cipher, output, (err) => {
            if (err) throw err;
        });
    });
});
```

예제: [`cipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#cipherupdatedata-inputencoding-outputencoding)와 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding) 메서드 사용하기:

```js
const { scrypt, randomFill, createCipheriv, } = await import('node:crypto');
const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';

// 먼저 키를 생성합니다. 키 길이는 알고리즘에 따라 다릅니다.
// 이 경우 aes192는 24바이트(192비트)입니다.
scrypt(password, 'salt', 24, (err, key) => {
    if (err) throw err;

    // 그런 다음, 랜덤 초기화 벡터를 생성합니다.
    randomFill(new Uint8Array(16), (err, iv) => {
        if (err) throw err;

        const cipher = createCipheriv(algorithm, key, iv);
        let encrypted = cipher.update('some clear text data', 'utf8', 'hex');
        encrypted += cipher.final('hex');
        console.log(encrypted);
    });
});
```


#### `cipher.final([outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding)

추가된 버전: v0.1.94

-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 남아있는 암호화된 내용. `outputEncoding`이 지정되면 문자열이 반환됩니다. `outputEncoding`이 제공되지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`cipher.final()` 메서드가 호출된 후에는 `Cipher` 객체를 더 이상 데이터 암호화에 사용할 수 없습니다. `cipher.final()`을 두 번 이상 호출하려고 하면 오류가 발생합니다.


#### `cipher.getAuthTag()`[#](https://nodejs.org/docs/latest/api/crypto.html#ciphergetauthtag)

추가된 버전: v1.0.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)  
    인증된 암호화 모드(`GCM`, `CCM`, `OCB`, `chacha20-poly1305`가 현재 지원됨)를 사용할 때, `cipher.getAuthTag()` 메서드는 주어진 데이터로부터 계산된 *인증 태그(authentication tag)*를 포함하는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)를 반환합니다.

`cipher.getAuthTag()` 메서드는 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding) 메서드를 사용하여 암호화가 완료된 후에만 호출해야 합니다.

`cipher` 인스턴스 생성 시 `authTagLength` 옵션이 설정되었다면, 이 함수는 정확히 `authTagLength` 바이트를 반환합니다.


#### `cipher.setAAD(buffer[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#ciphersetaadbuffer-options)

추가된 버전: v1.0.0

-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
    -   `plaintextLength` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`가 문자열일 때 사용할 문자열 인코딩.
-   반환값: [`<Cipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-cipher) 메서드 체이닝을 위해 동일한 `Cipher` 인스턴스를 반환.

인증된 암호화 모드(`GCM`, `CCM`, `OCB`, `chacha20-poly1305`가 현재 지원됨)를 사용할 때, `cipher.setAAD()` 메서드는 *추가 인증 데이터*(AAD) 입력 파라미터에 사용될 값을 설정한다.

`plaintextLength` 옵션은 `GCM`과 `OCB`에서 선택 사항이다. `CCM`을 사용할 때는 `plaintextLength` 옵션을 반드시 지정해야 하며, 그 값은 평문의 바이트 길이와 일치해야 한다. [CCM 모드](https://nodejs.org/docs/latest/api/crypto.html#ccm-mode)를 참고하라.

`cipher.setAAD()` 메서드는 [`cipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#cipherupdatedata-inputencoding-outputencoding)를 호출하기 전에 반드시 호출해야 한다.


#### `cipher.setAutoPadding([autoPadding])`[#](https://nodejs.org/docs/latest/api/crypto.html#ciphersetautopaddingautopadding)

추가된 버전: v0.7.1

-   `autoPadding` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `true`
-   반환값: [`<Cipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-cipher) 메서드 체이닝을 위해 동일한 `Cipher` 인스턴스를 반환합니다.

블록 암호화 알고리즘을 사용할 때, `Cipher` 클래스는 입력 데이터에 적절한 블록 크기에 맞게 자동으로 패딩을 추가합니다. 기본 패딩을 비활성화하려면 `cipher.setAutoPadding(false)`를 호출하세요.

`autoPadding`이 `false`로 설정되면, 전체 입력 데이터의 길이는 암호화 블록 크기의 배수여야 합니다. 그렇지 않으면 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding)이 에러를 발생시킵니다. 자동 패딩을 비활성화하는 것은 PKCS 패딩 대신 `0x0`과 같은 비표준 패딩을 사용할 때 유용합니다.

`cipher.setAutoPadding()` 메서드는 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding)을 호출하기 전에 반드시 호출되어야 합니다.


#### `cipher.update(data[, inputEncoding][, outputEncoding])`

- `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 데이터의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
- `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
- 반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`cipher.update()` 메서드는 `data`를 사용하여 암호화를 업데이트합니다. `inputEncoding` 인자가 주어지면, `data`는 지정된 인코딩을 사용하는 문자열이어야 합니다. `inputEncoding` 인자가 주어지지 않으면, `data`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView` 타입이어야 합니다. 만약 `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView` 타입이라면, `inputEncoding`은 무시됩니다.

`outputEncoding`은 암호화된 데이터의 출력 형식을 지정합니다. `outputEncoding`이 지정되면, 지정된 인코딩을 사용한 문자열이 반환됩니다. `outputEncoding`이 제공되지 않으면, [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`cipher.update()` 메서드는 [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding)이 호출되기 전까지 새로운 데이터와 함께 여러 번 호출될 수 있습니다. [`cipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#cipherfinaloutputencoding) 이후에 `cipher.update()`를 호출하면 에러가 발생합니다.


### 클래스: `Decipher`[#](https://nodejs.org/docs/latest/api/crypto.html#class-decipher)

추가된 버전: v0.1.94

-   상속: [`<stream.Transform>`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform)

`Decipher` 클래스의 인스턴스는 데이터를 복호화하는 데 사용됩니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   읽기와 쓰기가 모두 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여, 암호화된 데이터를 쓰면 읽기 가능한 쪽에서 복호화된 데이터를 생성하거나,
-   [`decipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#decipherupdatedata-inputencoding-outputencoding)와 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding) 메서드를 사용하여 복호화된 데이터를 생성합니다.

[`crypto.createDecipheriv()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatedecipherivalgorithm-key-iv-options) 메서드는 `Decipher` 인스턴스를 생성하는 데 사용됩니다. `Decipher` 객체는 `new` 키워드를 사용하여 직접 생성하지 않습니다.

예제: `Decipher` 객체를 스트림으로 사용하기:

```js
import { Buffer } from 'node:buffer';
const { scryptSync, createDecipheriv } = await import('node:crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// 키 길이는 알고리즘에 따라 다릅니다. 이 경우 aes192는 24바이트(192비트)입니다.
// 비동기 `crypto.scrypt()`를 대신 사용하세요.
const key = scryptSync(password, 'salt', 24);
// IV는 일반적으로 암호문과 함께 전달됩니다.
const iv = Buffer.alloc(16, 0); // 초기화 벡터.
const decipher = createDecipheriv(algorithm, key, iv);

let decrypted = '';
decipher.on('readable', () => {
    let chunk;
    while (null !== (chunk = decipher.read())) {
        decrypted += chunk.toString('utf8');
    }
});

decipher.on('end', () => {
    console.log(decrypted); // 출력: some clear text data
});

// 동일한 알고리즘, 키, IV로 암호화된 데이터.
const encrypted = 'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
decipher.write(encrypted, 'hex');
decipher.end();
```

예제: `Decipher`와 파이프된 스트림 사용하기:

```js
import { createReadStream, createWriteStream } from 'node:fs';
import { Buffer } from 'node:buffer';
const { scryptSync, createDecipheriv } = await import('node:crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// 비동기 `crypto.scrypt()`를 대신 사용하세요.
const key = scryptSync(password, 'salt', 24);
// IV는 일반적으로 암호문과 함께 전달됩니다.
const iv = Buffer.alloc(16, 0); // 초기화 벡터.
const decipher = createDecipheriv(algorithm, key, iv);

const input = createReadStream('test.enc');
const output = createWriteStream('test.js');

input.pipe(decipher).pipe(output);
```

예제: [`decipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#decipherupdatedata-inputencoding-outputencoding)와 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding) 메서드 사용하기:

```js
import { Buffer } from 'node:buffer';
const { scryptSync, createDecipheriv } = await import('node:crypto');

const algorithm = 'aes-192-cbc';
const password = 'Password used to generate key';
// 비동기 `crypto.scrypt()`를 대신 사용하세요.
const key = scryptSync(password, 'salt', 24);
// IV는 일반적으로 암호문과 함께 전달됩니다.
const iv = Buffer.alloc(16, 0); // 초기화 벡터.
const decipher = createDecipheriv(algorithm, key, iv);

// 동일한 알고리즘, 키, IV로 암호화된 데이터.
const encrypted = 'e5f79c5915c02171eec6b212d5520d44480993d7d622a7c4c2da32f6efda0ffa';
let decrypted = decipher.update(encrypted, 'hex', 'utf8');
decrypted += decipher.final('utf8');

console.log(decrypted); // 출력: some clear text data
```


#### `decipher.final([outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding)

추가된 버전: v0.1.94

-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 남아 있는 복호화된 내용. `outputEncoding`이 지정되면 문자열이 반환됩니다. `outputEncoding`이 제공되지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`decipher.final()` 메서드가 호출된 후에는 `Decipher` 객체를 더 이상 데이터 복호화에 사용할 수 없습니다. `decipher.final()`을 두 번 이상 호출하려고 하면 오류가 발생합니다.


#### `decipher.setAAD(buffer[, options])`

- `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
    - `plaintextLength` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    - `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`가 문자열일 때 사용할 문자열 인코딩.
- 반환값: [`<Decipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-decipher) 메서드 체이닝을 위해 동일한 Decipher 객체를 반환.

인증된 암호화 모드(`GCM`, `CCM`, `OCB`, `chacha20-poly1305`가 현재 지원됨)를 사용할 때, `decipher.setAAD()` 메서드는 *추가 인증 데이터*(AAD) 입력 파라미터에 사용될 값을 설정합니다.

`options` 인자는 `GCM`에서는 선택 사항입니다. `CCM`을 사용할 때는 `plaintextLength` 옵션을 반드시 지정해야 하며, 그 값은 암호문의 길이(바이트 단위)와 일치해야 합니다. 자세한 내용은 [CCM 모드](https://nodejs.org/docs/latest/api/crypto.html#ccm-mode)를 참고하세요.

`decipher.setAAD()` 메서드는 [`decipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#decipherupdatedata-inputencoding-outputencoding)를 호출하기 전에 반드시 호출해야 합니다.

`buffer`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.


#### `decipher.setAuthTag(buffer[, encoding])`

- `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`가 문자열일 때 사용할 인코딩.
- 반환값: [`<Decipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-decipher) 메서드 체이닝을 위해 동일한 Decipher 객체를 반환.

인증된 암호화 모드(`GCM`, `CCM`, `OCB`, `chacha20-poly1305`가 현재 지원됨)를 사용할 때, `decipher.setAuthTag()` 메서드는 수신된 **인증 태그**를 전달하는 데 사용됩니다. 태그가 제공되지 않거나 암호문이 변조된 경우, [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding)은 인증 실패로 인해 암호문을 폐기해야 함을 나타내는 예외를 던집니다. 태그 길이가 [NIST SP 800-38D](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf)에 따라 유효하지 않거나 `authTagLength` 옵션의 값과 일치하지 않으면, `decipher.setAuthTag()`는 오류를 발생시킵니다.

`decipher.setAuthTag()` 메서드는 `CCM` 모드에서는 [`decipher.update()`](https://nodejs.org/docs/latest/api/crypto.html#decipherupdatedata-inputencoding-outputencoding) 전에, `GCM` 및 `OCB` 모드와 `chacha20-poly1305`에서는 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding) 전에 호출해야 합니다. `decipher.setAuthTag()`는 한 번만 호출할 수 있습니다.

인증 태그로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.


#### `decipher.setAutoPadding([autoPadding])`[#](https://nodejs.org/docs/latest/api/crypto.html#deciphersetautopaddingautopadding)

추가된 버전: v0.7.1

-   `autoPadding` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `true`
-   반환값: [`<Decipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-decipher) 메서드 체이닝을 위한 동일한 Decipher 객체

데이터가 표준 블록 패딩 없이 암호화된 경우, `decipher.setAutoPadding(false)`를 호출하면 자동 패딩을 비활성화하여 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding)이 패딩을 확인하고 제거하는 것을 방지할 수 있습니다.

자동 패딩을 끄려면 입력 데이터의 길이가 암호화 블록 크기의 배수여야 합니다.

`decipher.setAutoPadding()` 메서드는 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding) 이전에 호출되어야 합니다.


#### `decipher.update(data[, inputEncoding][, outputEncoding])`

- `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `data` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- 반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`data`를 사용하여 디코딩을 업데이트합니다. `inputEncoding` 인자가 주어지면, `data`는 지정된 인코딩을 사용한 문자열이어야 합니다. `inputEncoding` 인자가 주어지지 않으면, `data`는 반드시 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)여야 합니다. `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)라면 `inputEncoding`은 무시됩니다.

`outputEncoding`은 디코딩된 데이터의 출력 형식을 지정합니다. `outputEncoding`이 지정되면, 지정된 인코딩을 사용한 문자열이 반환됩니다. `outputEncoding`이 제공되지 않으면, [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`decipher.update()` 메서드는 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding)이 호출될 때까지 새로운 데이터와 함께 여러 번 호출할 수 있습니다. [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding) 이후에 `decipher.update()`를 호출하면 에러가 발생합니다.

기본 암호화 알고리즘이 인증을 구현하더라도, 이 함수에서 반환된 평문의 진위와 무결성은 현재 시점에서 확실하지 않을 수 있습니다. 인증된 암호화 알고리즘의 경우, 일반적으로 애플리케이션이 [`decipher.final()`](https://nodejs.org/docs/latest/api/crypto.html#decipherfinaloutputencoding)을 호출할 때만 진위가 확인됩니다.


### 클래스: `DiffieHellman`[#](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellman)

추가된 버전: v0.5.0

`DiffieHellman` 클래스는 Diffie-Hellman 키 교환을 생성하기 위한 유틸리티입니다.

`DiffieHellman` 클래스의 인스턴스는 [`crypto.createDiffieHellman()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatediffiehellmanprime-primeencoding-generator-generatorencoding) 함수를 사용하여 생성할 수 있습니다.

```js
import assert from 'node:assert';
const { createDiffieHellman } = await import('node:crypto');

// Alice의 키 생성
const alice = createDiffieHellman(2048);
const aliceKey = alice.generateKeys();

// Bob의 키 생성
const bob = createDiffieHellman(alice.getPrime(), alice.getGenerator());
const bobKey = bob.generateKeys();

// 키 교환 및 비밀키 생성
const aliceSecret = alice.computeSecret(bobKey);
const bobSecret = bob.computeSecret(aliceKey);

// 검증
assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex'));
```


#### `diffieHellman.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmancomputesecretotherpublickey-inputencoding-outputencoding)

추가된 버전: v0.5.0

-   `otherPublicKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `otherPublicKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`otherPublicKey`를 상대방의 공개 키로 사용하여 공유 비밀키를 계산하고, 계산된 공유 비밀키를 반환합니다. 제공된 키는 지정된 `inputEncoding`을 사용하여 해석되며, 비밀키는 지정된 `outputEncoding`을 사용하여 인코딩됩니다. `inputEncoding`이 제공되지 않으면, `otherPublicKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 간주됩니다.

`outputEncoding`이 주어지면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `diffieHellman.generateKeys([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangeneratekeysencoding)

추가된 버전: v0.5.0

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 메서드는 Diffie-Hellman의 개인 키와 공개 키를 생성합니다. 이미 생성되거나 계산된 키가 없다면 새로운 키를 생성하고, 지정된 `encoding` 방식으로 공개 키를 반환합니다. 이 공개 키는 상대방에게 전달되어야 합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

이 함수는 [`DH_generate_key()`](https://www.openssl.org/docs/man3.0/man3/DH_generate_key.html)를 간단히 감싼 래퍼입니다. 특히, 개인 키가 이미 생성되거나 설정된 경우, 이 함수를 호출하면 공개 키만 업데이트되고 새로운 개인 키는 생성되지 않습니다.


#### `diffieHellman.getGenerator([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangetgeneratorencoding)

추가된 버전: v0.5.0

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

지정된 `encoding` 방식으로 Diffie-Hellman 생성기를 반환합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `diffieHellman.getPrime([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangetprimeencoding)

추가된 버전: v0.5.0

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

지정된 `encoding`으로 Diffie-Hellman 소수를 반환합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `diffieHellman.getPrivateKey([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangetprivatekeyencoding)

추가된 버전: v0.5.0

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

지정된 `encoding` 방식으로 Diffie-Hellman 개인 키를 반환합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `diffieHellman.getPublicKey([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangetpublickeyencoding)

추가된 버전: v0.5.0

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

지정된 `encoding` 방식으로 Diffie-Hellman 공개 키를 반환합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `diffieHellman.setPrivateKey(privateKey[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmansetprivatekeyprivatekey-encoding)

추가된 버전: v0.5.0

-   `privateKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `privateKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.

Diffie-Hellman 개인 키를 설정합니다. `encoding` 인자가 제공되면, `privateKey`는 문자열로 예상됩니다. `encoding`이 제공되지 않으면, `privateKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.

이 함수는 자동으로 관련된 공개 키를 계산하지 않습니다. 공개 키를 수동으로 제공하거나 자동으로 유도하려면 [`diffieHellman.setPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmansetpublickeypublickey-encoding) 또는 [`diffieHellman.generateKeys()`](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmangeneratekeysencoding)를 사용할 수 있습니다.


#### `diffieHellman.setPublicKey(publicKey[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmansetpublickeypublickey-encoding)

추가된 버전: v0.5.0

-   `publicKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `publicKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.

Diffie-Hellman 공개 키를 설정합니다. `encoding` 인자가 제공되면, `publicKey`는 문자열로 예상됩니다. `encoding`이 제공되지 않으면, `publicKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.


#### `diffieHellman.verifyError`[#](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmanverifyerror)

추가된 버전: v0.11.12

`DiffieHellman` 객체 초기화 과정에서 수행된 검사로 인해 발생한 경고나 오류를 나타내는 비트 필드입니다.

이 속성에 사용할 수 있는 값은 다음과 같습니다 (`node:constants` 모듈에 정의됨):

```javascript
- DH_CHECK_P_NOT_SAFE_PRIME
- DH_CHECK_P_NOT_PRIME
- DH_UNABLE_TO_CHECK_GENERATOR
- DH_NOT_SUITABLE_GENERATOR
```


### 클래스: `DiffieHellmanGroup`[#](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellmangroup)

추가된 버전: v0.7.5

`DiffieHellmanGroup` 클래스는 잘 알려진 modp 그룹을 인자로 받습니다. 이 클래스는 `DiffieHellman`과 동일하게 작동하지만, 생성 후에 키를 변경할 수 없다는 점이 다릅니다. 즉, `setPublicKey()`나 `setPrivateKey()` 메서드를 구현하지 않습니다.

```js
const { createDiffieHellmanGroup } = await import('node:crypto');
const dh = createDiffieHellmanGroup('modp16');
```

다음과 같은 그룹들이 지원됩니다:

-   `'modp14'` (2048 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 3)
-   `'modp15'` (3072 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 4)
-   `'modp16'` (4096 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 5)
-   `'modp17'` (6144 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 6)
-   `'modp18'` (8192 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 7)

다음 그룹들은 여전히 지원되지만 더 이상 권장되지 않습니다 ([주의사항](https://nodejs.org/docs/latest/api/crypto.html#support-for-weak-or-compromised-algorithms) 참조):

-   `'modp1'` (768 비트, [RFC 2409](https://www.rfc-editor.org/rfc/rfc2409.txt) Section 6.1)
-   `'modp2'` (1024 비트, [RFC 2409](https://www.rfc-editor.org/rfc/rfc2409.txt) Section 6.2)
-   `'modp5'` (1536 비트, [RFC 3526](https://www.rfc-editor.org/rfc/rfc3526.txt) Section 2)

이 더 이상 권장되지 않는 그룹들은 Node.js의 향후 버전에서 제거될 수 있습니다.


### 클래스: `ECDH`[#](https://nodejs.org/docs/latest/api/crypto.html#class-ecdh)

추가된 버전: v0.11.14

`ECDH` 클래스는 타원 곡선 디피-헬만(ECDH) 키 교환을 생성하기 위한 유틸리티입니다.

`ECDH` 클래스의 인스턴스는 [`crypto.createECDH()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateecdhcurvename) 함수를 사용하여 생성할 수 있습니다.

```js
import assert from 'node:assert';
const { createECDH } = await import('node:crypto');

// Alice의 키 생성
const alice = createECDH('secp521r1');
const aliceKey = alice.generateKeys();

// Bob의 키 생성
const bob = createECDH('secp521r1');
const bobKey = bob.generateKeys();

// 키 교환 및 비밀키 생성
const aliceSecret = alice.computeSecret(bobKey);
const bobSecret = bob.computeSecret(aliceKey);

// 비밀키가 동일한지 확인
assert.strictEqual(aliceSecret.toString('hex'), bobSecret.toString('hex')); // OK
```


#### 정적 메서드: `ECDH.convertKey(key, curve[, inputEncoding[, outputEncoding[, format]]])`[#](https://nodejs.org/docs/latest/api/crypto.html#static-method-ecdhconvertkeykey-curve-inputencoding-outputencoding-format)

추가된 버전: v10.0.0

-   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `curve` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `key` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'uncompressed'`
-   반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`key`와 `curve`로 지정된 EC Diffie-Hellman 공개 키를 `format`에 지정된 형식으로 변환합니다. `format` 인자는 포인트 인코딩을 지정하며 `'compressed'`, `'uncompressed'`, `'hybrid'` 중 하나일 수 있습니다. 제공된 키는 `inputEncoding`을 사용해 해석되며, 반환된 키는 `outputEncoding`을 사용해 인코딩됩니다.

사용 가능한 곡선 이름 목록을 얻으려면 [`crypto.getCurves()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetcurves)를 사용하세요. 최신 OpenSSL 릴리스에서는 `openssl ecparam -list_curves`를 실행해 사용 가능한 타원 곡선의 이름과 설명을 확인할 수 있습니다.

`format`이 지정되지 않으면 포인트는 `'uncompressed'` 형식으로 반환됩니다.

`inputEncoding`이 제공되지 않으면 `key`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 간주됩니다.

예제 (키 압축 해제):

```js
const { createECDH, ECDH } = await import('node:crypto');
const ecdh = createECDH('secp256k1');
ecdh.generateKeys();

const compressedKey = ecdh.getPublicKey('hex', 'compressed');
const uncompressedKey = ECDH.convertKey(compressedKey, 'secp256k1', 'hex', 'hex', 'uncompressed');

// 변환된 키와 압축 해제된 공개 키는 동일해야 함
console.log(uncompressedKey === ecdh.getPublicKey('hex'));
```


#### `ecdh.computeSecret(otherPublicKey[, inputEncoding][, outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhcomputesecretotherpublickey-inputencoding-outputencoding)

-   `otherPublicKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `otherPublicKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환 값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환 값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`otherPublicKey`를 상대방의 공개 키로 사용하여 공유 비밀키를 계산하고, 계산된 공유 비밀키를 반환합니다. 제공된 키는 지정된 `inputEncoding`을 사용해 해석되며, 반환된 비밀키는 지정된 `outputEncoding`을 사용해 인코딩됩니다. `inputEncoding`이 제공되지 않으면, `otherPublicKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 간주됩니다.

`outputEncoding`이 주어지면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`otherPublicKey`가 타원 곡선의 범위를 벗어날 경우, `ecdh.computeSecret`은 `ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY` 오류를 발생시킵니다. `otherPublicKey`는 일반적으로 불안전한 네트워크를 통해 원격 사용자로부터 제공되므로, 이 예외를 적절히 처리해야 합니다.


#### `ecdh.generateKeys([encoding[, format]])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhgeneratekeysencoding-format)

추가된 버전: v0.11.14

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'uncompressed'`
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

EC Diffie-Hellman의 개인 키와 공개 키를 생성하고, 지정된 `format`과 `encoding`으로 공개 키를 반환합니다. 이 키는 상대방에게 전달되어야 합니다.

`format` 인자는 포인트 인코딩 방식을 지정하며, `'compressed'` 또는 `'uncompressed'` 중 하나를 선택할 수 있습니다. `format`이 지정되지 않으면, 기본적으로 `'uncompressed'` 형식으로 반환됩니다.

`encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `ecdh.getPrivateKey([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhgetprivatekeyencoding)

추가된 버전: v0.11.14

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지정된 `encoding` 방식으로 변환된 EC Diffie-Hellman 개인 키.

`encoding`이 지정되면 문자열이 반환됩니다. 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `ecdh.getPublicKey([encoding][, format])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhgetpublickeyencoding-format)

추가된 버전: v0.11.14

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'uncompressed'`
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지정된 `encoding`과 `format`으로 된 EC Diffie-Hellman 공개키.

`format` 인자는 포인트 인코딩 방식을 지정하며, `'compressed'` 또는 `'uncompressed'` 중 하나를 선택할 수 있습니다. `format`이 지정되지 않으면 `'uncompressed'` 형식으로 반환됩니다.

`encoding`이 지정되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.


#### `ecdh.setPrivateKey(privateKey[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhsetprivatekeyprivatekey-encoding)

추가된 버전: v0.11.14

-   `privateKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `privateKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.

EC Diffie-Hellman 개인 키를 설정합니다. `encoding`이 제공되면 `privateKey`는 문자열로 예상됩니다. 그렇지 않으면 `privateKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.

`privateKey`가 `ECDH` 객체가 생성될 때 지정된 곡선에 대해 유효하지 않으면 오류가 발생합니다. 개인 키를 설정하면 관련된 공개 키도 생성되어 `ECDH` 객체에 설정됩니다.


#### `ecdh.setPublicKey(publicKey[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#ecdhsetpublickeypublickey-encoding)

추가된 버전: v0.11.14  
사용 중단(deprecated) 버전: v5.2.0

-   `publicKey` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `publicKey` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.

EC(Elliptic Curve) Diffie-Hellman 공개 키를 설정합니다. `encoding`이 제공되면 `publicKey`는 문자열로 예상됩니다. 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`가 예상됩니다.

일반적으로 이 메서드를 호출할 필요는 없습니다. `ECDH`는 공유 비밀을 계산하기 위해 개인 키와 상대방의 공개 키만 필요로 하기 때문입니다. 보통 [`ecdh.generateKeys()`](https://nodejs.org/docs/latest/api/crypto.html#ecdhgeneratekeysencoding-format) 또는 [`ecdh.setPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#ecdhsetprivatekeyprivatekey-encoding)가 호출됩니다. [`ecdh.setPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#ecdhsetprivatekeyprivatekey-encoding) 메서드는 설정된 개인 키와 관련된 공개 키를 자동으로 생성하려고 시도합니다.

예제 (공유 비밀 얻기):

```js
const { createECDH, createHash } = await import('node:crypto');

const alice = createECDH('secp256k1');
const bob = createECDH('secp256k1');

// 이는 Alice의 이전 개인 키를 간단히 지정하는 방법입니다.
// 실제 애플리케이션에서는 이렇게 예측 가능한 개인 키를 사용하는 것은 좋지 않습니다.
alice.setPrivateKey(
  createHash('sha256').update('alice', 'utf8').digest()
);

// Bob은 새로 생성된 암호학적으로 강력한 의사 난수 키 쌍을 사용합니다.
bob.generateKeys();

const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');

// aliceSecret과 bobSecret은 동일한 공유 비밀 값이어야 합니다.
console.log(aliceSecret === bobSecret);
```


### 클래스: `Hash`[#](https://nodejs.org/docs/latest/api/crypto.html#class-hash)

추가된 버전: v0.1.92

-   상속: [`<stream.Transform>`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform)

`Hash` 클래스는 데이터의 해시 다이제스트를 생성하는 유틸리티입니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   읽기와 쓰기가 모두 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여 데이터를 쓰고, 읽기 측에서 계산된 해시 다이제스트를 생성하거나,
-   [`hash.update()`](https://nodejs.org/docs/latest/api/crypto.html#hashupdatedata-inputencoding)와 [`hash.digest()`](https://nodejs.org/docs/latest/api/crypto.html#hashdigestencoding) 메서드를 사용하여 계산된 해시를 생성합니다.

[`crypto.createHash()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatehashalgorithm-options) 메서드를 사용하여 `Hash` 인스턴스를 생성합니다. `Hash` 객체는 `new` 키워드를 사용하여 직접 생성하지 않습니다.

예제: `Hash` 객체를 스트림으로 사용하기:

```js
const { createHash } = await import('node:crypto');
const hash = createHash('sha256');

hash.on('readable', () => {
    // 해시 스트림에서 하나의 요소만 생성됩니다.
    const data = hash.read();
    if (data) {
        console.log(data.toString('hex'));
        // 출력:
        // 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
    }
});

hash.write('some data to hash');
hash.end();
```

예제: `Hash`와 파이프된 스트림 사용하기:

```js
import { createReadStream } from 'node:fs';
import { stdout } from 'node:process';
const { createHash } = await import('node:crypto');

const hash = createHash('sha256');
const input = createReadStream('test.js');

input.pipe(hash).setEncoding('hex').pipe(stdout);
```

예제: [`hash.update()`](https://nodejs.org/docs/latest/api/crypto.html#hashupdatedata-inputencoding)와 [`hash.digest()`](https://nodejs.org/docs/latest/api/crypto.html#hashdigestencoding) 메서드 사용하기:

```js
const { createHash } = await import('node:crypto');
const hash = createHash('sha256');

hash.update('some data to hash');
console.log(hash.digest('hex'));
// 출력:
// 6a2da20943931e9834fc12cfe5bb47bbd9ae43489a30726962b576f4e3993e50
```


#### `hash.copy([options])`[#](https://nodejs.org/docs/latest/api/crypto.html#hashcopyoptions)

추가된 버전: v13.1.0

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
-   반환값: [`<Hash>`](https://nodejs.org/docs/latest/api/crypto.html#class-hash)

현재 `Hash` 객체의 내부 상태를 깊은 복사한 새로운 `Hash` 객체를 생성합니다.

선택적 `options` 인자는 스트림 동작을 제어합니다. `'shake256'`과 같은 XOF 해시 함수의 경우, `outputLength` 옵션을 사용하여 원하는 출력 길이를 바이트 단위로 지정할 수 있습니다.

`Hash` 객체의 [`hash.digest()`](https://nodejs.org/docs/latest/api/crypto.html#hashdigestencoding) 메서드가 호출된 후에 복사를 시도하면 오류가 발생합니다.

```js
// 롤링 해시 계산
const { createHash } = await import('node:crypto');
const hash = createHash('sha256');

hash.update('one');
console.log(hash.copy().digest('hex'));

hash.update('two');
console.log(hash.copy().digest('hex'));

hash.update('three');
console.log(hash.copy().digest('hex'));

// 기타
```


#### `hash.digest([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#hashdigestencoding)

추가된 버전: v0.1.92

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

[`hash.update()`](https://nodejs.org/docs/latest/api/crypto.html#hashupdatedata-inputencoding) 메서드를 통해 전달된 모든 데이터의 해시 값을 계산합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`hash.digest()` 메서드가 호출된 후에는 `Hash` 객체를 다시 사용할 수 없습니다. 여러 번 호출하면 오류가 발생합니다.


#### `hash.update(data[, inputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#hashupdatedata-inputencoding)

-   `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `data` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings)

주어진 `data`로 해시 내용을 업데이트합니다. `data`의 인코딩은 `inputEncoding`으로 지정됩니다. `encoding`이 제공되지 않고 `data`가 문자열인 경우, `'utf8'` 인코딩이 강제로 적용됩니다. `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`인 경우, `inputEncoding`은 무시됩니다.

이 메서드는 스트리밍되는 새로운 데이터와 함께 여러 번 호출할 수 있습니다.


### 클래스: `Hmac`[#](https://nodejs.org/docs/latest/api/crypto.html#class-hmac)

추가된 버전: v0.1.94

-   상속: [`<stream.Transform>`](https://nodejs.org/docs/latest/api/stream.html#class-streamtransform)

`Hmac` 클래스는 암호화된 HMAC 다이제스트를 생성하는 유틸리티입니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   읽기와 쓰기가 모두 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여 데이터를 쓰고, 읽기 측에서 계산된 HMAC 다이제스트를 생성하거나,
-   [`hmac.update()`](https://nodejs.org/docs/latest/api/crypto.html#hmacupdatedata-inputencoding)와 [`hmac.digest()`](https://nodejs.org/docs/latest/api/crypto.html#hmacdigestencoding) 메서드를 사용하여 계산된 HMAC 다이제스트를 생성합니다.

[`crypto.createHmac()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatehmacalgorithm-key-options) 메서드를 사용하여 `Hmac` 인스턴스를 생성합니다. `Hmac` 객체는 `new` 키워드를 사용하여 직접 생성하지 않습니다.

예제: `Hmac` 객체를 스트림으로 사용하기:

```js
const { createHmac } = await import('node:crypto');
const hmac = createHmac('sha256', 'a secret');

hmac.on('readable', () => {
    // 해시 스트림에서 하나의 요소만 생성됩니다.
    const data = hmac.read();
    if (data) {
        console.log(data.toString('hex'));
        // 출력:
        // 7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
    }
});

hmac.write('some data to hash');
hmac.end();
```

예제: `Hmac`과 파이프된 스트림 사용하기:

```js
import { createReadStream } from 'node:fs';
import { stdout } from 'node:process';
const { createHmac } = await import('node:crypto');

const hmac = createHmac('sha256', 'a secret');
const input = createReadStream('test.js');
input.pipe(hmac).pipe(stdout);
```

예제: [`hmac.update()`](https://nodejs.org/docs/latest/api/crypto.html#hmacupdatedata-inputencoding)와 [`hmac.digest()`](https://nodejs.org/docs/latest/api/crypto.html#hmacdigestencoding) 메서드 사용하기:

```js
const { createHmac } = await import('node:crypto');
const hmac = createHmac('sha256', 'a secret');

hmac.update('some data to hash');
console.log(hmac.digest('hex'));
// 출력:
// 7fd04df92f636fd450bc841c9418e5825c17f33ad9c87c518115a45971f7f77e
```


#### `hmac.digest([encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#hmacdigestencoding)

추가된 버전: v0.1.94

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

[`hmac.update()`](https://nodejs.org/docs/latest/api/crypto.html#hmacupdatedata-inputencoding)를 통해 전달된 모든 데이터의 HMAC 다이제스트를 계산합니다. `encoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`hmac.digest()`가 호출된 후에는 `Hmac` 객체를 다시 사용할 수 없습니다. `hmac.digest()`를 여러 번 호출하면 오류가 발생합니다.


#### `hmac.update(data[, inputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#hmacupdatedata-inputencoding)

- `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `data` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings)

주어진 `data`로 `Hmac` 내용을 업데이트합니다. `data`의 인코딩은 `inputEncoding`으로 지정됩니다. `inputEncoding`이 제공되지 않고 `data`가 문자열인 경우, `'utf8'` 인코딩이 강제로 적용됩니다. `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`인 경우, `inputEncoding`은 무시됩니다.

이 메서드는 스트리밍되는 새로운 데이터와 함께 여러 번 호출할 수 있습니다.


### 클래스: `KeyObject`[#](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

Node.js는 `KeyObject` 클래스를 사용하여 대칭 키 또는 비대칭 키를 표현합니다. 각 키 유형은 서로 다른 함수를 제공합니다. [`crypto.createSecretKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatesecretkeykey-encoding), [`crypto.createPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey), 그리고 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey) 메서드를 사용하여 `KeyObject` 인스턴스를 생성할 수 있습니다. `KeyObject` 객체는 `new` 키워드를 사용해 직접 생성할 수 없습니다.

대부분의 애플리케이션은 보안 기능이 개선된 새로운 `KeyObject` API를 사용하는 것을 고려해야 합니다. 이는 키를 문자열이나 `Buffer`로 전달하는 방식보다 더 안전합니다.

`KeyObject` 인스턴스는 [`postMessage()`](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist)를 통해 다른 스레드로 전달할 수 있습니다. 수신 측에서는 복제된 `KeyObject`를 얻게 되며, `KeyObject`는 `transferList` 인자에 포함할 필요가 없습니다.


#### 정적 메서드: `KeyObject.from(key)`[#](https://nodejs.org/docs/latest/api/crypto.html#static-method-keyobjectfromkey)

추가된 버전: v15.0.0

-   `key` [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
-   반환값: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

예제: `CryptoKey` 인스턴스를 `KeyObject`로 변환하기:

```js
const { KeyObject } = await import('node:crypto');
const { subtle } = globalThis.crypto;

const key = await subtle.generateKey(
  {
    name: 'HMAC',
    hash: 'SHA-256',
    length: 256,
  },
  true,
  ['sign', 'verify']
);

const keyObject = KeyObject.from(key);
console.log(keyObject.symmetricKeySize); // 출력: 32 (대칭 키 크기, 바이트 단위)
```


#### `keyObject.asymmetricKeyDetails`

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `modulusLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 키 크기(비트 단위, RSA, DSA).
    -   `publicExponent`: [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) 공개 지수(RSA).
    -   `hashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 메시지 다이제스트 이름(RSA-PSS).
    -   `mgf1HashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) MGF1에서 사용하는 메시지 다이제스트 이름(RSA-PSS).
    -   `saltLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 최소 솔트 길이(바이트 단위, RSA-PSS).
    -   `divisorLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `q`의 크기(비트 단위, DSA).
    -   `namedCurve`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 곡선 이름(EC).

이 속성은 비대칭 키에만 존재합니다. 키의 타입에 따라 이 객체는 키에 대한 정보를 포함합니다. 이 속성을 통해 얻은 정보는 키를 고유하게 식별하거나 키의 보안을 훼손하는 데 사용할 수 없습니다.

RSA-PSS 키의 경우, 키 자료에 `RSASSA-PSS-params` 시퀀스가 포함되어 있다면 `hashAlgorithm`, `mgf1HashAlgorithm`, `saltLength` 속성이 설정됩니다.

추가 속성을 통해 이 API로 다른 키 세부 정보가 노출될 수도 있습니다.


#### `keyObject.asymmetricKeyType`

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

비대칭 키의 경우, 이 속성은 키의 타입을 나타냅니다. 지원되는 키 타입은 다음과 같습니다:

-   `'rsa'` (OID 1.2.840.113549.1.1.1)
-   `'rsa-pss'` (OID 1.2.840.113549.1.1.10)
-   `'dsa'` (OID 1.2.840.10040.4.1)
-   `'ec'` (OID 1.2.840.10045.2.1)
-   `'x25519'` (OID 1.3.101.110)
-   `'x448'` (OID 1.3.101.111)
-   `'ed25519'` (OID 1.3.101.112)
-   `'ed448'` (OID 1.3.101.113)
-   `'dh'` (OID 1.2.840.113549.1.3.1)

이 속성은 인식되지 않는 `KeyObject` 타입과 대칭 키의 경우 `undefined`입니다.


#### `keyObject.equals(otherKeyObject)`[#](https://nodejs.org/docs/latest/api/crypto.html#keyobjectequalsotherkeyobject)

추가된 버전: v17.7.0, v16.15.0

-   `otherKeyObject`: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) `keyObject`와 비교할 `KeyObject`
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

두 키의 타입, 값, 매개변수가 완전히 동일한지 여부에 따라 `true` 또는 `false`를 반환합니다. 이 메서드는 [상수 시간](https://en.wikipedia.org/wiki/Timing_attack)을 보장하지 않습니다.


#### `keyObject.export([options])`

- `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- 반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

**대칭 키**의 경우, 다음과 같은 인코딩 옵션을 사용할 수 있습니다:

- `format`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'buffer'` (기본값) 또는 `'jwk'` 중 하나여야 합니다.

**공개 키**의 경우, 다음과 같은 인코딩 옵션을 사용할 수 있습니다:

- `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pkcs1'` (RSA 전용) 또는 `'spki'` 중 하나여야 합니다.
- `format`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pem'`, `'der'`, 또는 `'jwk'` 중 하나여야 합니다.

**개인 키**의 경우, 다음과 같은 인코딩 옵션을 사용할 수 있습니다:

- `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pkcs1'` (RSA 전용), `'pkcs8'`, 또는 `'sec1'` (EC 전용) 중 하나여야 합니다.
- `format`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pem'`, `'der'`, 또는 `'jwk'` 중 하나여야 합니다.
- `cipher`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지정된 경우, 개인 키는 PKCS#5 v2.0 비밀번호 기반 암호화를 사용하여 주어진 `cipher`와 `passphrase`로 암호화됩니다.
- `passphrase`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 암호화에 사용할 비밀번호입니다. `cipher`를 참조하세요.

결과 타입은 선택한 인코딩 포맷에 따라 달라집니다. PEM 포맷일 경우 결과는 문자열이고, DER 포맷일 경우 DER로 인코딩된 데이터를 포함하는 버퍼가 됩니다. [JWK](https://tools.ietf.org/html/rfc7517) 포맷일 경우 객체가 반환됩니다.

[JWK](https://tools.ietf.org/html/rfc7517) 인코딩 포맷을 선택한 경우, 다른 모든 인코딩 옵션은 무시됩니다.

PKCS#1, SEC1, 그리고 PKCS#8 타입 키는 `cipher`와 `format` 옵션을 조합하여 암호화할 수 있습니다. PKCS#8 `type`은 모든 `format`과 함께 사용할 수 있으며, `cipher`를 지정하여 모든 키 알고리즘(RSA, EC, 또는 DH)을 암호화할 수 있습니다. PKCS#1과 SEC1은 PEM `format`을 사용할 때만 `cipher`를 지정하여 암호화할 수 있습니다. 최대 호환성을 위해 암호화된 개인 키에는 PKCS#8을 사용하세요. PKCS#8은 자체 암호화 메커니즘을 정의하기 때문에, PKCS#8 키를 암호화할 때 PEM 수준의 암호화는 지원되지 않습니다. PKCS#8 암호화에 대해서는 [RFC 5208](https://www.rfc-editor.org/rfc/rfc5208.txt)을, PKCS#1과 SEC1 암호화에 대해서는 [RFC 1421](https://www.rfc-editor.org/rfc/rfc1421.txt)을 참조하세요.


#### `keyObject.symmetricKeySize`[#](https://nodejs.org/docs/latest/api/crypto.html#keyobjectsymmetrickeysize)

추가된 버전: v11.6.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

비밀 키의 경우, 이 속성은 키의 크기를 바이트 단위로 나타냅니다. 비대칭 키의 경우 이 속성은 `undefined`입니다.


#### `keyObject.toCryptoKey(algorithm, extractable, keyUsages)`[#](https://nodejs.org/docs/latest/api/crypto.html#keyobjecttocryptokeyalgorithm-extractable-keyusages)

추가된 버전: v23.0.0

-   `algorithm`: [`<AlgorithmIdentifier>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-algorithmidentifier) | [`<RsaHashedImportParams>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-rsahashedimportparams) | [`<EcKeyImportParams>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-eckeyimportparams) | [`<HmacImportParams>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-hmacimportparams)

-   `extractable`: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   `keyUsages`: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) [키 사용법](https://nodejs.org/docs/latest/api/webcrypto.html#cryptokeyusages) 참조.
-   반환값: [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)

`KeyObject` 인스턴스를 `CryptoKey`로 변환합니다.


#### `keyObject.type`[#](https://nodejs.org/docs/latest/api/crypto.html#keyobjecttype)

v11.6.0에서 추가됨

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 `KeyObject`의 타입에 따라, 이 속성은 비밀(대칭) 키일 경우 `'secret'`, 공개(비대칭) 키일 경우 `'public'`, 그리고 개인(비대칭) 키일 경우 `'private'` 값을 가집니다.


### 클래스: `Sign`[#](https://nodejs.org/docs/latest/api/crypto.html#class-sign)

추가된 버전: v0.1.92

-   상속: [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)

`Sign` 클래스는 서명을 생성하는 유틸리티입니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   쓰기 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여 서명할 데이터를 쓰고, [`sign.sign()`](https://nodejs.org/docs/latest/api/crypto.html#signsignprivatekey-outputencoding) 메서드를 사용해 서명을 생성하고 반환하는 방식, 또는
-   [`sign.update()`](https://nodejs.org/docs/latest/api/crypto.html#signupdatedata-inputencoding)와 [`sign.sign()`](https://nodejs.org/docs/latest/api/crypto.html#signsignprivatekey-outputencoding) 메서드를 사용해 서명을 생성하는 방식.

[`crypto.createSign()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatesignalgorithm-options) 메서드를 사용해 `Sign` 인스턴스를 생성합니다. 인자로는 사용할 해시 함수의 문자열 이름을 전달합니다. `Sign` 객체는 `new` 키워드를 사용해 직접 생성하지 않습니다.

예제: `Sign`과 [`Verify`](https://nodejs.org/docs/latest/api/crypto.html#class-verify) 객체를 스트림으로 사용하는 예제:

```js
const { generateKeyPairSync, createSign, createVerify, } = await import('node:crypto');
const { privateKey, publicKey } = generateKeyPairSync('ec', { namedCurve: 'sect239k1', });
const sign = createSign('SHA256');
sign.write('some data to sign');
sign.end();
const signature = sign.sign(privateKey, 'hex');
const verify = createVerify('SHA256');
verify.write('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature, 'hex')); // 출력: true
```

예제: [`sign.update()`](https://nodejs.org/docs/latest/api/crypto.html#signupdatedata-inputencoding)와 [`verify.update()`](https://nodejs.org/docs/latest/api/crypto.html#verifyupdatedata-inputencoding) 메서드를 사용하는 예제:

```js
const { generateKeyPairSync, createSign, createVerify, } = await import('node:crypto');
const { privateKey, publicKey } = generateKeyPairSync('rsa', { modulusLength: 2048, });
const sign = createSign('SHA256');
sign.update('some data to sign');
sign.end();
const signature = sign.sign(privateKey);
const verify = createVerify('SHA256');
verify.update('some data to sign');
verify.end();
console.log(verify.verify(publicKey, signature)); // 출력: true
```


#### `sign.sign(privateKey[, outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#signsignprivatekey-outputencoding)

-   `privateKey` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
    -   `dsaEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `padding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `saltLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반환값의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

[`sign.update()`](https://nodejs.org/docs/latest/api/crypto.html#signupdatedata-inputencoding) 또는 [`sign.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)를 통해 전달된 모든 데이터에 대해 서명을 계산합니다.

`privateKey`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `privateKey`가 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)에 전달된 것처럼 동작합니다. 만약 객체라면, 다음과 같은 추가 속성을 전달할 수 있습니다:

-   `dsaEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) DSA와 ECDSA의 경우, 이 옵션은 생성된 서명의 형식을 지정합니다. 다음 중 하나일 수 있습니다:
    
    -   `'der'` (기본값): DER로 인코딩된 ASN.1 서명 구조 `(r, s)`.
    -   `'ieee-p1363'`: IEEE-P1363에서 제안된 `r || s` 형식의 서명.
-   `padding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) RSA에 대한 선택적 패딩 값으로, 다음 중 하나일 수 있습니다:
    
    -   `crypto.constants.RSA_PKCS1_PADDING` (기본값)
    -   `crypto.constants.RSA_PKCS1_PSS_PADDING`
    
    `RSA_PKCS1_PSS_PADDING`은 [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt) 섹션 3.1에 명시된 대로 메시지 서명에 사용된 해시 함수와 동일한 MGF1을 사용합니다. 단, [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt) 섹션 3.3에 따라 키의 일부로 MGF1 해시 함수가 지정된 경우는 예외입니다.
    
-   `saltLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 패딩이 `RSA_PKCS1_PSS_PADDING`일 때의 솔트 길이입니다. 특수 값 `crypto.constants.RSA_PSS_SALTLEN_DIGEST`는 솔트 길이를 다이제스트 크기로 설정하고, `crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN` (기본값)은 최대 허용 값으로 설정합니다.

`outputEncoding`이 제공되면 문자열이 반환되고, 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 반환됩니다.

`sign.sign()` 메서드가 호출된 후에는 `Sign` 객체를 다시 사용할 수 없습니다. `sign.sign()`을 여러 번 호출하면 오류가 발생합니다.


#### `sign.update(data[, inputEncoding])`

- `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `data` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings)

주어진 `data`로 `Sign` 내용을 업데이트합니다. `data`의 인코딩은 `inputEncoding`으로 지정됩니다. `encoding`이 제공되지 않고 `data`가 문자열인 경우, `'utf8'` 인코딩이 강제로 적용됩니다. `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`인 경우, `inputEncoding`은 무시됩니다.

이 메서드는 스트리밍되는 새로운 데이터와 함께 여러 번 호출할 수 있습니다.


### 클래스: `Verify`[#](https://nodejs.org/docs/latest/api/crypto.html#class-verify)

추가된 버전: v0.1.92

-   상속: [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable)

`Verify` 클래스는 서명을 검증하기 위한 유틸리티입니다. 이 클래스는 두 가지 방식으로 사용할 수 있습니다:

-   쓰기 가능한 [스트림](https://nodejs.org/docs/latest/api/stream.html)으로 사용하여, 쓰여진 데이터를 제공된 서명과 비교하여 검증하거나,
-   [`verify.update()`](https://nodejs.org/docs/latest/api/crypto.html#verifyupdatedata-inputencoding)와 [`verify.verify()`](https://nodejs.org/docs/latest/api/crypto.html#verifyverifyobject-signature-signatureencoding) 메서드를 사용하여 서명을 검증합니다.

[`crypto.createVerify()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateverifyalgorithm-options) 메서드를 사용하여 `Verify` 인스턴스를 생성합니다. `Verify` 객체는 `new` 키워드를 사용하여 직접 생성하지 않습니다.

예제는 [`Sign`](https://nodejs.org/docs/latest/api/crypto.html#class-sign)을 참고하세요.


#### `verify.update(data[, inputEncoding])`

- `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `inputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `data` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings)

주어진 `data`로 `Verify` 내용을 업데이트합니다. `inputEncoding`은 `data`의 인코딩을 지정합니다. `inputEncoding`이 제공되지 않고 `data`가 문자열인 경우, `'utf8'` 인코딩이 강제로 적용됩니다. `data`가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`인 경우, `inputEncoding`은 무시됩니다.

이 메서드는 스트리밍되는 새로운 데이터와 함께 여러 번 호출할 수 있습니다.


#### `verify.verify(object, signature[, signatureEncoding])`

- `object` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
  - `dsaEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
  - `padding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
  - `saltLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `signature` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `signatureEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `signature` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- 반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 데이터와 공개 키에 대한 서명의 유효성에 따라 `true` 또는 `false`를 반환.

제공된 데이터를 `object`와 `signature`를 사용하여 검증합니다.

`object`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `object`가 [`crypto.createPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey)에 전달된 것처럼 동작합니다. `object`가 객체인 경우, 다음과 같은 추가 속성을 전달할 수 있습니다:

- `dsaEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) DSA와 ECDSA의 경우, 이 옵션은 서명의 형식을 지정합니다. 다음 중 하나일 수 있습니다:
  - `'der'` (기본값): DER로 인코딩된 ASN.1 서명 구조 `(r, s)`.
  - `'ieee-p1363'`: IEEE-P1363에서 제안된 `r || s` 형식의 서명.
  
- `padding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) RSA에 대한 선택적 패딩 값으로, 다음 중 하나일 수 있습니다:
  - `crypto.constants.RSA_PKCS1_PADDING` (기본값)
  - `crypto.constants.RSA_PKCS1_PSS_PADDING`
  
  `RSA_PKCS1_PSS_PADDING`은 [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt) 섹션 3.1에 명시된 대로 메시지 검증에 사용된 해시 함수와 동일한 MGF1을 사용합니다. 단, [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt) 섹션 3.3에 따라 키의 일부로 MGF1 해시 함수가 지정된 경우는 예외입니다.
  
- `saltLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 패딩이 `RSA_PKCS1_PSS_PADDING`일 때의 솔트 길이입니다. 특수 값 `crypto.constants.RSA_PSS_SALTLEN_DIGEST`는 솔트 길이를 다이제스트 크기로 설정하고, `crypto.constants.RSA_PSS_SALTLEN_AUTO` (기본값)는 자동으로 결정되도록 합니다.

`signature` 인자는 데이터에 대해 이전에 계산된 서명으로, `signatureEncoding`에 따라 제공됩니다. `signatureEncoding`이 지정된 경우, `signature`는 문자열로 예상됩니다. 그렇지 않으면 `signature`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.

`verify` 객체는 `verify.verify()`가 호출된 후 다시 사용할 수 없습니다. `verify.verify()`를 여러 번 호출하면 오류가 발생합니다.

공개 키는 개인 키에서 파생될 수 있으므로, 공개 키 대신 개인 키를 전달할 수도 있습니다.


### 클래스: `X509Certificate`[#](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate)

추가된 버전: v15.6.0

X509 인증서를 캡슐화하고 해당 정보에 대한 읽기 전용 접근을 제공합니다.

```js
const { X509Certificate } = await import('node:crypto');
const x509 = new X509Certificate('{... pem encoded cert ...}');
console.log(x509.subject);
```


#### `new X509Certificate(buffer)`[#](https://nodejs.org/docs/latest/api/crypto.html#new-x509certificatebuffer)

추가된 버전: v15.6.0

-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
    PEM 또는 DER 형식으로 인코딩된 X509 인증서입니다.


#### `x509.ca`[#](https://nodejs.org/docs/latest/api/crypto.html#x509ca)

추가된 버전: v15.6.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
  이 인증서가 인증 기관(CA) 인증서인 경우 `true`로 설정됩니다.


#### `x509.checkEmail(email[, options])`

-   `email` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `subject` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'default'`, `'always'`, 또는 `'never'`. **기본값:** `'default'`.
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 인증서가 일치하면 `email`을 반환하고, 일치하지 않으면 `undefined`를 반환합니다.

이 메서드는 인증서가 주어진 이메일 주소와 일치하는지 확인합니다.

`'subject'` 옵션이 정의되지 않았거나 `'default'`로 설정된 경우, 인증서 주체는 주체 대체 이름 확장이 존재하지 않거나 이메일 주소를 포함하지 않을 때만 고려됩니다.

`'subject'` 옵션이 `'always'`로 설정되고, 주체 대체 이름 확장이 존재하지 않거나 일치하는 이메일 주소를 포함하지 않을 경우, 인증서 주체가 고려됩니다.

`'subject'` 옵션이 `'never'`로 설정된 경우, 인증서에 주체 대체 이름이 포함되어 있지 않더라도 인증서 주체는 절대 고려되지 않습니다.


#### `x509.checkHost(name[, options])`

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `subject` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'default'`, `'always'`, 또는 `'never'`. **기본값:** `'default'`.
    -   `wildcards` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `true`.
    -   `partialWildcards` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `true`.
    -   `multiLabelWildcards` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`.
    -   `singleLabelSubdomains` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`.
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) `name`과 일치하는 주체 이름을 반환합니다. 일치하는 이름이 없으면 `undefined`를 반환합니다.

이 메서드는 인증서가 주어진 호스트 이름과 일치하는지 확인합니다.

인증서가 주어진 호스트 이름과 일치하면, 일치하는 주체 이름을 반환합니다. 반환된 이름은 정확한 일치일 수도 있고(예: `foo.example.com`), 와일드카드를 포함할 수도 있습니다(예: `*.example.com`). 호스트 이름 비교는 대소문자를 구분하지 않기 때문에, 반환된 주체 이름은 주어진 `name`과 대소문자가 다를 수 있습니다.

`'subject'` 옵션이 정의되지 않았거나 `'default'`로 설정된 경우, 인증서 주체는 주체 대체 이름 확장이 존재하지 않거나 DNS 이름을 포함하지 않는 경우에만 고려됩니다. 이 동작은 [RFC 2818](https://www.rfc-editor.org/rfc/rfc2818.txt)("HTTP Over TLS")과 일치합니다.

`'subject'` 옵션이 `'always'`로 설정된 경우, 주체 대체 이름 확장이 존재하지 않거나 일치하는 DNS 이름을 포함하지 않으면 인증서 주체를 고려합니다.

`'subject'` 옵션이 `'never'`로 설정된 경우, 인증서에 주체 대체 이름이 포함되어 있지 않더라도 인증서 주체를 고려하지 않습니다.


#### `x509.checkIP(ip)`[#](https://nodejs.org/docs/latest/api/crypto.html#x509checkipip)

-   `ip` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  인증서가 주어진 IP 주소와 일치하면 `ip`를 반환하고, 일치하지 않으면 `undefined`를 반환합니다.

이 메서드는 인증서가 주어진 IP 주소(IPv4 또는 IPv6)와 일치하는지 확인합니다.

[RFC 5280](https://www.rfc-editor.org/rfc/rfc5280.txt)에 정의된 `iPAddress` 주체 대체 이름만 고려되며, 이는 주어진 `ip` 주소와 정확히 일치해야 합니다. 다른 주체 대체 이름이나 인증서의 주체 필드는 무시됩니다.


#### `x509.checkIssued(otherCert)`[#](https://nodejs.org/docs/latest/api/crypto.html#x509checkissuedothercert)

v15.6.0에서 추가됨

-   `otherCert` [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드는 현재 인증서가 주어진 `otherCert`에 의해 발급되었는지 확인합니다.


#### `x509.checkPrivateKey(privateKey)`[#](https://nodejs.org/docs/latest/api/crypto.html#x509checkprivatekeyprivatekey)

추가된 버전: v15.6.0

-   `privateKey` [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) 개인 키
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 인증서의 공개 키가 주어진 개인 키와 일치하는지 확인합니다.


#### `x509.extKeyUsage`[#](https://nodejs.org/docs/latest/api/crypto.html#x509extkeyusage)

추가된 버전: v15.6.0

-   타입: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 확장 키 사용 목록을 담은 배열입니다.


#### `x509.fingerprint`[#](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 SHA-1 지문입니다.

SHA-1은 암호학적으로 취약하며, 일반적으로 인증서 서명에 사용되는 알고리즘에 비해 보안성이 현저히 떨어집니다. 따라서 [`x509.fingerprint256`](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint256)을 대신 사용하는 것을 고려해 보세요.


#### `x509.fingerprint256`[#](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint256)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 SHA-256 지문입니다.


#### `x509.fingerprint512`[#](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint512)

추가된 버전: v17.2.0, v16.14.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 SHA-512 지문입니다.

SHA-256 지문을 계산하는 것이 일반적으로 더 빠르고, 크기가 SHA-512 지문의 절반이기 때문에 [`x509.fingerprint256`](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint256)을 사용하는 것이 더 나은 선택일 수 있습니다. SHA-512는 일반적으로 더 높은 수준의 보안을 제공하지만, SHA-256의 보안은 대부분의 인증서 서명 알고리즘과 동등합니다.


#### `x509.infoAccess`[#](https://nodejs.org/docs/latest/api/crypto.html#x509infoaccess)

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 속성은 인증서의 **권한 정보 접근 확장**을 텍스트로 표현한 것입니다.

이 값은 줄바꿈으로 구분된 접근 설명 목록입니다. 각 줄은 접근 방법과 접근 위치의 종류로 시작하며, 콜론 뒤에 접근 위치와 관련된 값이 옵니다.

접근 방법과 접근 위치의 종류를 나타내는 접두사 뒤에, 각 줄의 나머지 부분은 값이 JSON 문자열 리터럴임을 나타내기 위해 따옴표로 둘러싸일 수 있습니다. 하위 호환성을 위해 Node.js는 이 속성 내에서 모호함을 피하기 위해 필요한 경우에만 JSON 문자열 리터럴을 사용합니다. 따라서 서드파티 코드는 두 가지 가능한 형식을 모두 처리할 수 있어야 합니다.


#### `x509.issuer`[#](https://nodejs.org/docs/latest/api/crypto.html#x509issuer)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서에 포함된 발급자 식별 정보입니다.


#### `x509.issuerCertificate`[#](https://nodejs.org/docs/latest/api/crypto.html#x509issuercertificate)

추가된 버전: v15.9.0

-   타입: [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate)

발급자 인증서를 반환합니다. 발급자 인증서가 없는 경우 `undefined`를 반환합니다.


#### `x509.publicKey`[#](https://nodejs.org/docs/latest/api/crypto.html#x509publickey)

추가된 버전: v15.6.0

-   타입: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

이 인증서의 공개 키를 나타내는 [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)입니다.


#### `x509.raw`[#](https://nodejs.org/docs/latest/api/crypto.html#x509raw)

추가된 버전: v15.6.0

-   타입: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 인증서의 DER 인코딩을 포함하는 `Buffer`입니다.


#### `x509.serialNumber`[#](https://nodejs.org/docs/latest/api/crypto.html#x509serialnumber)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 일련번호입니다.

일련번호는 인증 기관(CA)에 의해 할당되며, 인증서를 고유하게 식별하지는 않습니다. 고유 식별자로는 [`x509.fingerprint256`](https://nodejs.org/docs/latest/api/crypto.html#x509fingerprint256)을 사용하는 것을 고려해 보세요.


#### `x509.subject`[#](https://nodejs.org/docs/latest/api/crypto.html#x509subject)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서의 전체 주체(subject)를 나타냅니다.


#### `x509.subjectAltName`

- 타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서에 지정된 주체 대체 이름(subject alternative name)입니다.

이 값은 쉼표로 구분된 주체 대체 이름 목록입니다. 각 항목은 주체 대체 이름의 종류를 나타내는 문자열로 시작하며, 콜론과 해당 항목의 값이 뒤따릅니다.

이전 버전의 Node.js는 이 속성을 두 문자 시퀀스 `', '`로 분리해도 안전하다고 잘못 가정했습니다([CVE-2021-44532](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44532) 참조). 그러나 악의적이거나 정상적인 인증서 모두 이 시퀀스를 포함한 주체 대체 이름을 문자열로 표현할 수 있습니다.

항목의 타입을 나타내는 접두사 이후, 각 항목의 나머지 부분은 값이 JSON 문자열 리터럴임을 나타내기 위해 따옴표로 둘러싸일 수 있습니다. 하위 호환성을 위해 Node.js는 모호함을 피하기 위해 필요한 경우에만 이 속성 내에서 JSON 문자열 리터럴을 사용합니다. 서드파티 코드는 두 가지 가능한 항목 형식을 모두 처리할 수 있도록 준비해야 합니다.


#### `x509.toJSON()`[#](https://nodejs.org/docs/latest/api/crypto.html#x509tojson)

추가된 버전: v15.6.0

- 타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

X509 인증서를 위한 표준 JSON 인코딩은 존재하지 않습니다. `toJSON()` 메서드는 PEM으로 인코딩된 인증서를 포함하는 문자열을 반환합니다.


#### `x509.toLegacyObject()`[#](https://nodejs.org/docs/latest/api/crypto.html#x509tolegacyobject)

추가된 버전: v15.6.0

-   타입: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 메서드는 레거시 [certificate object](https://nodejs.org/docs/latest/api/tls.html#certificate-object) 인코딩을 사용하여 이 인증서에 대한 정보를 반환합니다.


#### `x509.toString()`[#](https://nodejs.org/docs/latest/api/crypto.html#x509tostring)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

PEM 형식으로 인코딩된 인증서를 반환합니다.


#### `x509.validFrom`[#](https://nodejs.org/docs/latest/api/crypto.html#x509validfrom)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서가 유효한 시작 날짜/시간을 나타냅니다.


#### `x509.validFromDate`[#](https://nodejs.org/docs/latest/api/crypto.html#x509validfromdate)

추가된 버전: v23.0.0

-   타입: [`<Date>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)

이 인증서가 유효한 시작 날짜/시간을 `Date` 객체로 캡슐화한 값입니다.


#### `x509.validTo`[#](https://nodejs.org/docs/latest/api/crypto.html#x509validto)

추가된 버전: v15.6.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 인증서가 유효한 날짜/시간을 나타냅니다.


#### `x509.validToDate`[#](https://nodejs.org/docs/latest/api/crypto.html#x509validtodate)

추가된 버전: v23.0.0

- 타입: [`<Date>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)

이 인증서가 유효한 날짜/시간을 `Date` 객체로 캡슐화한 값입니다.


#### `x509.verify(publicKey)`[#](https://nodejs.org/docs/latest/api/crypto.html#x509verifypublickey)

추가된 버전: v15.6.0

-   `publicKey` [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) 공개 키
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드는 해당 인증서가 주어진 공개 키로 서명되었는지 확인합니다. 인증서에 대한 다른 유효성 검사는 수행하지 않습니다.


### `node:crypto` module methods and properties[#](https://nodejs.org/docs/latest/api/crypto.html#nodecrypto-module-methods-and-properties)





#### `crypto.checkPrime(candidate[, options], callback)`

- `candidate` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)  
  임의의 길이로 빅 엔디안 방식으로 인코딩된 소수 후보입니다.

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
  - `checks` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    수행할 Miller-Rabin 확률적 소수 판정 반복 횟수입니다. 값이 `0`일 경우, 무작위 입력에 대해 최대 2<sup>-64</sup>의 오탐률을 보장하는 횟수가 사용됩니다. 반복 횟수를 선택할 때 주의가 필요합니다. 자세한 내용은 OpenSSL 문서의 [`BN_is_prime_ex`](https://www.openssl.org/docs/man1.1.1/man3/BN_is_prime_ex.html) 함수의 `nchecks` 옵션을 참고하세요. **기본값:** `0`

- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
  - `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)  
    검사 중 오류가 발생한 경우 [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 객체로 설정됩니다.  
  - `result` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    후보가 소수일 경우 `true`를 반환하며, 오류 확률은 `0.25 ** options.checks`보다 작습니다.

`candidate`의 소수 여부를 검사합니다.


#### `crypto.checkPrimeSync(candidate[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocheckprimesynccandidate-options)

추가된 버전: v15.8.0

-   `candidate` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)  
    임의의 길이로 빅 엔디안 옥텟 시퀀스로 인코딩된 소수 후보입니다.

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `checks` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        수행할 Miller-Rabin 확률적 소수 판정 반복 횟수입니다. 값이 `0`일 경우, 무작위 입력에 대해 최대 2<sup>-64</sup>의 오탐률을 보장하는 횟수가 사용됩니다. 반복 횟수를 선택할 때 주의가 필요합니다. 자세한 내용은 OpenSSL 문서의 [`BN_is_prime_ex`](https://www.openssl.org/docs/man1.1.1/man3/BN_is_prime_ex.html) 함수 `nchecks` 옵션을 참고하세요. **기본값:** `0`

-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    후보가 소수일 경우 `true`를 반환하며, 오류 확률은 `0.25 ** options.checks`보다 작습니다.

`candidate`의 소수 여부를 확인합니다.


#### `crypto.constants`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants)

추가된 버전: v6.3.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 객체는 암호화 및 보안 관련 작업에서 자주 사용되는 상수들을 포함하고 있습니다. 현재 정의된 구체적인 상수들은 [Crypto constants](https://nodejs.org/docs/latest/api/crypto.html#crypto-constants)에서 확인할 수 있습니다.


#### `crypto.createCipheriv(algorithm, key, iv[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatecipherivalgorithm-key-iv-options)

-   `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
-   `iv` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` options](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
-   Returns: [`<Cipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-cipher)

주어진 `algorithm`, `key`, 그리고 초기화 벡터(`iv`)를 사용하여 `Cipher` 객체를 생성하고 반환합니다.

`options` 인자는 스트림 동작을 제어하며, CCM 또는 OCB 모드(예: `'aes-128-ccm'`)에서 사용할 때는 필수입니다. 이 경우, `authTagLength` 옵션은 인증 태그의 길이를 바이트 단위로 지정해야 합니다. 자세한 내용은 [CCM 모드](https://nodejs.org/docs/latest/api/crypto.html#ccm-mode)를 참조하세요. GCM 모드에서는 `authTagLength` 옵션이 필수는 아니지만, `getAuthTag()`가 반환할 인증 태그의 길이를 설정할 수 있으며 기본값은 16바이트입니다. `chacha20-poly1305`의 경우, `authTagLength` 옵션의 기본값은 16바이트입니다.

`algorithm`은 OpenSSL에 의존적이며, 예를 들어 `'aes192'` 등이 있습니다. 최신 OpenSSL 릴리스에서는 `openssl list -cipher-algorithms` 명령어를 사용하여 사용 가능한 암호 알고리즘을 확인할 수 있습니다.

`key`는 `algorithm`에서 사용하는 원시 키이고, `iv`는 [초기화 벡터](https://en.wikipedia.org/wiki/Initialization_vector)입니다. 두 인자는 모두 `'utf8'`로 인코딩된 문자열, [Buffer](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`여야 합니다. `key`는 선택적으로 `secret` 타입의 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)일 수 있습니다. 암호화에 초기화 벡터가 필요하지 않은 경우, `iv`는 `null`일 수 있습니다.

`key`나 `iv`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.

초기화 벡터는 예측 불가능하고 고유해야 합니다. 이상적으로는 암호학적으로 무작위여야 합니다. 하지만 비밀로 유지할 필요는 없습니다. IV는 일반적으로 암호화되지 않은 상태로 암호문 메시지에 추가됩니다. 무언가가 예측 불가능하고 고유해야 하지만 비밀로 유지할 필요는 없다는 것이 모순처럼 들릴 수 있지만, 공격자가 미리 주어진 IV를 예측할 수 없어야 한다는 점을 기억하세요.


#### `crypto.createDecipheriv(algorithm, key, iv[, options])`

-   `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
-   `iv` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
-   반환값: [`<Decipher>`](https://nodejs.org/docs/latest/api/crypto.html#class-decipher)

주어진 `algorithm`, `key`, 그리고 초기화 벡터(`iv`)를 사용하여 `Decipher` 객체를 생성하고 반환합니다.

`options` 인자는 스트림 동작을 제어하며, CCM 또는 OCB 모드(예: `'aes-128-ccm'`)에서 사용할 때는 필수입니다. 이 경우, `authTagLength` 옵션은 인증 태그의 길이를 바이트 단위로 지정해야 합니다. 자세한 내용은 [CCM 모드](https://nodejs.org/docs/latest/api/crypto.html#ccm-mode)를 참조하세요. AES-GCM과 `chacha20-poly1305`의 경우, `authTagLength` 옵션은 기본적으로 16바이트로 설정되며, 다른 길이를 사용할 때는 이 값을 변경해야 합니다.

`algorithm`은 OpenSSL에 의존적이며, 예를 들어 `'aes192'` 등이 있습니다. 최신 OpenSSL 버전에서는 `openssl list -cipher-algorithms` 명령어를 사용하여 사용 가능한 암호 알고리즘을 확인할 수 있습니다.

`key`는 `algorithm`에서 사용하는 원시 키이고, `iv`는 [초기화 벡터](https://en.wikipedia.org/wiki/Initialization_vector)입니다. 두 인자는 `'utf8'`로 인코딩된 문자열, [Buffer](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`여야 합니다. `key`는 선택적으로 `secret` 타입의 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)일 수 있습니다. 암호화에 초기화 벡터가 필요하지 않다면, `iv`는 `null`일 수 있습니다.

`key`나 `iv`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.

초기화 벡터는 예측 불가능하고 고유해야 합니다. 이상적으로는 암호학적으로 무작위여야 합니다. 하지만 비밀로 유지할 필요는 없습니다. IV는 일반적으로 암호화되지 않은 상태로 암호문 메시지에 추가됩니다. 예측 불가능하고 고유해야 하지만 비밀로 유지할 필요는 없다는 것이 모순적으로 들릴 수 있지만, 공격자가 미리 IV를 예측할 수 없어야 한다는 점을 기억하세요.


#### `crypto.createDiffieHellman(prime[, primeEncoding][, generator][, generatorEncoding])`

- `prime` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `primeEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `prime` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- `generator` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) **기본값:** `2`
- `generatorEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `generator` 문자열의 [인코딩](https://nodejs.org/docs/latest/api/buffer.html#buffers-and-character-encodings) 방식.
- 반환값: [`<DiffieHellman>`](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellman)

제공된 `prime`과 선택적으로 지정된 `generator`를 사용하여 `DiffieHellman` 키 교환 객체를 생성합니다.

`generator` 인자는 숫자, 문자열, 또는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)가 될 수 있습니다. `generator`가 지정되지 않으면 기본값 `2`가 사용됩니다.

`primeEncoding`이 지정된 경우, `prime`은 문자열로 예상됩니다. 그렇지 않으면 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.

`generatorEncoding`이 지정된 경우, `generator`는 문자열로 예상됩니다. 그렇지 않으면 숫자, [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html), `TypedArray`, 또는 `DataView`로 예상됩니다.


#### `crypto.createDiffieHellman(primeLength[, generator])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatediffiehellmanprimelength-generator)

추가된 버전: v0.5.0

-   `primeLength` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `generator` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `2`
-   반환값: [`<DiffieHellman>`](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellman)

`DiffieHellman` 키 교환 객체를 생성하고, 선택적으로 지정된 숫자 `generator`를 사용하여 `primeLength` 비트 길이의 소수를 생성합니다. `generator`가 지정되지 않으면 기본값 `2`가 사용됩니다.


#### `crypto.createDiffieHellmanGroup(name)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatediffiehellmangroupname)

추가된 버전: v0.9.3

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<DiffieHellmanGroup>`](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellmangroup)

[`crypto.getDiffieHellman()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetdiffiehellmangroupname)의 별칭입니다.


#### `crypto.createECDH(curveName)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateecdhcurvename)

추가된 버전: v0.11.14

-   `curveName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<ECDH>`](https://nodejs.org/docs/latest/api/crypto.html#class-ecdh)

`curveName` 문자열로 지정된 미리 정의된 곡선을 사용하여 타원 곡선 디피-헬만(`ECDH`) 키 교환 객체를 생성합니다. 사용 가능한 곡선 이름 목록을 얻으려면 [`crypto.getCurves()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetcurves)를 사용하세요. 최신 OpenSSL 버전에서는 `openssl ecparam -list_curves` 명령어를 통해 사용 가능한 각 타원 곡선의 이름과 설명을 확인할 수 있습니다.


#### `crypto.createHash(algorithm[, options])`

- `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
- 반환값: [`<Hash>`](https://nodejs.org/docs/latest/api/crypto.html#class-hash)

주어진 `algorithm`을 사용해 해시 다이제스트를 생성할 수 있는 `Hash` 객체를 만들고 반환합니다. 선택적 `options` 인자는 스트림 동작을 제어합니다. `'shake256'`과 같은 XOF 해시 함수의 경우, `outputLength` 옵션을 사용해 원하는 출력 길이를 바이트 단위로 지정할 수 있습니다.

`algorithm`은 플랫폼에 설치된 OpenSSL 버전에서 지원하는 알고리즘에 따라 달라집니다. 예를 들어 `'sha256'`, `'sha512'` 등이 있습니다. 최신 OpenSSL 릴리스에서는 `openssl list -digest-algorithms` 명령어를 실행해 사용 가능한 다이제스트 알고리즘을 확인할 수 있습니다.

예제: 파일의 sha256 해시 값 생성

```js
import { createReadStream } from 'node:fs';
import { argv } from 'node:process';
const { createHash } = await import('node:crypto');

const filename = argv[2];
const hash = createHash('sha256');
const input = createReadStream(filename);

input.on('readable', () => {
    // 해시 스트림에서 하나의 요소만 생성됩니다.
    const data = input.read();
    if (data) {
        hash.update(data);
    } else {
        console.log(`${hash.digest('hex')} ${filename}`);
    }
});
```


#### `crypto.createHmac(algorithm, key[, options])`

- `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.transform` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamtransformoptions)
  - `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `key`가 문자열일 때 사용할 인코딩 방식
- 반환값: [`<Hmac>`](https://nodejs.org/docs/latest/api/crypto.html#class-hmac)

주어진 `algorithm`과 `key`를 사용하여 `Hmac` 객체를 생성하고 반환합니다. 선택적 `options` 인자는 스트림 동작을 제어합니다.

`algorithm`은 플랫폼에 설치된 OpenSSL 버전에서 지원하는 알고리즘에 의존합니다. 예를 들어 `'sha256'`, `'sha512'` 등이 있습니다. 최신 OpenSSL 릴리스에서는 `openssl list -digest-algorithms` 명령어를 통해 사용 가능한 다이제스트 알고리즘을 확인할 수 있습니다.

`key`는 암호화 HMAC 해시를 생성하는 데 사용되는 HMAC 키입니다. 만약 `key`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)라면, 그 타입은 `secret`이어야 합니다. `key`가 문자열인 경우, [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려해야 합니다. `key`가 [`crypto.randomBytes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptorandombytessize-callback)나 [`crypto.generateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogeneratekeytype-options-callback)와 같은 암호학적으로 안전한 엔트로피 소스에서 얻어진 것이라면, 그 길이는 `algorithm`의 블록 크기(예: SHA-256의 경우 512비트)를 초과하지 않아야 합니다.

예제: 파일의 sha256 HMAC 생성

```js
import { createReadStream } from 'node:fs';
import { argv } from 'node:process';
const { createHmac } = await import('node:crypto');

const filename = argv[2];
const hmac = createHmac('sha256', 'a secret');
const input = createReadStream(filename);

input.on('readable', () => {
  // 해시 스트림에서 하나의 요소만 생성됩니다.
  const data = input.read();
  if (data) {
    hmac.update(data);
  } else {
    console.log(`${hmac.digest('hex')} ${filename}`);
  }
});
```


#### `crypto.createPrivateKey(key)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)

-   `key` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
    -   `key`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 키 자료로, PEM, DER, 또는 JWK 형식으로 제공된다.
    -   `format`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pem'`, `'der'`, 또는 `'jwk'` 중 하나여야 한다. **기본값:** `'pem'`.
    -   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pkcs1'`, `'pkcs8'`, 또는 `'sec1'` 중 하나여야 한다. 이 옵션은 `format`이 `'der'`일 때만 필수이며, 그 외에는 무시된다.
    -   `passphrase`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 복호화에 사용할 패스프레이즈.
    -   `encoding`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `key`가 문자열일 때 사용할 인코딩.
-   반환값: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

새로운 키 객체를 생성하고 반환한다. 이 객체는 개인 키를 포함한다. `key`가 문자열이나 `Buffer`라면, `format`은 `'pem'`으로 간주된다. 그렇지 않으면, `key`는 위에서 설명한 속성을 가진 객체여야 한다.

개인 키가 암호화된 경우, `passphrase`를 반드시 지정해야 한다. 패스프레이즈의 길이는 1024바이트로 제한된다.


#### `crypto.createPublicKey(key)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey)

-   `key` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
    -   `key`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 키 자료로, PEM, DER, 또는 JWK 형식으로 제공됩니다.
    -   `format`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pem'`, `'der'`, 또는 `'jwk'` 중 하나여야 합니다. **기본값:** `'pem'`.
    -   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'pkcs1'` 또는 `'spki'` 중 하나여야 합니다. 이 옵션은 `format`이 `'der'`일 때만 필요하며, 그 외의 경우에는 무시됩니다.
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `key`가 문자열일 때 사용할 인코딩입니다.
-   반환값: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

공개 키를 포함하는 새로운 키 객체를 생성하고 반환합니다. `key`가 문자열이나 `Buffer`라면 `format`은 `'pem'`으로 간주됩니다. `key`가 타입이 `'private'`인 `KeyObject`라면, 주어진 개인 키로부터 공개 키를 파생합니다. 그렇지 않다면, `key`는 위에서 설명한 속성을 가진 객체여야 합니다.

`format`이 `'pem'`이라면, `key`는 X.509 인증서일 수도 있습니다.

공개 키는 개인 키로부터 파생될 수 있기 때문에, 공개 키 대신 개인 키를 전달할 수도 있습니다. 이 경우, 이 함수는 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)가 호출된 것처럼 동작하지만, 반환된 `KeyObject`의 타입은 `'public'`이 되며, 반환된 `KeyObject`에서 개인 키를 추출할 수 없습니다. 마찬가지로, 타입이 `'private'`인 `KeyObject`가 주어지면, 타입이 `'public'`인 새로운 `KeyObject`가 반환되며, 반환된 객체에서 개인 키를 추출할 수 없습니다.


#### `crypto.createSecretKey(key[, encoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatesecretkeykey-encoding)

-   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `key`가 문자열일 때 사용할 문자열 인코딩.
-   반환값: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

대칭 암호화 또는 `Hmac`을 위한 비밀 키를 포함하는 새로운 키 객체를 생성하고 반환합니다.


#### `crypto.createSign(algorithm[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatesignalgorithm-options)

추가된 버전: v0.1.92

-   `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.Writable` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamwritableoptions)
-   반환값: [`<Sign>`](https://nodejs.org/docs/latest/api/crypto.html#class-sign)

주어진 `algorithm`을 사용하는 `Sign` 객체를 생성하고 반환합니다. 사용 가능한 다이제스트 알고리즘 이름을 얻으려면 [`crypto.getHashes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogethashes)를 사용하세요. 선택적 `options` 인자는 `stream.Writable`의 동작을 제어합니다.

일부 경우에는 다이제스트 알고리즘 대신 `'RSA-SHA256'`과 같은 서명 알고리즘 이름을 사용하여 `Sign` 인스턴스를 생성할 수 있습니다. 이 경우 해당 다이제스트 알고리즘이 사용됩니다. 하지만 `'ecdsa-with-SHA256'`과 같은 모든 서명 알고리즘에서 작동하지는 않으므로, 항상 다이제스트 알고리즘 이름을 사용하는 것이 좋습니다.


#### `crypto.createVerify(algorithm[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateverifyalgorithm-options)

추가된 버전: v0.1.92

-   `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`stream.Writable` 옵션](https://nodejs.org/docs/latest/api/stream.html#new-streamwritableoptions)
-   반환값: [`<Verify>`](https://nodejs.org/docs/latest/api/crypto.html#class-verify)

주어진 알고리즘을 사용하는 `Verify` 객체를 생성하고 반환합니다. 사용 가능한 서명 알고리즘의 이름 목록을 얻으려면 [`crypto.getHashes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogethashes)를 사용하세요. 선택적인 `options` 인자는 `stream.Writable`의 동작을 제어합니다.

일부 경우에는, `'RSA-SHA256'`과 같은 서명 알고리즘의 이름을 사용하여 `Verify` 인스턴스를 생성할 수 있습니다. 이 경우 해당하는 다이제스트 알고리즘이 사용됩니다. 하지만 `'ecdsa-with-SHA256'`과 같은 모든 서명 알고리즘에 대해 이 방법이 작동하지 않으므로, 항상 다이제스트 알고리즘 이름을 사용하는 것이 좋습니다.


#### `crypto.diffieHellman(options)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptodiffiehellmanoptions)

추가된 버전: v13.9.0, v12.17.0

-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `privateKey`: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)
    -   `publicKey`: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`privateKey`와 `publicKey`를 기반으로 Diffie-Hellman 비밀값을 계산합니다. 두 키는 동일한 `asymmetricKeyType`을 가져야 하며, 이 타입은 `'dh'`(Diffie-Hellman), `'ec'`, `'x448'`, 또는 `'x25519'`(ECDH) 중 하나여야 합니다.


#### `crypto.fips`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptofips)

추가된 버전: v6.0.0  
사용 중단된 버전: v10.0.0

이 속성은 현재 FIPS(Federal Information Processing Standards) 호환 암호화 프로바이더가 사용 중인지 확인하고 제어하는 데 사용됩니다. 이 값을 `true`로 설정하려면 Node.js의 FIPS 빌드가 필요합니다.

이 속성은 더 이상 사용되지 않습니다. 대신 `crypto.setFips()`와 `crypto.getFips()`를 사용하세요.


#### `crypto.generateKey(type, options, callback)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogeneratekeytype-options-callback)

-   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 생성할 비밀 키의 용도. 현재 허용되는 값은 `'hmac'`과 `'aes'`입니다.
-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `length`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 키의 비트 길이. 이 값은 0보다 커야 합니다.
        -   `type`이 `'hmac'`인 경우, 최소 길이는 8이고 최대 길이는 2<sup>31</sup>\-1입니다. 값이 8의 배수가 아니면 생성된 키는 `Math.floor(length / 8)`로 잘립니다.
        -   `type`이 `'aes'`인 경우, 길이는 `128`, `192`, 또는 `256` 중 하나여야 합니다.
-   `callback`: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err`: [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `key`: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

주어진 `length`로 새로운 랜덤 비밀 키를 비동기적으로 생성합니다. `type`은 `length`에 대해 어떤 유효성 검사를 수행할지 결정합니다.

```js
const { generateKey } = await import('node:crypto');
generateKey('hmac', { length: 512 }, (err, key) => {
    if (err) throw err;
    console.log(key.export().toString('hex')); // 46e..........620
});
```

생성된 HMAC 키의 크기는 기본 해시 함수의 블록 크기를 초과하지 않아야 합니다. 자세한 내용은 [`crypto.createHmac()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatehmacalgorithm-key-options)를 참고하세요.


#### `crypto.generateKeyPair(type, options, callback)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogeneratekeypairtype-options-callback)

-   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, 또는 `'dh'` 중 하나여야 합니다.
-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `modulusLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 비트 단위의 키 크기 (RSA, DSA).
    -   `publicExponent`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 공개 지수 (RSA). **기본값:** `0x10001`.
    -   `hashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 메시지 다이제스트 이름 (RSA-PSS).
    -   `mgf1HashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) MGF1에서 사용하는 메시지 다이제스트 이름 (RSA-PSS).
    -   `saltLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 최소 솔트 길이 (바이트 단위) (RSA-PSS).
    -   `divisorLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `q`의 크기 (비트 단위) (DSA).
    -   `namedCurve`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 곡선 이름 (EC).
    -   `prime`: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 소수 파라미터 (DH).
    -   `primeLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 소수 길이 (비트 단위) (DH).
    -   `generator`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 커스텀 생성자 (DH). **기본값:** `2`.
    -   `groupName`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Diffie-Hellman 그룹 이름 (DH). [`crypto.getDiffieHellman()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetdiffiehellmangroupname) 참조.
    -   `paramEncoding`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'named'` 또는 `'explicit'` 중 하나여야 합니다 (EC). **기본값:** `'named'`.
    -   `publicKeyEncoding`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions) 참조.
    -   `privateKeyEncoding`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions) 참조.
-   `callback`: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err`: [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `publicKey`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)
    -   `privateKey`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

주어진 `type`에 따라 새로운 비대칭 키 쌍을 생성합니다. 현재 RSA, RSA-PSS, DSA, EC, Ed25519, Ed448, X25519, X448, 그리고 DH가 지원됩니다.

`publicKeyEncoding` 또는 `privateKeyEncoding`이 지정된 경우, 이 함수는 결과에 대해 [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions)가 호출된 것처럼 동작합니다. 그렇지 않으면, 키의 해당 부분이 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)로 반환됩니다.

장기 저장을 위해 공개 키는 `'spki'`로, 개인 키는 암호화된 `'pkcs8'`로 인코딩하는 것을 권장합니다:

```js
const { generateKeyPair } = await import('node:crypto');
generateKeyPair('rsa', {
    modulusLength: 4096,
    publicKeyEncoding: {
        type: 'spki',
        format: 'pem',
    },
    privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem',
        cipher: 'aes-256-cbc',
        passphrase: 'top secret',
    },
}, (err, publicKey, privateKey) => {
    // 에러 처리 및 생성된 키 쌍 사용
});
```

완료되면, `callback`이 호출되며 `err`은 `undefined`로 설정되고, `publicKey`와 `privateKey`는 생성된 키 쌍을 나타냅니다.

이 메서드가 [`util.promisify()`](https://nodejs.org/docs/latest/api/util.html#utilpromisifyoriginal)된 버전으로 호출되면, `publicKey`와 `privateKey` 속성을 가진 `Object`에 대한 `Promise`를 반환합니다.


#### `crypto.generateKeyPairSync(type, options)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogeneratekeypairsynctype-options)

-   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'rsa'`, `'rsa-pss'`, `'dsa'`, `'ec'`, `'ed25519'`, `'ed448'`, `'x25519'`, `'x448'`, `'dh'` 중 하나여야 합니다.
-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `modulusLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 비트 단위의 키 크기 (RSA, DSA).
    -   `publicExponent`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 공개 지수 (RSA). **기본값:** `0x10001`.
    -   `hashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 메시지 다이제스트 이름 (RSA-PSS).
    -   `mgf1HashAlgorithm`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) MGF1에서 사용하는 메시지 다이제스트 이름 (RSA-PSS).
    -   `saltLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 최소 솔트 길이 (바이트 단위) (RSA-PSS).
    -   `divisorLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `q`의 크기 (비트 단위) (DSA).
    -   `namedCurve`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 곡선 이름 (EC).
    -   `prime`: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 소수 파라미터 (DH).
    -   `primeLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 소수 길이 (비트 단위) (DH).
    -   `generator`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 커스텀 생성자 (DH). **기본값:** `2`.
    -   `groupName`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Diffie-Hellman 그룹 이름 (DH). [`crypto.getDiffieHellman()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetdiffiehellmangroupname) 참조.
    -   `paramEncoding`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `'named'` 또는 `'explicit'` (EC). **기본값:** `'named'`.
    -   `publicKeyEncoding`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions) 참조.
    -   `privateKeyEncoding`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions) 참조.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `publicKey`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)
    -   `privateKey`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

주어진 `type`에 따라 새로운 비대칭 키 쌍을 생성합니다. 현재 RSA, RSA-PSS, DSA, EC, Ed25519, Ed448, X25519, X448, DH가 지원됩니다.

`publicKeyEncoding` 또는 `privateKeyEncoding`이 지정된 경우, 이 함수는 [`keyObject.export()`](https://nodejs.org/docs/latest/api/crypto.html#keyobjectexportoptions)가 결과에 대해 호출된 것처럼 동작합니다. 그렇지 않으면, 키의 해당 부분이 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)로 반환됩니다.

공개 키를 인코딩할 때는 `'spki'`를 사용하는 것이 좋습니다. 개인 키를 인코딩할 때는 강력한 암호와 함께 `'pkcs8'`을 사용하고, 암호를 비밀로 유지하는 것이 좋습니다.

```js
const { generateKeyPairSync } = await import('node:crypto');
const { publicKey, privateKey } = generateKeyPairSync('rsa', {
    modulusLength: 4096,
    publicKeyEncoding: {
        type: 'spki',
        format: 'pem',
    },
    privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem',
        cipher: 'aes-256-cbc',
        passphrase: 'top secret',
    },
});
```

반환값 `{ publicKey, privateKey }`는 생성된 키 쌍을 나타냅니다. PEM 인코딩이 선택된 경우, 해당 키는 문자열로 반환됩니다. 그렇지 않으면 DER로 인코딩된 데이터를 포함하는 버퍼가 반환됩니다.


#### `crypto.generateKeySync(type, options)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogeneratekeysynctype-options)

추가된 버전: v15.0.0

-   `type`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 생성할 비밀 키의 용도. 현재 허용되는 값은 `'hmac'`과 `'aes'`입니다.
-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `length`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 키의 비트 길이.
        -   `type`이 `'hmac'`인 경우, 최소값은 8이고 최대값은 2<sup>31</sup>\-1입니다. 값이 8의 배수가 아니면 생성된 키는 `Math.floor(length / 8)`로 잘립니다.
        -   `type`이 `'aes'`인 경우, 길이는 `128`, `192`, 또는 `256` 중 하나여야 합니다.
-   반환값: [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)

주어진 `length`로 새로운 랜덤 비밀 키를 동기적으로 생성합니다. `type`은 `length`에 대해 어떤 유효성 검사를 수행할지 결정합니다.

```js
const { generateKeySync } = await import('node:crypto');
const key = generateKeySync('hmac', { length: 512 });
console.log(key.export().toString('hex')); // e89..........41e
```

생성된 HMAC 키의 크기는 기본 해시 함수의 블록 크기를 초과하지 않아야 합니다. 자세한 내용은 [`crypto.createHmac()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatehmacalgorithm-key-options)을 참고하세요.


#### `crypto.generatePrime(size[, options[, callback]])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogenerateprimesize-options-callback)

-   `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 소수의 크기(비트 단위)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `add` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
    -   `rem` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
    -   `safe` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`
    -   `bigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면 생성된 소수가 `bigint`로 반환됨
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `prime` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

`size` 비트 크기의 의사 난수 소수를 생성한다.

`options.safe`가 `true`로 설정되면, 소수는 안전한 소수(safe prime)가 된다. 즉, `(prime - 1) / 2`도 소수가 된다.

`options.add`와 `options.rem` 매개변수를 사용하여 추가 요구사항을 적용할 수 있다. 예를 들어, Diffie-Hellman 알고리즘에서 사용할 수 있다:

-   `options.add`와 `options.rem`이 모두 설정되면, 소수는 `prime % add = rem` 조건을 만족한다.
-   `options.add`만 설정되고 `options.safe`가 `true`가 아니면, 소수는 `prime % add = 1` 조건을 만족한다.
-   `options.add`만 설정되고 `options.safe`가 `true`로 설정되면, 소수는 `prime % add = 3` 조건을 만족한다. 이는 `options.add > 2`일 때 `prime % add = 1`이 `options.safe`에 의해 강제된 조건과 모순되기 때문이다.
-   `options.add`가 주어지지 않으면 `options.rem`은 무시된다.

`options.add`와 `options.rem`은 `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, 또는 `DataView`로 주어질 경우 빅엔디안(big-endian) 시퀀스로 인코딩되어야 한다.

기본적으로 소수는 빅엔디안 옥텟 시퀀스로 [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)에 인코딩된다. `bigint` 옵션이 `true`로 설정되면 [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)가 제공된다.


#### `crypto.generatePrimeSync(size[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogenerateprimesyncsize-options)

추가된 버전: v15.8.0

-   `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 소수의 크기(비트 단위).
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `add` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
    -   `rem` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
    -   `safe` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`.
    -   `bigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면 생성된 소수가 `bigint`로 반환됨.
-   반환값: [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

`size` 비트 크기의 의사 난수 소수를 생성한다.

`options.safe`가 `true`로 설정되면, 소수는 안전한 소수가 된다. 즉, `(prime - 1) / 2`도 소수가 된다.

`options.add`와 `options.rem` 매개변수를 사용하여 추가 요구사항을 강제할 수 있다. 예를 들어, Diffie-Hellman 알고리즘에서:

-   `options.add`와 `options.rem`이 모두 설정되면, 소수는 `prime % add = rem` 조건을 만족한다.
-   `options.add`만 설정되고 `options.safe`가 `true`가 아니면, 소수는 `prime % add = 1` 조건을 만족한다.
-   `options.add`만 설정되고 `options.safe`가 `true`로 설정되면, 소수는 `prime % add = 3` 조건을 만족한다. 이는 `options.add > 2`일 때 `prime % add = 1`이 `options.safe`에 의해 강제된 조건과 모순되기 때문이다.
-   `options.add`가 주어지지 않으면 `options.rem`은 무시된다.

`options.add`와 `options.rem`은 `ArrayBuffer`, `SharedArrayBuffer`, `TypedArray`, `Buffer`, 또는 `DataView`로 주어질 경우 빅엔디안(big-endian) 시퀀스로 인코딩되어야 한다.

기본적으로 소수는 빅엔디안 옥텟 시퀀스로 [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)에 인코딩된다. `bigint` 옵션이 `true`로 설정되면 [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)가 제공된다.


#### `crypto.getCipherInfo(nameOrNid[, options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetcipherinfonameornid-options)

추가된 버전: v15.0.0

-   `nameOrNid`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    조회할 암호화 알고리즘의 이름 또는 NID(숫자 식별자).
-   `options`: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
    -   `keyLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        테스트할 키 길이.
    -   `ivLength`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        테스트할 초기화 벡터(IV) 길이.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
    -   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
        암호화 알고리즘의 이름.
    -   `nid` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        암호화 알고리즘의 NID(숫자 식별자).
    -   `blockSize` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        암호화 알고리즘의 블록 크기(바이트 단위). `mode`가 `'stream'`인 경우 이 속성은 생략됨.
    -   `ivLength` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        예상되거나 기본 초기화 벡터(IV) 길이(바이트 단위). 암호화 알고리즘이 초기화 벡터를 사용하지 않는 경우 이 속성은 생략됨.
    -   `keyLength` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        예상되거나 기본 키 길이(바이트 단위).
    -   `mode` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
        암호화 모드. 가능한 값: `'cbc'`, `'ccm'`, `'cfb'`, `'ctr'`, `'ecb'`, `'gcm'`, `'ocb'`, `'ofb'`, `'stream'`, `'wrap'`, `'xts'`.

주어진 암호화 알고리즘에 대한 정보를 반환합니다.

일부 암호화 알고리즘은 가변 길이의 키와 초기화 벡터를 허용합니다. 기본적으로 `crypto.getCipherInfo()` 메서드는 이러한 암호화 알고리즘의 기본값을 반환합니다. 특정 키 길이나 초기화 벡터 길이가 해당 암호화 알고리즘에 적합한지 테스트하려면 `keyLength`와 `ivLength` 옵션을 사용하세요. 주어진 값이 허용되지 않으면 `undefined`가 반환됩니다.


#### `crypto.getCiphers()`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetciphers)

추가된 버전: v0.9.3

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지원되는 암호화 알고리즘 이름을 담은 배열.

```js
const { getCiphers } = await import('node:crypto');
console.log(getCiphers()); // ['aes-128-cbc', 'aes-128-ccm', ...]
```


#### `crypto.getCurves()`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetcurves)

추가된 버전: v2.3.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지원되는 타원 곡선 이름들의 배열.

```js
const { getCurves } = await import('node:crypto');
console.log(getCurves()); // ['Oakley-EC2N-3', 'Oakley-EC2N-4', ...]
```


#### `crypto.getDiffieHellman(groupName)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetdiffiehellmangroupname)

추가된 버전: v0.7.5

-   `groupName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<DiffieHellmanGroup>`](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellmangroup)

미리 정의된 `DiffieHellmanGroup` 키 교환 객체를 생성합니다. 지원되는 그룹은 [`DiffieHellmanGroup`](https://nodejs.org/docs/latest/api/crypto.html#class-diffiehellmangroup) 문서에 나열되어 있습니다.

이 메서드가 반환하는 객체는 [`crypto.createDiffieHellman()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatediffiehellmanprime-primeencoding-generator-generatorencoding)로 생성된 객체와 유사한 인터페이스를 가지지만, 키를 변경할 수는 없습니다 (예: [`diffieHellman.setPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#diffiehellmansetpublickeypublickey-encoding)). 이 메서드를 사용하면 각 당사자가 그룹 모듈러스를 미리 생성하거나 교환할 필요가 없어 프로세서와 통신 시간을 절약할 수 있습니다.

예제 (공유 비밀키 얻기):

```js
const { getDiffieHellman } = await import('node:crypto');
const alice = getDiffieHellman('modp14');
const bob = getDiffieHellman('modp14');

alice.generateKeys();
bob.generateKeys();

const aliceSecret = alice.computeSecret(bob.getPublicKey(), null, 'hex');
const bobSecret = bob.computeSecret(alice.getPublicKey(), null, 'hex');

/* aliceSecret과 bobSecret은 동일해야 합니다 */
console.log(aliceSecret === bobSecret);
```


#### `crypto.getFips()`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetfips)

추가된 버전: v10.0.0

-   반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    현재 FIPS 호환 암호화 프로바이더가 사용 중이라면 `1`을 반환하고, 그렇지 않으면 `0`을 반환합니다. 향후 주요 버전 업데이트에서 이 API의 반환 타입이 [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)으로 변경될 수 있습니다.


#### `crypto.getHashes()`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogethashes)

추가된 버전: v0.9.3

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 지원되는 해시 알고리즘 이름들의 배열을 반환합니다. 예를 들어 `'RSA-SHA256'`과 같은 값이 포함됩니다. 해시 알고리즘은 "다이제스트" 알고리즘이라고도 불립니다.

```js
const { getHashes } = await import('node:crypto');
console.log(getHashes()); // ['DSA', 'DSA-SHA', 'DSA-SHA1', ...]
```


#### `crypto.getRandomValues(typedArray)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptogetrandomvaluestypedarray)

추가된 버전: v17.4.0

-   `typedArray` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) `typedArray`를 반환합니다.

[`crypto.webcrypto.getRandomValues()`](https://nodejs.org/docs/latest/api/webcrypto.html#cryptogetrandomvaluestypedarray)의 간편한 별칭입니다. 이 구현은 Web Crypto 사양과 호환되지 않으므로, 웹 호환 코드를 작성하려면 [`crypto.webcrypto.getRandomValues()`](https://nodejs.org/docs/latest/api/webcrypto.html#cryptogetrandomvaluestypedarray)를 대신 사용해야 합니다.


#### `crypto.hash(algorithm, data[, outputEncoding])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptohashalgorithm-data-outputencoding)

추가된 버전: v21.7.0, v20.12.0

-   `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)
-   `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
    `data`가 문자열인 경우, 해시하기 전에 UTF-8로 인코딩됩니다. 문자열 입력에 다른 인코딩을 사용하려면, `TextEncoder`나 `Buffer.from()`을 사용해 문자열을 `TypedArray`로 인코딩한 후 이 API에 전달하면 됩니다.
-   `outputEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
    반환된 다이제스트를 인코딩하는 데 사용되는 인코딩입니다. **기본값:** `'hex'`.
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 함수는 데이터의 일회성 해시 다이제스트를 생성하는 유틸리티입니다. 작은 양의 데이터(<= 5MB)를 해시할 때, 객체 기반의 `crypto.createHash()`보다 더 빠를 수 있습니다. 데이터가 크거나 스트리밍되는 경우에는 여전히 `crypto.createHash()`를 사용하는 것이 권장됩니다.

`algorithm`은 플랫폼에 설치된 OpenSSL 버전에서 지원하는 알고리즘에 따라 달라집니다. 예를 들어 `'sha256'`, `'sha512'` 등이 있습니다. 최신 OpenSSL 릴리스에서는 `openssl list -digest-algorithms` 명령어를 사용해 사용 가능한 다이제스트 알고리즘을 확인할 수 있습니다.

예제:

```js
import crypto from 'node:crypto';
import { Buffer } from 'node:buffer';

// 문자열을 해시하고 결과를 16진수 문자열로 반환
const string = 'Node.js';
console.log(crypto.hash('sha1', string)); // 10b3493287f831e81a438811a1ffba01f8cec4b7

// base64로 인코딩된 문자열을 Buffer로 변환한 후 해시하고 결과를 Buffer로 반환
const base64 = 'Tm9kZS5qcw==';
console.log(crypto.hash('sha1', Buffer.from(base64, 'base64'), 'buffer'));
```


#### `crypto.hkdf(digest, ikm, salt, info, keylen, callback)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptohkdfdigest-ikm-salt-info-keylen-callback)

-   `digest` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 해시 알고리즘.
-   `ikm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) 입력 키 자료. 필수값이지만 길이가 0일 수 있음.
-   `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 솔트 값. 필수값이지만 길이가 0일 수 있음.
-   `info` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 추가 정보 값. 필수값이지만 길이가 0일 수 있으며, 1024바이트를 초과할 수 없음.
-   `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 키의 길이. 0보다 커야 함. 최대 허용값은 선택한 해시 함수가 생성하는 바이트 수의 255배 (예: `sha512`는 64바이트 해시를 생성하므로 HKDF 출력의 최대값은 16320바이트).
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `derivedKey` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)

HKDF는 RFC 5869에 정의된 간단한 키 유도 함수입니다. 주어진 `ikm`, `salt`, `info`는 `digest`와 함께 사용되어 `keylen` 바이트의 키를 생성합니다.

제공된 `callback` 함수는 두 개의 인자 `err`와 `derivedKey`와 함께 호출됩니다. 키를 생성하는 동안 오류가 발생하면 `err`가 설정되고, 그렇지 않으면 `err`는 `null`이 됩니다. 성공적으로 생성된 `derivedKey`는 [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 형태로 콜백에 전달됩니다. 입력 인자 중 유효하지 않은 값이나 타입이 지정되면 오류가 발생합니다.

```js
import { Buffer } from 'node:buffer';
const { hkdf } = await import('node:crypto');

hkdf('sha512', 'key', 'salt', 'info', 64, (err, derivedKey) => {
    if (err) throw err;
    console.log(Buffer.from(derivedKey).toString('hex')); // '24156e2...5391653'
});
```


#### `crypto.hkdfSync(digest, ikm, salt, info, keylen)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptohkdfsyncdigest-ikm-salt-info-keylen)

-   `digest` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 해시 알고리즘.
-   `ikm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) 입력 키 자료. 반드시 제공해야 하지만 길이가 0일 수 있음.
-   `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 솔트 값. 반드시 제공해야 하지만 길이가 0일 수 있음.
-   `info` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 추가 정보 값. 반드시 제공해야 하지만 길이가 0일 수 있으며, 1024바이트를 초과할 수 없음.
-   `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성할 키의 길이. 0보다 커야 함. 허용되는 최대 값은 선택한 해시 함수가 생성하는 바이트 수의 255배 (예: `sha512`는 64바이트 해시를 생성하므로 HKDF 출력의 최대 크기는 16320바이트).
-   반환값: [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)

RFC 5869에 정의된 동기식 HKDF 키 유도 함수를 제공한다. 주어진 `ikm`, `salt`, `info`는 `digest`와 함께 사용되어 `keylen` 바이트의 키를 생성한다.

성공적으로 생성된 `derivedKey`는 [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)로 반환된다.

입력 인자가 유효하지 않은 값이나 타입을 지정하거나, 키를 생성할 수 없는 경우 에러가 발생한다.

```js
import { Buffer } from 'node:buffer';
const { hkdfSync } = await import('node:crypto');

const derivedKey = hkdfSync('sha512', 'key', 'salt', 'info', 64);
console.log(Buffer.from(derivedKey).toString('hex')); // '24156e2...5391653'
```


#### `crypto.pbkdf2(password, salt, iterations, keylen, digest, callback)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2password-salt-iterations-keylen-digest-callback)

-   `password` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `iterations` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `digest` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `derivedKey` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 함수는 비동기적으로 PBKDF2(Password-Based Key Derivation Function 2)를 구현합니다. 선택된 HMAC 다이제스트 알고리즘(`digest`)을 사용하여 `password`, `salt`, `iterations`로부터 요청된 바이트 길이(`keylen`)의 키를 생성합니다.

제공된 `callback` 함수는 두 개의 인자(`err`, `derivedKey`)와 함께 호출됩니다. 키를 생성하는 동안 오류가 발생하면 `err`이 설정되고, 그렇지 않으면 `err`은 `null`이 됩니다. 성공적으로 생성된 `derivedKey`는 기본적으로 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) 형태로 콜백에 전달됩니다. 입력 인자가 유효하지 않은 값이나 타입을 지정하면 오류가 발생합니다.

`iterations` 인자는 가능한 한 높은 숫자로 설정해야 합니다. 반복 횟수가 많을수록 생성된 키는 더 안전해지지만, 완료하는 데 더 많은 시간이 소요됩니다.

`salt`는 가능한 한 고유해야 합니다. 랜덤하고 최소 16바이트 길이의 salt를 사용하는 것이 권장됩니다. 자세한 내용은 [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)를 참고하세요.

`password`나 `salt`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려해야 합니다.

```javascript
const { pbkdf2 } = await import('node:crypto');
pbkdf2('secret', 'salt', 100000, 64, 'sha512', (err, derivedKey) => {
    if (err) throw err;
    console.log(derivedKey.toString('hex')); // '3745e48...08d59ae'
});
```

지원되는 다이제스트 함수 목록은 [`crypto.getHashes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogethashes)를 사용하여 확인할 수 있습니다.

이 API는 libuv의 스레드 풀을 사용하며, 일부 애플리케이션에서는 예상치 못한 성능 문제를 일으킬 수 있습니다. 자세한 내용은 [`UV_THREADPOOL_SIZE`](https://nodejs.org/docs/latest/api/cli.html#uv_threadpool_sizesize) 문서를 참고하세요.


#### `crypto.pbkdf2Sync(password, salt, iterations, keylen, digest)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptopbkdf2syncpassword-salt-iterations-keylen-digest)

-   `password` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `iterations` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `digest` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   Returns: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 함수는 동기적으로 PBKDF2(Password-Based Key Derivation Function 2)를 구현합니다. `digest`로 지정된 HMAC 다이제스트 알고리즘을 사용하여 `password`, `salt`, `iterations`로부터 요청된 바이트 길이(`keylen`)의 키를 생성합니다.

에러가 발생하면 `Error`가 발생하고, 그렇지 않으면 생성된 키가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)로 반환됩니다.

`iterations` 인자는 가능한 한 높은 숫자로 설정해야 합니다. 반복 횟수가 많을수록 생성된 키는 더 안전해지지만, 완료하는 데 더 많은 시간이 소요됩니다.

`salt`는 가능한 한 고유해야 합니다. 랜덤하고 최소 16바이트 길이의 salt를 사용하는 것이 권장됩니다. 자세한 내용은 [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)를 참고하세요.

`password`나 `salt`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려해야 합니다.

```js
const { pbkdf2Sync } = await import('node:crypto');
const key = pbkdf2Sync('secret', 'salt', 100000, 64, 'sha512');
console.log(key.toString('hex')); // '3745e48...08d59ae'
```

지원되는 다이제스트 함수 목록은 [`crypto.getHashes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogethashes)를 사용하여 확인할 수 있습니다.


#### `crypto.privateDecrypt(privateKey, buffer)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptoprivatedecryptprivatekey-buffer)

-   `privateKey` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
    -   `oaepHash` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) OAEP 패딩과 MGF1에 사용할 해시 함수. **기본값:** `'sha1'`
    -   `oaepLabel` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) OAEP 패딩에 사용할 레이블. 지정하지 않으면 레이블을 사용하지 않음.
    -   `padding` [`<crypto.constants>`](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants) `crypto.constants`에 정의된 선택적 패딩 값. 가능한 값: `crypto.constants.RSA_NO_PADDING`, `crypto.constants.RSA_PKCS1_PADDING`, 또는 `crypto.constants.RSA_PKCS1_OAEP_PADDING`.
-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 복호화된 내용을 담은 새로운 `Buffer`.

`privateKey`를 사용해 `buffer`를 복호화합니다. `buffer`는 이전에 해당 공개 키를 사용해 암호화된 데이터입니다. 예를 들어 [`crypto.publicEncrypt()`](https://nodejs.org/docs/latest/api/crypto.html#cryptopublicencryptkey-buffer)를 사용해 암호화할 수 있습니다.

`privateKey`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `privateKey`가 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)에 전달된 것처럼 동작합니다. 객체인 경우 `padding` 속성을 전달할 수 있습니다. 그렇지 않으면 이 함수는 `RSA_PKCS1_OAEP_PADDING`을 사용합니다.

[`crypto.privateDecrypt()`](https://nodejs.org/docs/latest/api/crypto.html#cryptoprivatedecryptprivatekey-buffer)에서 `crypto.constants.RSA_PKCS1_PADDING`을 사용하려면 OpenSSL이 암묵적 거부(`rsa_pkcs1_implicit_rejection`)를 지원해야 합니다. Node.js가 사용하는 OpenSSL 버전이 이 기능을 지원하지 않으면 `RSA_PKCS1_PADDING` 사용 시 실패합니다.


#### `crypto.privateEncrypt(privateKey, buffer)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptoprivateencryptprivatekey-buffer)

-   `privateKey` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
    -   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey) PEM 형식으로 인코딩된 개인 키.
    -   `passphrase` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 개인 키에 사용할 선택적 암호.
    -   `padding` [`<crypto.constants>`](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants) `crypto.constants`에 정의된 선택적 패딩 값. 가능한 값은 `crypto.constants.RSA_NO_PADDING` 또는 `crypto.constants.RSA_PKCS1_PADDING`이다.
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`, `key`, 또는 `passphrase`가 문자열일 때 사용할 인코딩.
-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 암호화된 내용을 담은 새로운 `Buffer`.

`buffer`를 `privateKey`로 암호화한다. 반환된 데이터는 해당 공개 키를 사용하여 복호화할 수 있다. 예를 들어 [`crypto.publicDecrypt()`](https://nodejs.org/docs/latest/api/crypto.html#cryptopublicdecryptkey-buffer)를 사용할 수 있다.

`privateKey`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `privateKey`가 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)에 전달된 것처럼 동작한다. 객체인 경우 `padding` 속성을 전달할 수 있다. 그렇지 않으면 이 함수는 `RSA_PKCS1_PADDING`을 사용한다.


#### `crypto.publicDecrypt(key, buffer)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptopublicdecryptkey-buffer)

-   `key` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
    -   `passphrase` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 개인 키에 대한 선택적 암호.
    -   `padding` [`<crypto.constants>`](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants) `crypto.constants`에 정의된 선택적 패딩 값. 가능한 값은 `crypto.constants.RSA_NO_PADDING` 또는 `crypto.constants.RSA_PKCS1_PADDING`입니다.
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`, `key`, 또는 `passphrase`가 문자열일 때 사용할 인코딩.
-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 복호화된 내용을 담은 새로운 `Buffer`.

`key`를 사용하여 `buffer`를 복호화합니다. `buffer`는 이전에 해당 개인 키를 사용하여 암호화된 데이터입니다. 예를 들어 [`crypto.privateEncrypt()`](https://nodejs.org/docs/latest/api/crypto.html#cryptoprivateencryptprivatekey-buffer)를 사용하여 암호화되었을 수 있습니다.

`key`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `key`가 [`crypto.createPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey)에 전달된 것처럼 동작합니다. 만약 객체라면 `padding` 속성을 전달할 수 있습니다. 그렇지 않으면 이 함수는 `RSA_PKCS1_PADDING`을 사용합니다.

RSA 공개 키는 개인 키에서 파생될 수 있으므로, 공개 키 대신 개인 키를 전달할 수도 있습니다.


#### `crypto.publicEncrypt(key, buffer)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptopublicencryptkey-buffer)

-   `key` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
    -   `key` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey) PEM 형식으로 인코딩된 공개 키 또는 개인 키, [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject), 또는 [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey).
    -   `oaepHash` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) OAEP 패딩과 MGF1에 사용할 해시 함수. **기본값:** `'sha1'`
    -   `oaepLabel` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) OAEP 패딩에 사용할 레이블. 지정하지 않으면 레이블을 사용하지 않음.
    -   `passphrase` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 개인 키에 대한 선택적 암호.
    -   `padding` [`<crypto.constants>`](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants) `crypto.constants`에 정의된 선택적 패딩 값. 가능한 값: `crypto.constants.RSA_NO_PADDING`, `crypto.constants.RSA_PKCS1_PADDING`, 또는 `crypto.constants.RSA_PKCS1_OAEP_PADDING`.
    -   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buffer`, `key`, `oaepLabel`, 또는 `passphrase`가 문자열일 때 사용할 문자열 인코딩.
-   `buffer` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 암호화된 내용을 담은 새로운 `Buffer`.

`buffer`의 내용을 `key`로 암호화하고 암호화된 내용을 담은 새로운 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)를 반환합니다. 반환된 데이터는 해당 개인 키를 사용하여 복호화할 수 있습니다. 예를 들어 [`crypto.privateDecrypt()`](https://nodejs.org/docs/latest/api/crypto.html#cryptoprivatedecryptprivatekey-buffer)를 사용할 수 있습니다.

`key`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `key`가 [`crypto.createPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey)에 전달된 것처럼 동작합니다. 객체인 경우 `padding` 속성을 전달할 수 있습니다. 그렇지 않으면 이 함수는 `RSA_PKCS1_OAEP_PADDING`을 사용합니다.

RSA 공개 키는 개인 키에서 파생될 수 있으므로, 공개 키 대신 개인 키를 전달할 수도 있습니다.


#### `crypto.randomBytes(size[, callback])`

- `size` [`<number>`] 생성할 바이트 수. `size`는 `2**31 - 1`보다 크지 않아야 한다.
- `callback` [`<Function>`]
  - `err` [`<Error>`]
  - `buf` [`<Buffer>`]
- 반환값: [`<Buffer>`] `callback` 함수가 제공되지 않으면 반환된다.

암호학적으로 강력한 의사 난수 데이터를 생성한다. `size` 인자는 생성할 바이트 수를 나타내는 숫자다.

`callback` 함수가 제공되면, 바이트는 비동기적으로 생성되고 `callback` 함수는 `err`와 `buf` 두 인자와 함께 호출된다. 오류가 발생하면 `err`는 `Error` 객체가 되고, 그렇지 않으면 `null`이 된다. `buf` 인자는 생성된 바이트를 포함하는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)다.

```javascript
// 비동기 방식
const { randomBytes } = await import('node:crypto');
randomBytes(256, (err, buf) => {
  if (err) throw err;
  console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
});
```

`callback` 함수가 제공되지 않으면, 랜덤 바이트는 동기적으로 생성되고 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)로 반환된다. 바이트 생성 중 문제가 발생하면 오류가 발생한다.

```javascript
// 동기 방식
const { randomBytes } = await import('node:crypto');
const buf = randomBytes(256);
console.log(`${buf.length} bytes of random data: ${buf.toString('hex')}`);
```

`crypto.randomBytes()` 메서드는 충분한 엔트로피가 있을 때까지 완료되지 않는다. 일반적으로 이 작업은 몇 밀리초 이상 걸리지 않는다. 랜덤 바이트 생성이 더 오래 걸릴 수 있는 유일한 경우는 시스템 부팅 직후, 전체 시스템이 여전히 엔트로피가 부족할 때다.

이 API는 libuv의 스레드 풀을 사용하며, 일부 애플리케이션에서는 예상치 못한 성능 저하를 초래할 수 있다. 자세한 내용은 [`UV_THREADPOOL_SIZE`](https://nodejs.org/docs/latest/api/cli.html#uv_threadpool_sizesize) 문서를 참고한다.

`crypto.randomBytes()`의 비동기 버전은 단일 스레드 풀 요청에서 실행된다. 스레드 풀 작업 길이 변동을 최소화하려면 클라이언트 요청을 처리하는 과정에서 큰 `randomBytes` 요청을 분할하는 것이 좋다.


#### `crypto.randomFill(buffer[, offset][, size], callback)`

- `buffer` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
  반드시 제공되어야 합니다. 제공된 `buffer`의 크기는 `2**31 - 1`을 초과할 수 없습니다.

- `offset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  **기본값:** `0`

- `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  **기본값:** `buffer.length - offset`. `size`는 `2**31 - 1`을 초과할 수 없습니다.

- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
  `function(err, buf) {}`

이 함수는 [`crypto.randomBytes()`](https://nodejs.org/docs/latest/api/crypto.html#cryptorandombytessize-callback)와 유사하지만, 첫 번째 인자로 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)를 받아 채워야 합니다. 또한 콜백 함수를 반드시 전달해야 합니다.

만약 `callback` 함수가 제공되지 않으면, 에러가 발생합니다.

```javascript
import { Buffer } from 'node:buffer';
const { randomFill } = await import('node:crypto');

const buf = Buffer.alloc(10);
randomFill(buf, (err, buf) => {
    if (err) throw err;
    console.log(buf.toString('hex'));
});

randomFill(buf, 5, (err, buf) => {
    if (err) throw err;
    console.log(buf.toString('hex'));
});

// 위 코드는 아래와 동일합니다.
randomFill(buf, 5, 5, (err, buf) => {
    if (err) throw err;
    console.log(buf.toString('hex'));
});
```

`ArrayBuffer`, `TypedArray`, 또는 `DataView` 인스턴스를 `buffer`로 전달할 수 있습니다.

`Float32Array`와 `Float64Array` 인스턴스도 포함되지만, 이 함수는 랜덤 부동소수점 숫자를 생성하는 데 사용하면 안 됩니다. 결과에 `+Infinity`, `-Infinity`, `NaN`이 포함될 수 있으며, 배열이 유한한 숫자만 포함하더라도 균일한 랜덤 분포에서 추출되지 않으며 의미 있는 하한 또는 상한이 없습니다.

```javascript
import { Buffer } from 'node:buffer';
const { randomFill } = await import('node:crypto');

const a = new Uint32Array(10);
randomFill(a, (err, buf) => {
    if (err) throw err;
    console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString('hex'));
});

const b = new DataView(new ArrayBuffer(10));
randomFill(b, (err, buf) => {
    if (err) throw err;
    console.log(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength).toString('hex'));
});

const c = new ArrayBuffer(10);
randomFill(c, (err, buf) => {
    if (err) throw err;
    console.log(Buffer.from(buf).toString('hex'));
});
```

이 API는 libuv의 스레드풀을 사용하며, 일부 애플리케이션에서 예상치 못한 성능 저하를 초래할 수 있습니다. 자세한 내용은 [`UV_THREADPOOL_SIZE`](https://nodejs.org/docs/latest/api/cli.html#uv_threadpool_sizesize) 문서를 참고하세요.

`crypto.randomFill()`의 비동기 버전은 단일 스레드풀 요청으로 실행됩니다. 스레드풀 작업 길이 변동을 최소화하려면 클라이언트 요청을 처리하는 과정에서 큰 `randomFill` 요청을 분할하세요.


#### `crypto.randomFillSync(buffer[, offset][, size])`

- `buffer` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
  반드시 제공되어야 합니다. 제공된 `buffer`의 크기는 `2**31 - 1`을 초과할 수 없습니다.

- `offset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  **기본값:** `0`

- `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  **기본값:** `buffer.length - offset`. `size`는 `2**31 - 1`을 초과할 수 없습니다.

- 반환값: [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
  `buffer` 인자로 전달된 객체를 반환합니다.

이 함수는 [`crypto.randomFill()`](https://nodejs.org/docs/latest/api/crypto.html#cryptorandomfillbuffer-offset-size-callback)의 동기 버전입니다.

```js
import { Buffer } from 'node:buffer';
const { randomFillSync } = await import('node:crypto');

const buf = Buffer.alloc(10);
console.log(randomFillSync(buf).toString('hex'));

randomFillSync(buf, 5);
console.log(buf.toString('hex'));

// 위 코드는 아래와 동일합니다.
randomFillSync(buf, 5, 5);
console.log(buf.toString('hex'));
```

`ArrayBuffer`, `TypedArray`, `DataView` 인스턴스를 `buffer`로 전달할 수 있습니다.

```js
import { Buffer } from 'node:buffer';
const { randomFillSync } = await import('node:crypto');

const a = new Uint32Array(10);
console.log(Buffer.from(randomFillSync(a).buffer, a.byteOffset, a.byteLength).toString('hex'));

const b = new DataView(new ArrayBuffer(10));
console.log(Buffer.from(randomFillSync(b).buffer, b.byteOffset, b.byteLength).toString('hex'));

const c = new ArrayBuffer(10);
console.log(Buffer.from(randomFillSync(c)).toString('hex'));
```


#### `crypto.randomInt([min, ]max[, callback])`

- `min` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 랜덤 범위의 시작 값 (포함). **기본값:** `0`.
- `max` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 랜덤 범위의 끝 값 (제외).
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) `function(err, n) {}`.

`min <= n < max` 조건을 만족하는 랜덤 정수 `n`을 반환합니다. 이 구현은 [모듈로 편향](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Modulo_bias)을 피합니다.

범위 (`max - min`)는 2<sup>48</sup>보다 작아야 합니다. `min`과 `max`는 [안전한 정수](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isSafeInteger)여야 합니다.

`callback` 함수가 제공되지 않으면, 랜덤 정수는 동기적으로 생성됩니다.

```javascript
// 비동기 방식
const { randomInt } = await import('node:crypto');
randomInt(3, (err, n) => {
    if (err) throw err;
    console.log(`(0, 1, 2) 중 선택된 랜덤 숫자: ${n}`);
});
```

```javascript
// 동기 방식
const { randomInt } = await import('node:crypto');
const n = randomInt(3);
console.log(`(0, 1, 2) 중 선택된 랜덤 숫자: ${n}`);
```

```javascript
// `min` 인수 사용
const { randomInt } = await import('node:crypto');
const n = randomInt(1, 7);
console.log(`주사위 결과: ${n}`);
```


#### `crypto.randomUUID([options])`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptorandomuuidoptions)

추가된 버전: v15.6.0, v14.17.0

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `disableEntropyCache` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 기본적으로 성능 향상을 위해 Node.js는 최대 128개의 랜덤 UUID를 생성할 수 있는 충분한 랜덤 데이터를 생성하고 캐시합니다. 캐시를 사용하지 않고 UUID를 생성하려면 `disableEntropyCache`를 `true`로 설정하세요. **기본값:** `false`.
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

[RFC 4122](https://www.rfc-editor.org/rfc/rfc4122.txt) 버전 4에 따른 랜덤 UUID를 생성합니다. 이 UUID는 암호화된 의사 난수 생성기를 사용하여 생성됩니다.


#### `crypto.scrypt(password, salt, keylen[, options], callback)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptoscryptpassword-salt-keylen-options-callback)

-   `password` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `cost` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) CPU/메모리 비용 파라미터. 1보다 큰 2의 제곱수여야 함. **기본값:** `16384`.
    -   `blockSize` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 블록 크기 파라미터. **기본값:** `8`.
    -   `parallelization` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 병렬화 파라미터. **기본값:** `1`.
    -   `N` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `cost`의 별칭. 둘 중 하나만 지정 가능.
    -   `r` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `blockSize`의 별칭. 둘 중 하나만 지정 가능.
    -   `p` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `parallelization`의 별칭. 둘 중 하나만 지정 가능.
    -   `maxmem` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 메모리 상한. `128 * N * r > maxmem`일 경우 오류 발생. **기본값:** `32 * 1024 * 1024`.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `derivedKey` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

비동기 [scrypt](https://en.wikipedia.org/wiki/Scrypt) 구현을 제공합니다. Scrypt는 무차별 대입 공격을 어렵게 만들기 위해 계산 및 메모리 측면에서 비용이 많이 드는 비밀번호 기반 키 유도 함수입니다.

`salt`는 가능한 한 고유해야 합니다. 랜덤하고 최소 16바이트 길이의 salt를 사용하는 것이 권장됩니다. 자세한 내용은 [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)를 참고하세요.

`password`나 `salt`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.

`callback` 함수는 `err`와 `derivedKey` 두 인자와 함께 호출됩니다. `err`는 키 유도가 실패했을 때 예외 객체이며, 그렇지 않으면 `null`입니다. `derivedKey`는 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)로 콜백에 전달됩니다.

입력 인자가 유효하지 않은 값이나 타입을 지정하면 예외가 발생합니다.

```javascript
const { scrypt } = await import('node:crypto');

// 기본 설정 사용
scrypt('password', 'salt', 64, (err, derivedKey) => {
    if (err) throw err;
    console.log(derivedKey.toString('hex')); // '3745e48...08d59ae'
});

// 커스텀 N 파라미터 사용. 2의 제곱수여야 함.
scrypt('password', 'salt', 64, { N: 1024 }, (err, derivedKey) => {
    if (err) throw err;
    console.log(derivedKey.toString('hex')); // '3745e48...aa39b34'
});
```


#### `crypto.scryptSync(password, salt, keylen[, options])`

- `password` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `salt` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `keylen` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `cost` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) CPU/메모리 비용 파라미터. 1보다 큰 2의 제곱수여야 함. **기본값:** `16384`.
  - `blockSize` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 블록 크기 파라미터. **기본값:** `8`.
  - `parallelization` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 병렬화 파라미터. **기본값:** `1`.
  - `N` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `cost`의 별칭. 둘 중 하나만 지정 가능.
  - `r` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `blockSize`의 별칭. 둘 중 하나만 지정 가능.
  - `p` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `parallelization`의 별칭. 둘 중 하나만 지정 가능.
  - `maxmem` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 메모리 상한. `128 * N * r > maxmem`일 경우 오류 발생. **기본값:** `32 * 1024 * 1024`.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

동기적인 [scrypt](https://en.wikipedia.org/wiki/Scrypt) 구현을 제공합니다. Scrypt는 무차별 대입 공격을 어렵게 만들기 위해 계산 및 메모리 사용 측면에서 비용이 많이 드는 비밀번호 기반 키 유도 함수입니다.

`salt`는 가능한 한 고유해야 합니다. 랜덤하고 최소 16바이트 길이의 salt를 사용하는 것이 권장됩니다. 자세한 내용은 [NIST SP 800-132](https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf)를 참고하세요.

`password`나 `salt`로 문자열을 전달할 때는 [암호화 API에 문자열을 입력으로 사용할 때의 주의사항](https://nodejs.org/docs/latest/api/crypto.html#using-strings-as-inputs-to-cryptographic-apis)을 고려하세요.

키 유도가 실패하면 예외가 발생하며, 그렇지 않으면 유도된 키가 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html)로 반환됩니다.

입력 인수가 유효하지 않은 값이나 타입을 지정하면 예외가 발생합니다.

```javascript
const { scryptSync } = await import('node:crypto');

// 기본 설정 사용
const key1 = scryptSync('password', 'salt', 64);
console.log(key1.toString('hex')); // '3745e48...08d59ae'

// 커스텀 N 파라미터 사용. 2의 제곱수여야 함.
const key2 = scryptSync('password', 'salt', 64, { N: 1024 });
console.log(key2.toString('hex')); // '3745e48...aa39b34'
```


#### `crypto.secureHeapUsed()`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptosecureheapused)

추가된 버전: v15.6.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `total` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `--secure-heap=n` 커맨드라인 플래그로 지정된 전체 할당된 보안 힙 크기.
    -   `min` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `--secure-heap-min` 커맨드라인 플래그로 지정된 보안 힙의 최소 할당 크기.
    -   `used` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 현재 보안 힙에서 할당된 총 바이트 수.
    -   `utilization` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `used`와 `total` 할당된 바이트의 비율을 계산한 값.


#### `crypto.setEngine(engine[, flags])`

- `engine` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `flags` [`<crypto.constants>`](https://nodejs.org/docs/latest/api/crypto.html#cryptoconstants) **기본값:** `crypto.constants.ENGINE_METHOD_ALL`

특정 또는 모든 OpenSSL 함수에 대해 `engine`을 로드하고 설정합니다. OpenSSL 3부터는 커스텀 엔진 지원이 더 이상 권장되지 않습니다.

`engine`은 엔진의 ID 또는 공유 라이브러리의 경로가 될 수 있습니다.

선택적 인자 `flags`는 기본적으로 `ENGINE_METHOD_ALL`을 사용합니다. `flags`는 비트 필드로, 다음 플래그 중 하나 또는 조합을 사용할 수 있습니다 (플래그는 `crypto.constants`에 정의됨):

- `crypto.constants.ENGINE_METHOD_RSA`
- `crypto.constants.ENGINE_METHOD_DSA`
- `crypto.constants.ENGINE_METHOD_DH`
- `crypto.constants.ENGINE_METHOD_RAND`
- `crypto.constants.ENGINE_METHOD_EC`
- `crypto.constants.ENGINE_METHOD_CIPHERS`
- `crypto.constants.ENGINE_METHOD_DIGESTS`
- `crypto.constants.ENGINE_METHOD_PKEY_METHS`
- `crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS`
- `crypto.constants.ENGINE_METHOD_ALL`
- `crypto.constants.ENGINE_METHOD_NONE`


#### `crypto.setFips(bool)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptosetfipsbool)

추가된 버전: v10.0.0

- `bool` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) FIPS 모드를 활성화하려면 `true`로 설정합니다.

FIPS가 활성화된 Node.js 빌드에서 FIPS 규격 암호화 프로바이더를 활성화합니다. FIPS 모드를 사용할 수 없는 경우 에러를 발생시킵니다.


#### `crypto.sign(algorithm, data, key[, callback])`

- `algorithm` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)
- `data` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
- `key` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<KeyObject>`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject) | [`<CryptoKey>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-cryptokey)
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
  - `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
  - `signature` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) (`callback` 함수가 제공되지 않은 경우)

주어진 개인 키와 알고리즘을 사용하여 `data`에 대한 서명을 계산하고 반환합니다. `algorithm`이 `null` 또는 `undefined`인 경우, 알고리즘은 키 타입(특히 Ed25519와 Ed448)에 따라 결정됩니다.

`key`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `key`가 [`crypto.createPrivateKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreateprivatekeykey)에 전달된 것처럼 동작합니다. `key`가 객체인 경우, 다음과 같은 추가 속성을 전달할 수 있습니다:

- `dsaEncoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): DSA와 ECDSA에서 이 옵션은 생성된 서명의 형식을 지정합니다. 다음 중 하나일 수 있습니다:
  - `'der'` (기본값): DER로 인코딩된 ASN.1 서명 구조 `(r, s)`.
  - `'ieee-p1363'`: IEEE-P1363에서 제안된 `r || s` 형식의 서명.
  
- `padding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): RSA에 대한 선택적 패딩 값으로, 다음 중 하나일 수 있습니다:
  - `crypto.constants.RSA_PKCS1_PADDING` (기본값)
  - `crypto.constants.RSA_PKCS1_PSS_PADDING`
  
  `RSA_PKCS1_PSS_PADDING`은 [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt)의 섹션 3.1에 명시된 대로 메시지 서명에 사용된 해시 함수와 동일한 MGF1을 사용합니다.
  
- `saltLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 패딩이 `RSA_PKCS1_PSS_PADDING`일 때의 솔트 길이입니다. 특수 값 `crypto.constants.RSA_PSS_SALTLEN_DIGEST`는 솔트 길이를 다이제스트 크기로 설정하고, `crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN` (기본값)은 허용 가능한 최대 값으로 설정합니다.

`callback` 함수가 제공된 경우, 이 함수는 libuv의 스레드 풀을 사용합니다.


#### `crypto.subtle`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptosubtle)

추가된 버전: v17.4.0

-   타입: [`<SubtleCrypto>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-subtlecrypto)

[`crypto.webcrypto.subtle`](https://nodejs.org/docs/latest/api/webcrypto.html#class-subtlecrypto)의 편리한 별칭입니다.


#### `crypto.timingSafeEqual(a, b)`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptotimingsafeequala-b)

-   `a` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   `b` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 함수는 주어진 `ArrayBuffer`, `TypedArray`, 또는 `DataView` 인스턴스의 바이트를 상수 시간 알고리즘을 사용하여 비교합니다.

이 함수는 공격자가 값을 추측할 수 있는 타이밍 정보를 유출하지 않습니다. 따라서 HMAC 다이제스트나 인증 쿠키, [capability URLs](https://www.w3.org/TR/capability-urls/)와 같은 비밀 값을 비교하는 데 적합합니다.

`a`와 `b`는 모두 `Buffer`, `TypedArray`, 또는 `DataView`여야 하며, 두 값의 바이트 길이가 동일해야 합니다. `a`와 `b`의 바이트 길이가 다르면 에러가 발생합니다.

`a`와 `b` 중 하나 이상이 `Uint16Array`와 같이 한 엔트리에 여러 바이트를 사용하는 `TypedArray`인 경우, 결과는 플랫폼의 바이트 순서를 사용하여 계산됩니다.

**두 입력이 모두 `Float32Array` 또는 `Float64Array`인 경우, IEEE 754 부동소수점 숫자 인코딩으로 인해 예상치 못한 결과가 반환될 수 있습니다. 특히, `x === y` 또는 `Object.is(x, y)`가 참이라고 해서 두 부동소수점 숫자 `x`와 `y`의 바이트 표현이 동일하다는 것을 의미하지는 않습니다.**

`crypto.timingSafeEqual`을 사용한다고 해서 *주변* 코드가 타이밍 공격에 안전하다는 것을 보장하지는 않습니다. 주변 코드가 타이밍 취약점을 유발하지 않도록 주의해야 합니다.


#### `crypto.verify(algorithm, data, key, signature[, callback])`

-   `algorithm` [`<string>`] | [`<null>`] | [`<undefined>`]
-   `data` [`<ArrayBuffer>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`]
-   `key` [`<Object>`] | [`<string>`] | [`<ArrayBuffer>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`] | [`<KeyObject>`] | [`<CryptoKey>`]
-   `signature` [`<ArrayBuffer>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`]
-   `callback` [`<Function>`]
    -   `err` [`<Error>`]
    -   `result` [`<boolean>`]
-   반환값: [`<boolean>`] `callback` 함수가 제공되지 않으면, 데이터와 공개 키에 대한 서명의 유효성에 따라 `true` 또는 `false`를 반환합니다.

주어진 키와 알고리즘을 사용하여 `data`에 대한 서명을 검증합니다. `algorithm`이 `null` 또는 `undefined`인 경우, 알고리즘은 키 타입(특히 Ed25519와 Ed448)에 따라 결정됩니다.

`key`가 [`KeyObject`](https://nodejs.org/docs/latest/api/crypto.html#class-keyobject)가 아닌 경우, 이 함수는 `key`가 [`crypto.createPublicKey()`](https://nodejs.org/docs/latest/api/crypto.html#cryptocreatepublickeykey)에 전달된 것처럼 동작합니다. 객체인 경우, 다음과 같은 추가 속성을 전달할 수 있습니다:

-   `dsaEncoding` [`<string>`] DSA와 ECDSA의 경우, 이 옵션은 서명의 형식을 지정합니다. 다음 중 하나일 수 있습니다:
    
    -   `'der'` (기본값): DER로 인코딩된 ASN.1 서명 구조 `(r, s)`.
    -   `'ieee-p1363'`: IEEE-P1363에서 제안한 `r || s` 형식의 서명.
-   `padding` [`<integer>`] RSA에 대한 선택적 패딩 값으로, 다음 중 하나일 수 있습니다:
    
    -   `crypto.constants.RSA_PKCS1_PADDING` (기본값)
    -   `crypto.constants.RSA_PKCS1_PSS_PADDING`
    
    `RSA_PKCS1_PSS_PADDING`은 [RFC 4055](https://www.rfc-editor.org/rfc/rfc4055.txt)의 3.1절에 명시된 대로 메시지 서명에 사용된 해시 함수와 동일한 MGF1을 사용합니다.
    
-   `saltLength` [`<integer>`] 패딩이 `RSA_PKCS1_PSS_PADDING`일 때의 솔트 길이입니다. 특수 값 `crypto.constants.RSA_PSS_SALTLEN_DIGEST`는 솔트 길이를 다이제스트 크기로 설정하고, `crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN` (기본값)은 최대 허용 값으로 설정합니다.
    

`signature` 인자는 이전에 계산된 `data`에 대한 서명입니다.

공개 키는 개인 키에서 파생될 수 있으므로, `key`로 개인 키 또는 공개 키를 전달할 수 있습니다.

`callback` 함수가 제공되면, 이 함수는 libuv의 스레드 풀을 사용합니다.


#### `crypto.webcrypto`[#](https://nodejs.org/docs/latest/api/crypto.html#cryptowebcrypto)

추가된 버전: v15.0.0

타입: [`<Crypto>`](https://nodejs.org/docs/latest/api/webcrypto.html#class-crypto)  
Web Crypto API 표준의 구현체입니다.

자세한 내용은 [Web Crypto API 문서](https://nodejs.org/docs/latest/api/webcrypto.html)를 참고하세요.


### Notes[#](https://nodejs.org/docs/latest/api/crypto.html#notes)





#### 암호화 API에서 문자열 입력 사용하기

역사적인 이유로, Node.js가 제공하는 많은 암호화 API는 기본적으로 바이트 시퀀스를 다루는 암호화 알고리즘에 문자열을 입력으로 받습니다. 이러한 경우에는 평문, 암호문, 대칭 키, 초기화 벡터, 패스프레이즈, 솔트, 인증 태그, 추가 인증 데이터 등이 포함됩니다.

암호화 API에 문자열을 전달할 때 다음 사항을 고려해야 합니다.

- 모든 바이트 시퀀스가 유효한 UTF-8 문자열은 아닙니다. 따라서 길이가 `n`인 바이트 시퀀스가 문자열에서 파생된 경우, 그 엔트로피는 일반적으로 무작위 또는 의사 무작위 `n` 바이트 시퀀스의 엔트로피보다 낮습니다. 예를 들어, 어떤 UTF-8 문자열도 `c0 af`라는 바이트 시퀀스를 생성하지 않습니다. 비밀 키는 거의 항상 무작위 또는 의사 무작위 바이트 시퀀스여야 합니다.

- 마찬가지로, 무작위 또는 의사 무작위 바이트 시퀀스를 UTF-8 문자열로 변환할 때, 유효한 코드 포인트를 나타내지 않는 부분 시퀀스는 유니코드 대체 문자(`U+FFFD`)로 대체될 수 있습니다. 따라서 결과 유니코드 문자열의 바이트 표현은 원래 바이트 시퀀스와 같지 않을 수 있습니다.

    ```js
    const original = [0xc0, 0xaf];
    const bytesAsString = Buffer.from(original).toString('utf8');
    const stringAsBytes = Buffer.from(bytesAsString, 'utf8');
    console.log(stringAsBytes); // ''를 출력합니다.
    ```

    암호화 함수, 해시 함수, 서명 알고리즘, 키 유도 함수의 출력은 의사 무작위 바이트 시퀀스이며, 유니코드 문자열로 사용해서는 안 됩니다.

- 사용자 입력에서 문자열을 얻을 때, 일부 유니코드 문자는 서로 다른 바이트 시퀀스를 생성하는 여러 동등한 방식으로 표현될 수 있습니다. 예를 들어, 사용자 패스프레이즈를 PBKDF2나 scrypt 같은 키 유도 함수에 전달할 때, 키 유도 함수의 결과는 문자열이 합성된 문자를 사용하는지 분해된 문자를 사용하는지에 따라 달라집니다. Node.js는 문자 표현을 정규화하지 않습니다. 개발자는 암호화 API에 전달하기 전에 사용자 입력에 [`String.prototype.normalize()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)를 사용하는 것을 고려해야 합니다.


#### 레거시 스트림 API (Node.js 0.10 이전)

Crypto 모듈은 통합된 Stream API 개념이 생기기 전, 그리고 바이너리 데이터를 처리하기 위한 [`Buffer`](https://nodejs.org/docs/latest/api/buffer.html) 객체가 도입되기 전에 Node.js에 추가되었습니다. 따라서 많은 `crypto` 클래스는 [스트림](https://nodejs.org/docs/latest/api/stream.html) API를 구현하는 다른 Node.js 클래스에서는 일반적으로 찾아볼 수 없는 메서드(`update()`, `final()`, `digest()` 등)를 가지고 있습니다. 또한, 많은 메서드가 기본적으로 `Buffer` 대신 `'latin1'` 인코딩된 문자열을 받고 반환했습니다. 이 기본값은 Node.js v0.8 이후로 `Buffer` 객체를 기본으로 사용하도록 변경되었습니다.


#### 취약하거나 문제가 있는 알고리즘 지원[#](https://nodejs.org/docs/latest/api/crypto.html#support-for-weak-or-compromised-algorithms)

`node:crypto` 모듈은 이미 문제가 발견되어 사용이 권장되지 않는 일부 알고리즘을 여전히 지원합니다. 또한, 안전한 사용에 적합하지 않은 작은 키 크기의 암호화 알고리즘과 해시 함수를 사용할 수 있도록 허용합니다.

사용자는 보안 요구사항에 맞게 암호화 알고리즘과 키 크기를 선택하는 데 전적인 책임을 져야 합니다.

[NIST SP 800-131A](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar2.pdf)의 권장사항에 따르면:

-   MD5와 SHA-1은 디지털 서명과 같이 충돌 저항성이 필요한 경우 더 이상 사용할 수 없습니다.
-   RSA, DSA, DH 알고리즘과 함께 사용되는 키는 최소 2048비트, ECDSA와 ECDH의 곡선은 최소 224비트여야 안전하게 사용할 수 있습니다.
-   `modp1`, `modp2`, `modp5` DH 그룹은 키 크기가 2048비트보다 작아 권장되지 않습니다.

다른 권장사항과 자세한 내용은 참고 문서를 확인하세요.

실제로 거의 사용되지 않고 알려진 취약점이 있는 일부 알고리즘은 기본적으로 활성화되지 않은 [레거시 프로바이더](https://nodejs.org/docs/latest/api/cli.html#--openssl-legacy-provider)를 통해서만 사용할 수 있습니다.


#### CCM 모드[#](https://nodejs.org/docs/latest/api/crypto.html#ccm-mode)

CCM은 지원되는 [AEAD 알고리즘](https://en.wikipedia.org/wiki/Authenticated_encryption) 중 하나입니다. 이 모드를 사용하는 애플리케이션은 암호화 API를 사용할 때 몇 가지 제약 사항을 준수해야 합니다:

-   인증 태그 길이는 `authTagLength` 옵션을 설정하여 암호화 생성 시 지정해야 하며, 4, 6, 8, 10, 12, 14 또는 16바이트 중 하나여야 합니다.
-   초기화 벡터(nonce) `N`의 길이는 7에서 13바이트 사이여야 합니다 (`7 ≤ N ≤ 13`).
-   평문의 길이는 `2 ** (8 * (15 - N))` 바이트로 제한됩니다.
-   복호화할 때, `update()`를 호출하기 전에 `setAuthTag()`를 통해 인증 태그를 설정해야 합니다. 그렇지 않으면 복호화가 실패하고 `final()`은 [RFC 3610](https://www.rfc-editor.org/rfc/rfc3610.txt)의 2.6절에 따라 오류를 발생시킵니다.
-   CCM 모드에서 `write(data)`, `end(data)` 또는 `pipe()`와 같은 스트림 메서드를 사용하면 실패할 수 있습니다. CCM은 인스턴스당 하나의 데이터 청크만 처리할 수 있기 때문입니다.
-   추가 인증 데이터(AAD)를 전달할 때, 실제 메시지의 바이트 길이를 `plaintextLength` 옵션을 통해 `setAAD()`에 전달해야 합니다. 많은 암호화 라이브러리는 암호문에 인증 태그를 포함하므로, 암호문의 길이는 `plaintextLength + authTagLength`가 됩니다. Node.js는 인증 태그를 포함하지 않으므로 암호문의 길이는 항상 `plaintextLength`입니다. AAD를 사용하지 않으면 이 작업은 필요하지 않습니다.
-   CCM은 전체 메시지를 한 번에 처리하므로, `update()`는 정확히 한 번만 호출되어야 합니다.
-   `update()`를 호출하는 것만으로도 메시지를 암호화/복호화할 수 있지만, 애플리케이션은 인증 태그를 계산하거나 검증하기 위해 반드시 `final()`을 호출해야 합니다.

```js
import { Buffer } from 'node:buffer';
const { createCipheriv, createDecipheriv, randomBytes } = await import('node:crypto');

const key = 'keykeykeykeykeykeykeykey';
const nonce = randomBytes(12);
const aad = Buffer.from('0123456789', 'hex');

const cipher = createCipheriv('aes-192-ccm', key, nonce, { authTagLength: 16 });
const plaintext = 'Hello world';
cipher.setAAD(aad, { plaintextLength: Buffer.byteLength(plaintext) });
const ciphertext = cipher.update(plaintext, 'utf8');
cipher.final();
const tag = cipher.getAuthTag();

// 이제 { ciphertext, nonce, tag }를 전송합니다.
const decipher = createDecipheriv('aes-192-ccm', key, nonce, { authTagLength: 16 });
decipher.setAuthTag(tag);
decipher.setAAD(aad, { plaintextLength: ciphertext.length });
const receivedPlaintext = decipher.update(ciphertext, null, 'utf8');

try {
    decipher.final();
} catch (err) {
    throw new Error('Authentication failed!', { cause: err });
}

console.log(receivedPlaintext);
```


#### FIPS 모드

OpenSSL 3을 사용할 때, Node.js는 적절한 OpenSSL 3 프로바이더와 함께 FIPS 140-2를 지원합니다. 예를 들어, [OpenSSL 3의 FIPS 프로바이더](https://www.openssl.org/docs/man3.0/man7/crypto.html#FIPS-provider)를 사용할 수 있으며, 이는 [OpenSSL의 FIPS README 파일](https://github.com/openssl/openssl/blob/openssl-3.0/README-FIPS.md)에 있는 지침을 따라 설치할 수 있습니다.

Node.js에서 FIPS를 지원하려면 다음이 필요합니다:

-   올바르게 설치된 OpenSSL 3 FIPS 프로바이더.
-   OpenSSL 3 [FIPS 모듈 설정 파일](https://www.openssl.org/docs/man3.0/man5/fips_config.html).
-   FIPS 모듈 설정 파일을 참조하는 OpenSSL 3 설정 파일.

Node.js는 FIPS 프로바이더를 가리키는 OpenSSL 설정 파일로 구성되어야 합니다. 예제 설정 파일은 다음과 같습니다:

```text
nodejs_conf = nodejs_init
.include //fipsmodule.cnf

[nodejs_init]
providers = provider_sect

[provider_sect]
default = default_sect
# fips 섹션 이름은 포함된 fipsmodule.cnf 파일 내의 섹션 이름과 일치해야 합니다.
fips = fips_sect

[default_sect]
activate = 1
```

여기서 `fipsmodule.cnf`는 FIPS 프로바이더 설치 단계에서 생성된 FIPS 모듈 설정 파일입니다:

```bash
openssl fipsinstall
```

`OPENSSL_CONF` 환경 변수를 설정 파일로 지정하고, `OPENSSL_MODULES`를 FIPS 프로바이더 동적 라이브러리의 위치로 설정합니다. 예를 들어:

```bash
export OPENSSL_CONF=//nodejs.cnf
export OPENSSL_MODULES=//ossl-modules
```

그런 다음 Node.js에서 FIPS 모드를 활성화할 수 있습니다. 방법은 다음과 같습니다:

-   `--enable-fips` 또는 `--force-fips` 커맨드라인 플래그로 Node.js를 시작합니다.
-   프로그래밍 방식으로 `crypto.setFips(true)`를 호출합니다.

선택적으로 OpenSSL 설정 파일을 통해 Node.js에서 FIPS 모드를 활성화할 수도 있습니다. 예를 들어:

```text
nodejs_conf = nodejs_init
.include //fipsmodule.cnf

[nodejs_init]
providers = provider_sect
alg_section = algorithm_sect

[provider_sect]
default = default_sect
# fips 섹션 이름은 포함된 fipsmodule.cnf 파일 내의 섹션 이름과 일치해야 합니다.
fips = fips_sect

[default_sect]
activate = 1

[algorithm_sect]
default_properties = fips=yes
```


### 암호화 상수

`crypto.constants`에서 내보내는 다음 상수들은 `node:crypto`, `node:tls`, 그리고 `node:https` 모듈의 다양한 사용에 적용되며, 일반적으로 OpenSSL에 특화되어 있습니다.


#### OpenSSL 옵션[#](https://nodejs.org/docs/latest/api/crypto.html#openssl-options)

자세한 내용은 [SSL OP 플래그 목록](https://wiki.openssl.org/index.php/List_of_SSL_OP_Flags#Table_of_Options)을 참고하세요.

| 상수 | 설명 |
| --- | --- |
| `SSL_OP_ALL` | OpenSSL 내에서 여러 버그를 해결하기 위한 옵션입니다. 자세한 내용은 [https://www.openssl.org/docs/man3.0/man3/SSL\_CTX\_set\_options.html](https://www.openssl.org/docs/man3.0/man3/SSL_CTX_set_options.html)를 참고하세요. |
| `SSL_OP_ALLOW_NO_DHE_KEX` | OpenSSL이 TLS v1.3에서 \[EC\]DHE 기반이 아닌 키 교환 모드를 허용하도록 지시합니다. |
| `SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION` | OpenSSL과 패치되지 않은 클라이언트 또는 서버 간의 레거시 안전하지 않은 재협상을 허용합니다. 자세한 내용은 [https://www.openssl.org/docs/man3.0/man3/SSL\_CTX\_set\_options.html](https://www.openssl.org/docs/man3.0/man3/SSL_CTX_set_options.html)를 참고하세요. |
| `SSL_OP_CIPHER_SERVER_PREFERENCE` | 암호 선택 시 클라이언트의 선호도 대신 서버의 선호도를 사용하려고 시도합니다. 프로토콜 버전에 따라 동작이 달라질 수 있습니다. 자세한 내용은 [https://www.openssl.org/docs/man3.0/man3/SSL\_CTX\_set\_options.html](https://www.openssl.org/docs/man3.0/man3/SSL_CTX_set_options.html)를 참고하세요. |
| `SSL_OP_CISCO_ANYCONNECT` | OpenSSL이 Cisco의 DTLS\_BAD\_VER 버전 식별자를 사용하도록 지시합니다. |
| `SSL_OP_COOKIE_EXCHANGE` | OpenSSL이 쿠키 교환을 활성화하도록 지시합니다. |
| `SSL_OP_CRYPTOPRO_TLSEXT_BUG` | OpenSSL이 초기 cryptopro 드래프트 버전의 서버-hello 확장을 추가하도록 지시합니다. |
| `SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS` | OpenSSL이 OpenSSL 0.9.6d에서 추가된 SSL 3.0/TLS 1.0 취약점 해결 방안을 비활성화하도록 지시합니다. |
| `SSL_OP_LEGACY_SERVER_CONNECT` | RI를 지원하지 않는 서버와의 초기 연결을 허용합니다. |
| `SSL_OP_NO_COMPRESSION` | OpenSSL이 SSL/TLS 압축 지원을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_ENCRYPT_THEN_MAC` | OpenSSL이 encrypt-then-MAC을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_QUERY_MTU` |  |
| `SSL_OP_NO_RENEGOTIATION` | OpenSSL이 재협상을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION` | OpenSSL이 재협상 시 항상 새로운 세션을 시작하도록 지시합니다. |
| `SSL_OP_NO_SSLv2` | OpenSSL이 SSL v2를 비활성화하도록 지시합니다. |
| `SSL_OP_NO_SSLv3` | OpenSSL이 SSL v3를 비활성화하도록 지시합니다. |
| `SSL_OP_NO_TICKET` | OpenSSL이 RFC4507bis 티켓 사용을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_TLSv1` | OpenSSL이 TLS v1을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_TLSv1_1` | OpenSSL이 TLS v1.1을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_TLSv1_2` | OpenSSL이 TLS v1.2을 비활성화하도록 지시합니다. |
| `SSL_OP_NO_TLSv1_3` | OpenSSL이 TLS v1.3을 비활성화하도록 지시합니다. |
| `SSL_OP_PRIORITIZE_CHACHA` | 클라이언트가 ChaCha20-Poly1305를 우선시할 때 OpenSSL 서버도 이를 우선시하도록 지시합니다. 이 옵션은 `SSL_OP_CIPHER_SERVER_PREFERENCE`가 활성화되지 않은 경우 효과가 없습니다. |
| `SSL_OP_TLS_ROLLBACK_BUG` | OpenSSL이 버전 롤백 공격 감지를 비활성화하도록 지시합니다. |


#### OpenSSL 엔진 상수[#](https://nodejs.org/docs/latest/api/crypto.html#openssl-engine-constants)

| 상수 | 설명 |
| --- | --- |
| `ENGINE_METHOD_RSA` | 엔진 사용을 RSA로 제한 |
| `ENGINE_METHOD_DSA` | 엔진 사용을 DSA로 제한 |
| `ENGINE_METHOD_DH` | 엔진 사용을 DH로 제한 |
| `ENGINE_METHOD_RAND` | 엔진 사용을 RAND로 제한 |
| `ENGINE_METHOD_EC` | 엔진 사용을 EC로 제한 |
| `ENGINE_METHOD_CIPHERS` | 엔진 사용을 CIPHERS로 제한 |
| `ENGINE_METHOD_DIGESTS` | 엔진 사용을 DIGESTS로 제한 |
| `ENGINE_METHOD_PKEY_METHS` | 엔진 사용을 PKEY\_METHS로 제한 |
| `ENGINE_METHOD_PKEY_ASN1_METHS` | 엔진 사용을 PKEY\_ASN1\_METHS로 제한 |
| `ENGINE_METHOD_ALL` | 모든 기능 사용 |
| `ENGINE_METHOD_NONE` | 기능 사용하지 않음 |


#### 기타 OpenSSL 상수

| 상수 | 설명 |
| --- | --- |
| `DH_CHECK_P_NOT_SAFE_PRIME` |  |
| `DH_CHECK_P_NOT_PRIME` |  |
| `DH_UNABLE_TO_CHECK_GENERATOR` |  |
| `DH_NOT_SUITABLE_GENERATOR` |  |
| `RSA_PKCS1_PADDING` |  |
| `RSA_SSLV23_PADDING` |  |
| `RSA_NO_PADDING` |  |
| `RSA_PKCS1_OAEP_PADDING` |  |
| `RSA_X931_PADDING` |  |
| `RSA_PKCS1_PSS_PADDING` |  |
| `RSA_PSS_SALTLEN_DIGEST` | `RSA_PKCS1_PSS_PADDING`을 사용할 때 서명 또는 검증 시 소금 길이를 다이제스트 크기로 설정합니다. |
| `RSA_PSS_SALTLEN_MAX_SIGN` | `RSA_PKCS1_PSS_PADDING`을 사용할 때 데이터 서명 시 소금 길이를 허용 가능한 최대 값으로 설정합니다. |
| `RSA_PSS_SALTLEN_AUTO` | `RSA_PKCS1_PSS_PADDING`을 사용할 때 서명 검증 시 소금 길이를 자동으로 결정합니다. |
| `POINT_CONVERSION_COMPRESSED` |  |
| `POINT_CONVERSION_UNCOMPRESSED` |  |
| `POINT_CONVERSION_HYBRID` |  |


#### Node.js crypto 상수

| 상수 | 설명 |
| --- | --- |
| `defaultCoreCipherList` | Node.js에서 사용하는 기본 내장 암호화 목록을 지정합니다. |
| `defaultCipherList` | 현재 Node.js 프로세스에서 사용 중인 활성 기본 암호화 목록을 지정합니다. |


