# Table of Contents

- [이벤트](#이벤트)
    - [리스너에 인자와 `this` 전달하기](#리스너에-인자와-this-전달하기)
    - [비동기 vs 동기](#비동기-vs-동기)
    - [이벤트를 한 번만 처리하기](#이벤트를-한-번만-처리하기)
    - [에러 이벤트](#에러-이벤트)
    - [Promise의 거부(rejection) 캡처하기](#promise의-거부rejection-캡처하기)
    - [클래스: `EventEmitter`[#](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)](#클래스-eventemitterhttpsnodejsorgdocslatestapieventshtmlclass-eventemitter)
      - [이벤트: `'newListener'`[#](https://nodejs.org/docs/latest/api/events.html#event-newlistener)](#이벤트-newlistenerhttpsnodejsorgdocslatestapieventshtmlevent-newlistener)
      - [이벤트: `'removeListener'`[#](https://nodejs.org/docs/latest/api/events.html#event-removelistener)](#이벤트-removelistenerhttpsnodejsorgdocslatestapieventshtmlevent-removelistener)
      - [`emitter.addListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteraddlistenereventname-listener)](#emitteraddlistenereventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitteraddlistenereventname-listener)
      - [`emitter.emit(eventName[, ...args])`[#](https://nodejs.org/docs/latest/api/events.html#emitteremiteventname-args)](#emitteremiteventname-argshttpsnodejsorgdocslatestapieventshtmlemitteremiteventname-args)
      - [`emitter.eventNames()`[#](https://nodejs.org/docs/latest/api/events.html#emittereventnames)](#emittereventnameshttpsnodejsorgdocslatestapieventshtmlemittereventnames)
      - [`emitter.getMaxListeners()`[#](https://nodejs.org/docs/latest/api/events.html#emittergetmaxlisteners)](#emittergetmaxlistenershttpsnodejsorgdocslatestapieventshtmlemittergetmaxlisteners)
      - [`emitter.listenerCount(eventName[, listener])`](#emitterlistenercounteventname-listener)
      - [`emitter.listeners(eventName)`[#](https://nodejs.org/docs/latest/api/events.html#emitterlistenerseventname)](#emitterlistenerseventnamehttpsnodejsorgdocslatestapieventshtmlemitterlistenerseventname)
      - [`emitter.off(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteroffeventname-listener)](#emitteroffeventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitteroffeventname-listener)
      - [`emitter.on(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteroneventname-listener)](#emitteroneventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitteroneventname-listener)
      - [`emitter.once(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteronceeventname-listener)](#emitteronceeventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitteronceeventname-listener)
      - [`emitter.prependListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterprependlistenereventname-listener)](#emitterprependlistenereventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitterprependlistenereventname-listener)
      - [`emitter.prependOnceListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterprependoncelistenereventname-listener)](#emitterprependoncelistenereventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitterprependoncelistenereventname-listener)
      - [`emitter.removeAllListeners([eventName])`[#](https://nodejs.org/docs/latest/api/events.html#emitterremovealllistenerseventname)](#emitterremovealllistenerseventnamehttpsnodejsorgdocslatestapieventshtmlemitterremovealllistenerseventname)
      - [`emitter.removeListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterremovelistenereventname-listener)](#emitterremovelistenereventname-listenerhttpsnodejsorgdocslatestapieventshtmlemitterremovelistenereventname-listener)
      - [`emitter.setMaxListeners(n)`[#](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn)](#emittersetmaxlistenersnhttpsnodejsorgdocslatestapieventshtmlemittersetmaxlistenersn)
      - [`emitter.rawListeners(eventName)`[#](https://nodejs.org/docs/latest/api/events.html#emitterrawlistenerseventname)](#emitterrawlistenerseventnamehttpsnodejsorgdocslatestapieventshtmlemitterrawlistenerseventname)
      - [`emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])`](#emittersymbolfornodejsrejectionerr-eventname-args)
    - [`events.defaultMaxListeners`[#](https://nodejs.org/docs/latest/api/events.html#eventsdefaultmaxlisteners)](#eventsdefaultmaxlistenershttpsnodejsorgdocslatestapieventshtmleventsdefaultmaxlisteners)
    - [`events.errorMonitor`[#](https://nodejs.org/docs/latest/api/events.html#eventserrormonitor)](#eventserrormonitorhttpsnodejsorgdocslatestapieventshtmleventserrormonitor)
    - [`events.getEventListeners(emitterOrTarget, eventName)`[#](https://nodejs.org/docs/latest/api/events.html#eventsgeteventlistenersemitterortarget-eventname)](#eventsgeteventlistenersemitterortarget-eventnamehttpsnodejsorgdocslatestapieventshtmleventsgeteventlistenersemitterortarget-eventname)
    - [`events.getMaxListeners(emitterOrTarget)`[#](https://nodejs.org/docs/latest/api/events.html#eventsgetmaxlistenersemitterortarget)](#eventsgetmaxlistenersemitterortargethttpsnodejsorgdocslatestapieventshtmleventsgetmaxlistenersemitterortarget)
    - [`events.once(emitter, name[, options])`](#eventsonceemitter-name-options)
      - [`process.nextTick()`에서 발생하는 여러 이벤트를 기다릴 때 주의사항](#processnexttick에서-발생하는-여러-이벤트를-기다릴-때-주의사항)
    - [`events.captureRejections`[#](https://nodejs.org/docs/latest/api/events.html#eventscapturerejections)](#eventscapturerejectionshttpsnodejsorgdocslatestapieventshtmleventscapturerejections)
    - [`events.captureRejectionSymbol`](#eventscapturerejectionsymbol)
    - [`events.listenerCount(emitter, eventName)`[#](https://nodejs.org/docs/latest/api/events.html#eventslistenercountemitter-eventname)](#eventslistenercountemitter-eventnamehttpsnodejsorgdocslatestapieventshtmleventslistenercountemitter-eventname)
    - [`events.on(emitter, eventName[, options])`[#](https://nodejs.org/docs/latest/api/events.html#eventsonemitter-eventname-options)](#eventsonemitter-eventname-optionshttpsnodejsorgdocslatestapieventshtmleventsonemitter-eventname-options)
    - [`events.setMaxListeners(n[, ...eventTargets])`[#](https://nodejs.org/docs/latest/api/events.html#eventssetmaxlistenersn-eventtargets)](#eventssetmaxlistenersn-eventtargetshttpsnodejsorgdocslatestapieventshtmleventssetmaxlistenersn-eventtargets)
    - [`events.addAbortListener(signal, listener)`[#](https://nodejs.org/docs/latest/api/events.html#eventsaddabortlistenersignal-listener)](#eventsaddabortlistenersignal-listenerhttpsnodejsorgdocslatestapieventshtmleventsaddabortlistenersignal-listener)
    - [클래스: `events.EventEmitterAsyncResource extends EventEmitter`[#](https://nodejs.org/docs/latest/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter)](#클래스-eventseventemitterasyncresource-extends-eventemitterhttpsnodejsorgdocslatestapieventshtmlclass-eventseventemitterasyncresource-extends-eventemitter)
      - [`new events.EventEmitterAsyncResource([options])`](#new-eventseventemitterasyncresourceoptions)
      - [`eventemitterasyncresource.asyncId`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourceasyncid)](#eventemitterasyncresourceasyncidhttpsnodejsorgdocslatestapieventshtmleventemitterasyncresourceasyncid)
      - [`eventemitterasyncresource.asyncResource`](#eventemitterasyncresourceasyncresource)
      - [`eventemitterasyncresource.emitDestroy()`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourceemitdestroy)](#eventemitterasyncresourceemitdestroyhttpsnodejsorgdocslatestapieventshtmleventemitterasyncresourceemitdestroy)
      - [`eventemitterasyncresource.triggerAsyncId`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourcetriggerasyncid)](#eventemitterasyncresourcetriggerasyncidhttpsnodejsorgdocslatestapieventshtmleventemitterasyncresourcetriggerasyncid)
    - [`EventTarget`과 `Event` API[#](https://nodejs.org/docs/latest/api/events.html#eventtarget-and-event-api)](#eventtarget과-event-apihttpsnodejsorgdocslatestapieventshtmleventtarget-and-event-api)
      - [Node.js `EventTarget` vs. DOM `EventTarget`](#nodejs-eventtarget-vs-dom-eventtarget)
      - [`NodeEventTarget` vs. `EventEmitter`](#nodeeventtarget-vs-eventemitter)
      - [이벤트 리스너](#이벤트-리스너)
      - [`EventTarget` 오류 처리[#](https://nodejs.org/docs/latest/api/events.html#eventtarget-error-handling)](#eventtarget-오류-처리httpsnodejsorgdocslatestapieventshtmleventtarget-error-handling)
      - [클래스: `Event`[#](https://nodejs.org/docs/latest/api/events.html#class-event)](#클래스-eventhttpsnodejsorgdocslatestapieventshtmlclass-event)
        - [`event.bubbles`[#](https://nodejs.org/docs/latest/api/events.html#eventbubbles)](#eventbubbleshttpsnodejsorgdocslatestapieventshtmleventbubbles)
        - [`event.cancelBubble`[#](https://nodejs.org/docs/latest/api/events.html#eventcancelbubble)](#eventcancelbubblehttpsnodejsorgdocslatestapieventshtmleventcancelbubble)
        - [`event.cancelable`[#](https://nodejs.org/docs/latest/api/events.html#eventcancelable)](#eventcancelablehttpsnodejsorgdocslatestapieventshtmleventcancelable)
        - [`event.composed`[#](https://nodejs.org/docs/latest/api/events.html#eventcomposed)](#eventcomposedhttpsnodejsorgdocslatestapieventshtmleventcomposed)
        - [`event.composedPath()`[#](https://nodejs.org/docs/latest/api/events.html#eventcomposedpath)](#eventcomposedpathhttpsnodejsorgdocslatestapieventshtmleventcomposedpath)
        - [`event.currentTarget`[#](https://nodejs.org/docs/latest/api/events.html#eventcurrenttarget)](#eventcurrenttargethttpsnodejsorgdocslatestapieventshtmleventcurrenttarget)
        - [`event.defaultPrevented`[#](https://nodejs.org/docs/latest/api/events.html#eventdefaultprevented)](#eventdefaultpreventedhttpsnodejsorgdocslatestapieventshtmleventdefaultprevented)
        - [`event.eventPhase`[#](https://nodejs.org/docs/latest/api/events.html#eventeventphase)](#eventeventphasehttpsnodejsorgdocslatestapieventshtmleventeventphase)
        - [`event.initEvent(type[, bubbles[, cancelable]])`[#](https://nodejs.org/docs/latest/api/events.html#eventiniteventtype-bubbles-cancelable)](#eventiniteventtype-bubbles-cancelablehttpsnodejsorgdocslatestapieventshtmleventiniteventtype-bubbles-cancelable)
        - [`event.isTrusted`[#](https://nodejs.org/docs/latest/api/events.html#eventistrusted)](#eventistrustedhttpsnodejsorgdocslatestapieventshtmleventistrusted)
        - [`event.preventDefault()`[#](https://nodejs.org/docs/latest/api/events.html#eventpreventdefault)](#eventpreventdefaulthttpsnodejsorgdocslatestapieventshtmleventpreventdefault)
        - [`event.returnValue`[#](https://nodejs.org/docs/latest/api/events.html#eventreturnvalue)](#eventreturnvaluehttpsnodejsorgdocslatestapieventshtmleventreturnvalue)
        - [`event.srcElement`[#](https://nodejs.org/docs/latest/api/events.html#eventsrcelement)](#eventsrcelementhttpsnodejsorgdocslatestapieventshtmleventsrcelement)
        - [`event.stopImmediatePropagation()`[#](https://nodejs.org/docs/latest/api/events.html#eventstopimmediatepropagation)](#eventstopimmediatepropagationhttpsnodejsorgdocslatestapieventshtmleventstopimmediatepropagation)
        - [`event.stopPropagation()`[#](https://nodejs.org/docs/latest/api/events.html#eventstoppropagation)](#eventstoppropagationhttpsnodejsorgdocslatestapieventshtmleventstoppropagation)
        - [`event.target`[#](https://nodejs.org/docs/latest/api/events.html#eventtarget)](#eventtargethttpsnodejsorgdocslatestapieventshtmleventtarget)
        - [`event.timeStamp`[#](https://nodejs.org/docs/latest/api/events.html#eventtimestamp)](#eventtimestamphttpsnodejsorgdocslatestapieventshtmleventtimestamp)
        - [`event.type`[#](https://nodejs.org/docs/latest/api/events.html#eventtype)](#eventtypehttpsnodejsorgdocslatestapieventshtmleventtype)
      - [Class: `EventTarget`[#](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)](#class-eventtargethttpsnodejsorgdocslatestapieventshtmlclass-eventtarget)
    - [`eventTarget.addEventListener(type, listener[, options])`](#eventtargetaddeventlistenertype-listener-options)
        - [`eventTarget.dispatchEvent(event)`[#](https://nodejs.org/docs/latest/api/events.html#eventtargetdispatcheventevent)](#eventtargetdispatcheventeventhttpsnodejsorgdocslatestapieventshtmleventtargetdispatcheventevent)
        - [`eventTarget.removeEventListener(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#eventtargetremoveeventlistenertype-listener-options)](#eventtargetremoveeventlistenertype-listener-optionshttpsnodejsorgdocslatestapieventshtmleventtargetremoveeventlistenertype-listener-options)
      - [클래스: `CustomEvent`[#](https://nodejs.org/docs/latest/api/events.html#class-customevent)](#클래스-customeventhttpsnodejsorgdocslatestapieventshtmlclass-customevent)
        - [`event.detail`[#](https://nodejs.org/docs/latest/api/events.html#eventdetail)](#eventdetailhttpsnodejsorgdocslatestapieventshtmleventdetail)
      - [클래스: `NodeEventTarget`[#](https://nodejs.org/docs/latest/api/events.html#class-nodeeventtarget)](#클래스-nodeeventtargethttpsnodejsorgdocslatestapieventshtmlclass-nodeeventtarget)
        - [`nodeEventTarget.addListener(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetaddlistenertype-listener)](#nodeeventtargetaddlistenertype-listenerhttpsnodejsorgdocslatestapieventshtmlnodeeventtargetaddlistenertype-listener)
        - [`nodeEventTarget.emit(type, arg)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetemittype-arg)](#nodeeventtargetemittype-arghttpsnodejsorgdocslatestapieventshtmlnodeeventtargetemittype-arg)
        - [`nodeEventTarget.eventNames()`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargeteventnames)](#nodeeventtargeteventnameshttpsnodejsorgdocslatestapieventshtmlnodeeventtargeteventnames)
        - [`nodeEventTarget.listenerCount(type)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetlistenercounttype)](#nodeeventtargetlistenercounttypehttpsnodejsorgdocslatestapieventshtmlnodeeventtargetlistenercounttype)
        - [`nodeEventTarget.setMaxListeners(n)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetsetmaxlistenersn)](#nodeeventtargetsetmaxlistenersnhttpsnodejsorgdocslatestapieventshtmlnodeeventtargetsetmaxlistenersn)
        - [`nodeEventTarget.getMaxListeners()`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetgetmaxlisteners)](#nodeeventtargetgetmaxlistenershttpsnodejsorgdocslatestapieventshtmlnodeeventtargetgetmaxlisteners)
        - [`nodeEventTarget.off(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetofftype-listener-options)](#nodeeventtargetofftype-listener-optionshttpsnodejsorgdocslatestapieventshtmlnodeeventtargetofftype-listener-options)
        - [`nodeEventTarget.on(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetontype-listener)](#nodeeventtargetontype-listenerhttpsnodejsorgdocslatestapieventshtmlnodeeventtargetontype-listener)
        - [`nodeEventTarget.once(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetoncetype-listener)](#nodeeventtargetoncetype-listenerhttpsnodejsorgdocslatestapieventshtmlnodeeventtargetoncetype-listener)
        - [`nodeEventTarget.removeAllListeners([type])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetremovealllistenerstype)](#nodeeventtargetremovealllistenerstypehttpsnodejsorgdocslatestapieventshtmlnodeeventtargetremovealllistenerstype)
        - [`nodeEventTarget.removeListener(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetremovelistenertype-listener-options)](#nodeeventtargetremovelistenertype-listener-optionshttpsnodejsorgdocslatestapieventshtmlnodeeventtargetremovelistenertype-listener-options)

# 이벤트

**소스 코드:** [lib/events.js](https://github.com/nodejs/node/blob/v23.5.0/lib/events.js)

Node.js 코어 API의 상당 부분은 관용적인 비동기 이벤트 기반 아키텍처를 중심으로 구축되어 있습니다. 이 아키텍처에서는 특정 종류의 객체(이하 "이미터")가 이름이 붙은 이벤트를 발생시키고, 이 이벤트는 `Function` 객체(이하 "리스너")를 호출하게 합니다.

예를 들어, [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver) 객체는 피어가 연결될 때마다 이벤트를 발생시키고, [`fs.ReadStream`](https://nodejs.org/docs/latest/api/fs.html#class-fsreadstream) 객체는 파일이 열릴 때 이벤트를 발생시킵니다. 또한 [스트림](https://nodejs.org/docs/latest/api/stream.html)은 읽을 데이터가 있을 때마다 이벤트를 발생시킵니다.

이벤트를 발생시키는 모든 객체는 `EventEmitter` 클래스의 인스턴스입니다. 이러한 객체는 `eventEmitter.on()` 함수를 제공하며, 이 함수를 통해 객체가 발생시키는 이름이 붙은 이벤트에 하나 이상의 함수를 연결할 수 있습니다. 일반적으로 이벤트 이름은 카멜 케이스 문자열이지만, 유효한 JavaScript 프로퍼티 키라면 무엇이든 사용할 수 있습니다.

`EventEmitter` 객체가 이벤트를 발생시키면, 해당 이벤트에 연결된 모든 함수가 *동기적으로* 호출됩니다. 호출된 리스너가 반환한 값은 *무시되고* 버려집니다.

다음 예제는 단일 리스너를 가진 간단한 `EventEmitter` 인스턴스를 보여줍니다. `eventEmitter.on()` 메서드는 리스너를 등록하는 데 사용되고, `eventEmitter.emit()` 메서드는 이벤트를 트리거하는 데 사용됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
    console.log('이벤트가 발생했습니다!');
});
myEmitter.emit('event');
```


### 리스너에 인자와 `this` 전달하기

`eventEmitter.emit()` 메서드는 리스너 함수에 임의의 인자들을 전달할 수 있게 해줍니다. 일반 리스너 함수가 호출될 때, 표준 `this` 키워드는 의도적으로 리스너가 연결된 `EventEmitter` 인스턴스를 참조하도록 설정됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

myEmitter.on('event', function(a, b) {
    console.log(a, b, this, this === myEmitter);
    // 출력:
    // a b MyEmitter {
    //   _events: [Object: null prototype] { event: [Function (anonymous)] },
    //   _eventsCount: 1,
    //   _maxListeners: undefined,
    //   [Symbol(shapeMode)]: false,
    //   [Symbol(kCapture)]: false
    // } true
});

myEmitter.emit('event', 'a', 'b');
```

ES6 화살표 함수를 리스너로 사용할 수도 있지만, 이 경우 `this` 키워드는 더 이상 `EventEmitter` 인스턴스를 참조하지 않습니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

myEmitter.on('event', (a, b) => {
    console.log(a, b, this); // 출력: a b undefined
});

myEmitter.emit('event', 'a', 'b');
```


### 비동기 vs 동기

`EventEmitter`는 등록된 순서대로 모든 리스너를 동기적으로 호출합니다. 이렇게 하면 이벤트의 순서가 올바르게 유지되고, 경쟁 상태나 논리 오류를 방지할 수 있습니다. 필요에 따라 리스너 함수는 `setImmediate()`나 `process.nextTick()` 메서드를 사용해 비동기 모드로 전환할 수 있습니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

myEmitter.on('event', (a, b) => {
    setImmediate(() => {
        console.log('이것은 비동기적으로 실행됩니다');
    });
});

myEmitter.emit('event', 'a', 'b');
```


### 이벤트를 한 번만 처리하기

`eventEmitter.on()` 메서드를 사용하여 리스너를 등록하면, 해당 이벤트가 발생할 때마다 리스너가 호출됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
let m = 0;

myEmitter.on('event', () => {
    console.log(++m);
});

myEmitter.emit('event'); // 출력: 1
myEmitter.emit('event'); // 출력: 2
```

`eventEmitter.once()` 메서드를 사용하면, 특정 이벤트에 대해 최대 한 번만 호출되는 리스너를 등록할 수 있습니다. 이벤트가 발생하면 리스너가 등록 해제된 후 호출됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
let m = 0;

myEmitter.once('event', () => {
    console.log(++m);
});

myEmitter.emit('event'); // 출력: 1
myEmitter.emit('event'); // 무시됨
```


### 에러 이벤트

`EventEmitter` 인스턴스 내에서 에러가 발생하면, 일반적으로 `'error'` 이벤트가 발생합니다. 이는 Node.js에서 특별한 경우로 처리됩니다.

만약 `EventEmitter`에 `'error'` 이벤트를 위한 리스너가 하나도 등록되어 있지 않은 상태에서 `'error'` 이벤트가 발생하면, 에러가 던져지고 스택 트레이스가 출력된 후 Node.js 프로세스가 종료됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.emit('error', new Error('whoops!')); // 에러를 던지고 Node.js가 종료됨
```

Node.js 프로세스가 종료되는 것을 방지하기 위해 [`domain`](https://nodejs.org/docs/latest/api/domain.html) 모듈을 사용할 수 있습니다. (단, `node:domain` 모듈은 더 이상 사용되지 않습니다.)

최선의 방법으로, 항상 `'error'` 이벤트를 위한 리스너를 추가하는 것이 좋습니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('error', (err) => {
  console.error('whoops! there was an error');
});
myEmitter.emit('error', new Error('whoops!')); // 출력: whoops! there was an error
```

`events.errorMonitor` 심볼을 사용하여 리스너를 설치하면, 발생한 에러를 소비하지 않고도 `'error'` 이벤트를 모니터링할 수 있습니다.

```js
import { EventEmitter, errorMonitor } from 'node:events';

const myEmitter = new EventEmitter();
myEmitter.on(errorMonitor, (err) => {
  MyMonitoringTool.log(err);
});
myEmitter.emit('error', new Error('whoops!')); // 여전히 에러를 던지고 Node.js가 종료됨
```


### Promise의 거부(rejection) 캡처하기

이벤트 핸들러에서 `async` 함수를 사용하면 예외가 발생했을 때 처리되지 않은 거부(unhandled rejection)가 발생할 수 있어 문제가 됩니다.

```js
import { EventEmitter } from 'node:events';
const ee = new EventEmitter();
ee.on('something', async (value) => {
    throw new Error('kaboom');
});
```

`EventEmitter` 생성자에서 `captureRejections` 옵션을 사용하거나 전역 설정을 변경하면, `Promise`에 `.then(undefined, handler)` 핸들러가 설치됩니다. 이 핸들러는 예외를 비동기적으로 [`Symbol.for('nodejs.rejection')`](https://nodejs.org/docs/latest/api/events.html#emittersymbolfornodejsrejectionerr-eventname-args) 메서드로 라우팅합니다. 해당 메서드가 없으면 [`'error'`](https://nodejs.org/docs/latest/api/events.html#error-events) 이벤트 핸들러로 전달됩니다.

```js
import { EventEmitter } from 'node:events';
const ee1 = new EventEmitter({ captureRejections: true });
ee1.on('something', async (value) => {
    throw new Error('kaboom');
});
ee1.on('error', console.log);

const ee2 = new EventEmitter({ captureRejections: true });
ee2.on('something', async (value) => {
    throw new Error('kaboom');
});
ee2[Symbol.for('nodejs.rejection')] = console.log;
```

`events.captureRejections = true`로 설정하면 모든 새로운 `EventEmitter` 인스턴스의 기본값이 변경됩니다.

```js
import { EventEmitter } from 'node:events';
EventEmitter.captureRejections = true;
const ee1 = new EventEmitter();
ee1.on('something', async (value) => {
    throw new Error('kaboom');
});
ee1.on('error', console.log);
```

`captureRejections` 동작으로 생성된 `'error'` 이벤트는 무한 오류 루프를 방지하기 위해 catch 핸들러가 없습니다. 따라서 **`'error'` 이벤트 핸들러로 `async` 함수를 사용하지 않는 것**을 권장합니다.


### 클래스: `EventEmitter`[#](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`EventEmitter` 클래스는 `node:events` 모듈에서 정의되고 제공됩니다:

```js
import { EventEmitter } from 'node:events';
```

모든 `EventEmitter`는 새로운 리스너가 추가될 때 `'newListener'` 이벤트를 발생시키고, 기존 리스너가 제거될 때 `'removeListener'` 이벤트를 발생시킵니다.

이 클래스는 다음과 같은 옵션을 지원합니다:

-   `captureRejections` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 이 옵션은 [Promise 거부 자동 캡처](https://nodejs.org/docs/latest/api/events.html#capture-rejections-of-promises)를 활성화합니다. **기본값:** `false`.


#### 이벤트: `'newListener'`[#](https://nodejs.org/docs/latest/api/events.html#event-newlistener)

추가된 버전: v0.1.26

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 리스닝 중인 이벤트의 이름
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 이벤트 핸들러 함수

`EventEmitter` 인스턴스는 리스너가 내부 리스너 배열에 추가되기 *전에* 자체적으로 `'newListener'` 이벤트를 발생시킵니다.

`'newListener'` 이벤트에 등록된 리스너들은 이벤트 이름과 추가될 리스너에 대한 참조를 전달받습니다.

이 이벤트가 리스너가 추가되기 전에 발생한다는 사실은 미묘하지만 중요한 부작용을 가집니다: `'newListener'` 콜백 내에서 동일한 `name`에 등록된 *추가* 리스너들은 추가 중인 리스너 *앞에* 삽입됩니다.

```js
import { EventEmitter } from 'node:events';

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

// 무한 루프를 방지하기 위해 한 번만 실행
myEmitter.once('newListener', (event, listener) => {
    if (event === 'event') {
        // 새로운 리스너를 앞에 추가
        myEmitter.on('event', () => {
            console.log('B');
        });
    }
});

myEmitter.on('event', () => {
    console.log('A');
});

myEmitter.emit('event');
// 출력:
// B
// A
```


#### 이벤트: `'removeListener'`[#](https://nodejs.org/docs/latest/api/events.html#event-removelistener)

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 이벤트 이름
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 이벤트 핸들러 함수

`'removeListener'` 이벤트는 `listener`가 제거된 *이후*에 발생합니다.


#### `emitter.addListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteraddlistenereventname-listener)

추가된 버전: v0.1.26

- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
- `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

`emitter.on(eventName, listener)`의 별칭입니다.


#### `emitter.emit(eventName[, ...args])`[#](https://nodejs.org/docs/latest/api/events.html#emitteremiteventname-args)

추가된 버전: v0.1.26

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   `...args` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`eventName`으로 등록된 모든 리스너를 등록된 순서대로 동기적으로 호출합니다. 이때 제공된 인자를 각 리스너에 전달합니다.

이벤트에 리스너가 등록되어 있었다면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.

```javascript
import { EventEmitter } from 'node:events';

const myEmitter = new EventEmitter();

// 첫 번째 리스너
myEmitter.on('event', function firstListener() {
    console.log('Helloooo! first listener');
});

// 두 번째 리스너
myEmitter.on('event', function secondListener(arg1, arg2) {
    console.log(`event with parameters ${arg1}, ${arg2} in second listener`);
});

// 세 번째 리스너
myEmitter.on('event', function thirdListener(...args) {
    const parameters = args.join(', ');
    console.log(`event with parameters ${parameters} in third listener`);
});

console.log(myEmitter.listeners('event'));

myEmitter.emit('event', 1, 2, 3, 4, 5);

// 출력:
// [
//     [Function: firstListener],
//     [Function: secondListener],
//     [Function: thirdListener]
// ]
// Helloooo! first listener
// event with parameters 1, 2 in second listener
// event with parameters 1, 2, 3, 4, 5 in third listener
```


#### `emitter.eventNames()`[#](https://nodejs.org/docs/latest/api/events.html#emittereventnames)

추가된 버전: v6.0.0

-   반환값: [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

이벤트 에미터가 리스너를 등록한 이벤트 목록을 배열로 반환합니다. 배열의 값은 문자열 또는 `Symbol`입니다.

```javascript
import { EventEmitter } from 'node:events';
const myEE = new EventEmitter();
myEE.on('foo', () => {});
myEE.on('bar', () => {});
const sym = Symbol('symbol');
myEE.on(sym, () => {});
console.log(myEE.eventNames()); // 출력: [ 'foo', 'bar', Symbol(symbol) ]
```


#### `emitter.getMaxListeners()`[#](https://nodejs.org/docs/latest/api/events.html#emittergetmaxlisteners)

추가된 버전: v1.0.0

-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`EventEmitter`의 현재 최대 리스너 값을 반환합니다. 이 값은 [`emitter.setMaxListeners(n)`](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn)을 통해 설정되거나, 기본값인 [`events.defaultMaxListeners`](https://nodejs.org/docs/latest/api/events.html#eventsdefaultmaxlisteners)로 설정됩니다.


#### `emitter.listenerCount(eventName[, listener])`

- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)  
  리스닝 중인 이벤트의 이름
- `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)  
  이벤트 핸들러 함수
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  

`eventName`으로 지정된 이벤트를 리스닝 중인 리스너의 수를 반환합니다. `listener`가 제공되면, 해당 리스너가 이벤트의 리스너 목록에서 몇 번 발견되는지 반환합니다.


#### `emitter.listeners(eventName)`[#](https://nodejs.org/docs/latest/api/events.html#emitterlistenerseventname)

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   반환값: [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

`eventName`이라는 이벤트에 등록된 리스너 배열의 복사본을 반환합니다.

```js
server.on('connection', (stream) => {
    console.log('someone connected!');
});
console.log(util.inspect(server.listeners('connection')));
// 출력: [ [Function] ]
```


#### `emitter.off(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteroffeventname-listener)

추가된 버전: v10.0.0

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

[`emitter.removeListener()`](https://nodejs.org/docs/latest/api/events.html#emitterremovelistenereventname-listener)의 별칭입니다.


#### `emitter.on(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteroneventname-listener)

추가된 버전: v0.1.101

- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 이벤트의 이름.
- `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 콜백 함수.
- 반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`eventName`이라는 이벤트에 대한 리스너 배열의 끝에 `listener` 함수를 추가합니다. `listener`가 이미 추가되었는지 여부는 확인하지 않습니다. 동일한 `eventName`과 `listener` 조합으로 여러 번 호출하면 `listener`가 여러 번 추가되고 호출됩니다.

```js
server.on('connection', (stream) => { 
    console.log('someone connected!'); 
});
```

`EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.

기본적으로 이벤트 리스너는 추가된 순서대로 호출됩니다. `emitter.prependListener()` 메서드를 사용하면 리스너 배열의 맨 앞에 이벤트 리스너를 추가할 수 있습니다.

```js
import { EventEmitter } from 'node:events'; 
const myEE = new EventEmitter(); 
myEE.on('foo', () => console.log('a')); 
myEE.prependListener('foo', () => console.log('b')); 
myEE.emit('foo'); 
// 출력: 
// b 
// a
```


#### `emitter.once(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitteronceeventname-listener)

추가된 버전: v0.3.0

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 이벤트의 이름.
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 콜백 함수.
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`eventName`이라는 이벤트에 대해 **한 번만 실행되는** `listener` 함수를 추가합니다. `eventName`이 다음에 트리거될 때, 이 리스너는 제거된 후 호출됩니다.

```js
server.once('connection', (stream) => {
    console.log('아, 첫 번째 사용자가 접속했습니다!');
});
```

`EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.

기본적으로, 이벤트 리스너는 추가된 순서대로 호출됩니다. `emitter.prependOnceListener()` 메서드를 사용하면 리스너 배열의 맨 앞에 이벤트 리스너를 추가할 수 있습니다.

```js
import { EventEmitter } from 'node:events';
const myEE = new EventEmitter();
myEE.once('foo', () => console.log('a'));
myEE.prependOnceListener('foo', () => console.log('b'));
myEE.emit('foo');
// 출력:
// b
// a
```


#### `emitter.prependListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterprependlistenereventname-listener)

추가된 버전: v6.0.0

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 이벤트의 이름.
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 콜백 함수.
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`listener` 함수를 `eventName` 이벤트의 리스너 배열 **맨 앞**에 추가합니다. `listener`가 이미 추가되었는지 확인하지 않습니다. 동일한 `eventName`과 `listener` 조합으로 여러 번 호출하면 `listener`가 여러 번 추가되고 호출됩니다.

```js
server.prependListener('connection', (stream) => { 
    console.log('누군가 연결되었습니다!'); 
});
```

`EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.


#### `emitter.prependOnceListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterprependoncelistenereventname-listener)

추가된 버전: v6.0.0

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 이벤트의 이름.
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 콜백 함수.
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`eventName` 이벤트에 대한 **한 번만 실행되는** `listener` 함수를 리스너 배열의 **맨 앞**에 추가합니다. `eventName`이 다음에 트리거되면, 이 리스너는 제거된 후 실행됩니다.

```js
server.prependOnceListener('connection', (stream) => { 
    console.log('아, 첫 번째 사용자가 접속했습니다!'); 
});
```

`EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.


#### `emitter.removeAllListeners([eventName])`[#](https://nodejs.org/docs/latest/api/events.html#emitterremovealllistenerseventname)

추가된 버전: v0.1.26

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

지정된 `eventName`에 대한 모든 리스너를 제거합니다. 만약 `eventName`이 제공되지 않으면 모든 리스너를 제거합니다.

다른 곳에서 추가된 리스너를 제거하는 것은 좋지 않은 습관입니다. 특히 `EventEmitter` 인스턴스가 다른 컴포넌트나 모듈(예: 소켓이나 파일 스트림)에 의해 생성된 경우에는 더욱 그렇습니다.

이 메서드는 `EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.


#### `emitter.removeListener(eventName, listener)`[#](https://nodejs.org/docs/latest/api/events.html#emitterremovelistenereventname-listener)

추가된 버전: v0.1.26

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

지정된 `eventName`에 대한 리스너 배열에서 특정 `listener`를 제거합니다.

```js
const callback = (stream) => { 
    console.log('someone connected!'); 
}; 
server.on('connection', callback); 
// ... 
server.removeListener('connection', callback);
```

`removeListener()`는 리스너 배열에서 최대 하나의 리스너 인스턴스를 제거합니다. 만약 특정 `eventName`에 대해 리스너가 여러 번 추가되었다면, 각 인스턴스를 제거하기 위해 `removeListener()`를 여러 번 호출해야 합니다.

이벤트가 발생하면, 발생 시점에 연결된 모든 리스너가 순서대로 호출됩니다. 이는 이벤트 발생 후 마지막 리스너가 실행을 마치기 전에 `removeListener()` 또는 `removeAllListeners()`를 호출해도 진행 중인 `emit()`에서 리스너가 제거되지 않음을 의미합니다. 이후 이벤트는 예상대로 동작합니다.

```js
import { EventEmitter } from 'node:events'; 
class MyEmitter extends EventEmitter {} 
const myEmitter = new MyEmitter(); 
const callbackA = () => { 
    console.log('A'); 
    myEmitter.removeListener('event', callbackB); 
}; 
const callbackB = () => { 
    console.log('B'); 
}; 
myEmitter.on('event', callbackA); 
myEmitter.on('event', callbackB); 
// callbackA가 리스너 callbackB를 제거하지만, 여전히 호출됩니다. 
// 이벤트 발생 시점의 내부 리스너 배열 [callbackA, callbackB] 
myEmitter.emit('event'); 
// 출력: 
// A 
// B 
// callbackB가 이제 제거되었습니다. 
// 내부 리스너 배열 [callbackA] 
myEmitter.emit('event'); 
// 출력: 
// A
```

리스너는 내부 배열로 관리되기 때문에, 이 메서드를 호출하면 제거되는 리스너 이후에 등록된 리스너의 위치 인덱스가 변경됩니다. 이는 리스너가 호출되는 순서에는 영향을 미치지 않지만, `emitter.listeners()` 메서드로 반환된 리스너 배열의 복사본을 다시 생성해야 함을 의미합니다.

단일 함수가 하나의 이벤트에 대해 여러 번 핸들러로 추가된 경우(아래 예제와 같이), `removeListener()`는 가장 최근에 추가된 인스턴스를 제거합니다. 아래 예제에서는 `once('ping')` 리스너가 제거됩니다:

```js
import { EventEmitter } from 'node:events'; 
const ee = new EventEmitter(); 
function pong() { 
    console.log('pong'); 
} 
ee.on('ping', pong); 
ee.once('ping', pong); 
ee.removeListener('ping', pong); 
ee.emit('ping'); 
ee.emit('ping');
```

`EventEmitter`에 대한 참조를 반환하므로, 체이닝이 가능합니다.


#### `emitter.setMaxListeners(n)`[#](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn)

추가된 버전: v0.3.5

-   `n` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   반환값: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

기본적으로 `EventEmitter`는 특정 이벤트에 대해 10개 이상의 리스너가 추가되면 경고를 출력합니다. 이는 메모리 누수를 찾는 데 도움이 되는 유용한 기본 설정입니다. `emitter.setMaxListeners()` 메서드는 이 특정 `EventEmitter` 인스턴스에 대한 제한을 수정할 수 있게 해줍니다. 값을 `Infinity`(또는 `0`)로 설정하면 리스너의 수를 무제한으로 지정할 수 있습니다.

이 메서드는 `EventEmitter`에 대한 참조를 반환하므로, 메서드 체이닝이 가능합니다.


#### `emitter.rawListeners(eventName)`[#](https://nodejs.org/docs/latest/api/events.html#emitterrawlistenerseventname)

추가된 버전: v9.4.0

-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   반환값: [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

`eventName`이라는 이벤트에 대한 리스너 배열의 복사본을 반환합니다. 이 복사본에는 `.once()`와 같은 래퍼로 생성된 리스너도 포함됩니다.

```js
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();

emitter.once('log', () => console.log('log once'));

// `onceWrapper`라는 함수를 포함한 새로운 배열을 반환합니다.
// 이 함수는 `listener`라는 속성을 가지며, 위에서 바인딩된 원래 리스너를 포함합니다.
const listeners = emitter.rawListeners('log');
const logFnWrapper = listeners[0];

// 콘솔에 "log once"를 출력하고 `once` 이벤트를 해제하지 않습니다.
logFnWrapper.listener();

// 콘솔에 "log once"를 출력하고 리스너를 제거합니다.
logFnWrapper();

emitter.on('log', () => console.log('log persistently'));

// 위에서 `.on()`으로 바인딩된 단일 함수를 포함한 새로운 배열을 반환합니다.
const newListeners = emitter.rawListeners('log');

// "log persistently"를 두 번 출력합니다.
newListeners[0]();
emitter.emit('log');
```


#### `emitter[Symbol.for('nodejs.rejection')](err, eventName[, ...args])`

- `err` Error
- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
- `...args` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

`Symbol.for('nodejs.rejection')` 메서드는 이벤트를 발생시킬 때 Promise가 거부되고, 이벤트 발신자(emitter)에 [`captureRejections`](https://nodejs.org/docs/latest/api/events.html#capture-rejections-of-promises)가 활성화된 경우 호출됩니다. `Symbol.for('nodejs.rejection')` 대신 [`events.captureRejectionSymbol`](https://nodejs.org/docs/latest/api/events.html#eventscapturerejectionsymbol)을 사용할 수도 있습니다.

```javascript
import { EventEmitter, captureRejectionSymbol } from 'node:events';

class MyClass extends EventEmitter {
    constructor() {
        super({ captureRejections: true });
    }

    [captureRejectionSymbol](err, event, ...args) {
        console.log('rejection happened for', event, 'with', err, ...args);
        this.destroy(err);
    }

    destroy(err) {
        // 여기서 리소스를 정리합니다.
    }
}
```


### `events.defaultMaxListeners`[#](https://nodejs.org/docs/latest/api/events.html#eventsdefaultmaxlisteners)

추가된 버전: v0.11.2

기본적으로, 단일 이벤트에 대해 최대 `10`개의 리스너를 등록할 수 있습니다. 이 제한은 [`emitter.setMaxListeners(n)`](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn) 메서드를 사용하여 개별 `EventEmitter` 인스턴스에 대해 변경할 수 있습니다. *모든* `EventEmitter` 인스턴스에 대한 기본값을 변경하려면 `events.defaultMaxListeners` 속성을 사용할 수 있습니다. 이 값이 양수가 아닌 경우, `RangeError`가 발생합니다.

`events.defaultMaxListeners`를 설정할 때 주의해야 합니다. 이 변경은 변경 전에 생성된 `EventEmitter` 인스턴스를 포함하여 *모든* `EventEmitter` 인스턴스에 영향을 미치기 때문입니다. 그러나 [`emitter.setMaxListeners(n)`](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn)을 호출하면 `events.defaultMaxListeners`보다 우선 적용됩니다.

이것은 엄격한 제한이 아닙니다. `EventEmitter` 인스턴스는 더 많은 리스너를 추가할 수 있지만, "가능한 EventEmitter 메모리 누수"가 감지되었다는 경고를 stderr에 출력합니다. 단일 `EventEmitter`에 대해 `emitter.getMaxListeners()`와 `emitter.setMaxListeners()` 메서드를 사용하여 이 경고를 일시적으로 피할 수 있습니다:

`defaultMaxListeners`는 `AbortSignal` 인스턴스에는 영향을 미치지 않습니다. 개별 `AbortSignal` 인스턴스에 대해 [`emitter.setMaxListeners(n)`](https://nodejs.org/docs/latest/api/events.html#emittersetmaxlistenersn)을 사용하여 경고 제한을 설정할 수 있지만, 기본적으로 `AbortSignal` 인스턴스는 경고를 표시하지 않습니다.

```js
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();
emitter.setMaxListeners(emitter.getMaxListeners() + 1);
emitter.once('event', () => {
    // 작업 수행
    emitter.setMaxListeners(Math.max(emitter.getMaxListeners() - 1, 0));
});
```

[`--trace-warnings`](https://nodejs.org/docs/latest/api/cli.html#--trace-warnings) 커맨드라인 플래그를 사용하여 이러한 경고에 대한 스택 트레이스를 표시할 수 있습니다.

발생한 경고는 [`process.on('warning')`](https://nodejs.org/docs/latest/api/process.html#event-warning)로 확인할 수 있으며, `emitter`, `type`, `count` 속성을 추가로 포함합니다. 이 속성들은 각각 이벤트 에미터 인스턴스, 이벤트 이름, 연결된 리스너의 수를 나타냅니다. `name` 속성은 `'MaxListenersExceededWarning'`으로 설정됩니다.


### `events.errorMonitor`[#](https://nodejs.org/docs/latest/api/events.html#eventserrormonitor)

추가된 버전: v13.6.0, v12.17.0

이 심볼은 `'error'` 이벤트를 모니터링하기 위한 리스너를 설치하는 데 사용됩니다. 이 심볼을 사용해 설치된 리스너는 일반적인 `'error'` 리스너가 호출되기 전에 호출됩니다.

이 심볼을 사용해 리스너를 설치해도 `'error'` 이벤트가 발생했을 때의 동작은 변하지 않습니다. 따라서 일반적인 `'error'` 리스너가 설치되어 있지 않으면 프로세스는 여전히 종료됩니다.


### `events.getEventListeners(emitterOrTarget, eventName)`[#](https://nodejs.org/docs/latest/api/events.html#eventsgeteventlistenersemitterortarget-eventname)

추가된 버전: v15.2.0, v14.17.0

-   `emitterOrTarget` [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) | [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)
-   `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
-   반환값: [`<Function\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

`eventName`에 해당하는 이벤트 리스너 배열의 복사본을 반환합니다.

`EventEmitter`의 경우, 이 메서드는 `.listeners`를 호출한 것과 동일하게 동작합니다.

`EventTarget`의 경우, 이 메서드는 이벤트 타겟의 리스너를 가져올 수 있는 유일한 방법입니다. 이는 디버깅과 진단 목적으로 유용합니다.

```js
import { getEventListeners, EventEmitter } from 'node:events';

{
    const ee = new EventEmitter();
    const listener = () => console.log('Events are fun');
    ee.on('foo', listener);
    console.log(getEventListeners(ee, 'foo')); // [ [Function: listener] ]
}

{
    const et = new EventTarget();
    const listener = () => console.log('Events are fun');
    et.addEventListener('foo', listener);
    console.log(getEventListeners(et, 'foo')); // [ [Function: listener] ]
}
```


### `events.getMaxListeners(emitterOrTarget)`[#](https://nodejs.org/docs/latest/api/events.html#eventsgetmaxlistenersemitterortarget)

추가된 버전: v19.9.0, v18.17.0

-   `emitterOrTarget` [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) | [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)
-   반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

현재 설정된 최대 리스너 수를 반환합니다.

`EventEmitter`의 경우, 이 메서드는 `.getMaxListeners`를 직접 호출한 것과 동일하게 동작합니다.

`EventTarget`의 경우, 이 메서드는 이벤트 타겟의 최대 이벤트 리스너 수를 확인할 수 있는 유일한 방법입니다. 만약 단일 `EventTarget`에 등록된 이벤트 핸들러 수가 설정된 최대값을 초과하면, `EventTarget`은 경고 메시지를 출력합니다.

```js
import { getMaxListeners, setMaxListeners, EventEmitter } from 'node:events';

{
    const ee = new EventEmitter();
    console.log(getMaxListeners(ee)); // 10
    setMaxListeners(11, ee);
    console.log(getMaxListeners(ee)); // 11
}

{
    const et = new EventTarget();
    console.log(getMaxListeners(et)); // 10
    setMaxListeners(11, et);
    console.log(getMaxListeners(et)); // 11
}
```


### `events.once(emitter, name[, options])`

- `emitter` [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)
- `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) 이벤트 대기를 취소하는 데 사용할 수 있습니다.
- 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

`EventEmitter`가 특정 이벤트를 발생시킬 때 이행되거나, 대기 중에 `'error'` 이벤트가 발생하면 거부되는 `Promise`를 생성합니다. 이 `Promise`는 해당 이벤트에 전달된 모든 인자를 배열로 해결합니다.

이 메서드는 웹 플랫폼의 [EventTarget](https://dom.spec.whatwg.org/#interface-eventtarget) 인터페이스와도 호환되도록 의도적으로 일반적으로 설계되었습니다. `EventTarget`은 특별한 `'error'` 이벤트 의미를 가지지 않으며, `'error'` 이벤트를 수신하지 않습니다.

```javascript
import { once, EventEmitter } from 'node:events';
import process from 'node:process';

const ee = new EventEmitter();

process.nextTick(() => {
  ee.emit('myevent', 42);
});

const [value] = await once(ee, 'myevent');
console.log(value);

const err = new Error('kaboom');
process.nextTick(() => {
  ee.emit('error', err);
});

try {
  await once(ee, 'myevent');
} catch (err) {
  console.error('error happened', err);
}
```

`'error'` 이벤트에 대한 특별한 처리는 `events.once()`가 다른 이벤트를 기다릴 때만 적용됩니다. 만약 `events.once()`가 `'error'` 이벤트 자체를 기다리는 데 사용된다면, 이는 특별한 처리가 없는 일반 이벤트로 취급됩니다:

```javascript
import { EventEmitter, once } from 'node:events';

const ee = new EventEmitter();

once(ee, 'error')
  .then(([err]) => console.log('ok', err.message))
  .catch((err) => console.error('error', err.message));

ee.emit('error', new Error('boom'));
// 출력: ok boom
```

[`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)을 사용하여 이벤트 대기를 취소할 수 있습니다:

```javascript
import { EventEmitter, once } from 'node:events';

const ee = new EventEmitter();
const ac = new AbortController();

async function foo(emitter, event, signal) {
  try {
    await once(emitter, event, { signal });
    console.log('event emitted!');
  } catch (error) {
    if (error.name === 'AbortError') {
      console.error('Waiting for the event was canceled!');
    } else {
      console.error('There was an error', error.message);
    }
  }
}

foo(ee, 'foo', ac.signal);
ac.abort();
// 출력: Waiting for the event was canceled!
```


#### `process.nextTick()`에서 발생하는 여러 이벤트를 기다릴 때 주의사항

`events.once()` 함수를 사용하여 `process.nextTick()` 작업의 동일한 배치에서 발생하는 여러 이벤트를 기다릴 때 주의해야 할 특이한 경우가 있습니다. 특히, `process.nextTick()` 큐가 `Promise` 마이크로태스크 큐보다 먼저 처리되며, `EventEmitter`가 모든 이벤트를 동기적으로 발생시키기 때문에 `events.once()`가 이벤트를 놓칠 수 있습니다.

```js
import { EventEmitter, once } from 'node:events';
import process from 'node:process';

const myEE = new EventEmitter();

async function foo() {
    await once(myEE, 'bar');
    console.log('bar'); 
    // 이 Promise는 절대 resolve되지 않습니다. 
    // 'foo' 이벤트가 Promise가 생성되기 전에 이미 발생했기 때문입니다.
    await once(myEE, 'foo');
    console.log('foo');
}

process.nextTick(() => {
    myEE.emit('bar');
    myEE.emit('foo');
});

foo().then(() => console.log('done'));
```

두 이벤트를 모두 잡으려면, 각각의 Promise를 기다리기 전에 미리 생성해야 합니다. 그런 다음 `Promise.all()`, `Promise.race()`, 또는 `Promise.allSettled()`를 사용할 수 있습니다.

```js
import { EventEmitter, once } from 'node:events';
import process from 'node:process';

const myEE = new EventEmitter();

async function foo() {
    await Promise.all([once(myEE, 'bar'), once(myEE, 'foo')]);
    console.log('foo', 'bar');
}

process.nextTick(() => {
    myEE.emit('bar');
    myEE.emit('foo');
});

foo().then(() => console.log('done'));
```


### `events.captureRejections`[#](https://nodejs.org/docs/latest/api/events.html#eventscapturerejections)

**값:** [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

새로 생성되는 모든 `EventEmitter` 객체의 기본 `captureRejections` 옵션을 변경합니다.


### `events.captureRejectionSymbol`

값: `Symbol.for('nodejs.rejection')`

커스텀 **rejection handler**를 작성하는 방법은 [여기](https://nodejs.org/docs/latest/api/events.html#emittersymbolfornodejsrejectionerr-eventname-args)를 참고하세요.


### `events.listenerCount(emitter, eventName)`[#](https://nodejs.org/docs/latest/api/events.html#eventslistenercountemitter-eventname)

추가된 버전: v0.9.12  
사용 중단(deprecated) 버전: v3.2.0

- `emitter` [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter): 쿼리할 이벤트 에미터
- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type): 이벤트 이름

이 클래스 메서드는 주어진 `emitter`에 등록된 `eventName`에 대한 리스너의 수를 반환합니다.

```js
import { EventEmitter, listenerCount } from 'node:events';

const myEmitter = new EventEmitter();
myEmitter.on('event', () => {});
myEmitter.on('event', () => {});

console.log(listenerCount(myEmitter, 'event')); // 출력: 2
```


### `events.on(emitter, eventName[, options])`[#](https://nodejs.org/docs/latest/api/events.html#eventsonemitter-eventname-options)

- `emitter` [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)
- `eventName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<symbol>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Symbol_type) 리스닝할 이벤트의 이름
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) 이벤트 대기를 취소하는 데 사용할 수 있음
  - `close` - [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 반복을 종료할 이벤트 이름들
  - `highWaterMark` - [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `Number.MAX_SAFE_INTEGER` 상위 워터마크. 버퍼링된 이벤트의 크기가 이 값을 초과할 때마다 emitter가 일시 중지됨. `pause()`와 `resume()` 메서드를 구현한 emitter에서만 지원됨
  - `lowWaterMark` - [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `1` 하위 워터마크. 버퍼링된 이벤트의 크기가 이 값보다 낮을 때마다 emitter가 재개됨. `pause()`와 `resume()` 메서드를 구현한 emitter에서만 지원됨
- 반환값: [`<AsyncIterator>`](https://tc39.github.io/ecma262/#sec-asynciterator-interface) `emitter`가 방출하는 `eventName` 이벤트를 반복함

```js
import { on, EventEmitter } from 'node:events';
import process from 'node:process';

const ee = new EventEmitter();

// 나중에 이벤트 방출
process.nextTick(() => {
  ee.emit('foo', 'bar');
  ee.emit('foo', 42);
});

for await (const event of on(ee, 'foo')) {
  // 이 내부 블록의 실행은 동기적이며, 한 번에 하나의 이벤트를 처리함
  // (await가 있더라도). 동시 실행이 필요한 경우 사용하지 마세요.
  console.log(event); // ['bar'] [42] 출력
}
// 여기는 도달할 수 없음
```

`eventName` 이벤트를 반복하는 `AsyncIterator`를 반환합니다. `EventEmitter`가 `'error'`를 방출하면 예외를 던집니다. 루프를 종료할 때 모든 리스너를 제거합니다. 각 반복에서 반환된 `value`는 방출된 이벤트 인자들로 구성된 배열입니다.

[`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)을 사용하여 이벤트 대기를 취소할 수 있습니다:

```js
import { on, EventEmitter } from 'node:events';
import process from 'node:process';

const ac = new AbortController();

(async () => {
  const ee = new EventEmitter();

  // 나중에 이벤트 방출
  process.nextTick(() => {
    ee.emit('foo', 'bar');
    ee.emit('foo', 42);
  });

  for await (const event of on(ee, 'foo', { signal: ac.signal })) {
    // 이 내부 블록의 실행은 동기적이며, 한 번에 하나의 이벤트를 처리함
    // (await가 있더라도). 동시 실행이 필요한 경우 사용하지 마세요.
    console.log(event); // ['bar'] [42] 출력
  }
  // 여기는 도달할 수 없음
})();

process.nextTick(() => ac.abort());
```


### `events.setMaxListeners(n[, ...eventTargets])`[#](https://nodejs.org/docs/latest/api/events.html#eventssetmaxlistenersn-eventtargets)

추가된 버전: v15.4.0

-   `n` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 음수가 아닌 숫자. `EventTarget` 이벤트당 최대 리스너 수.
-   `...eventsTargets` [`<EventTarget\[\]>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) | [`<EventEmitter\[\]>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) 0개 이상의 [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) 또는 [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) 인스턴스. 아무것도 지정하지 않으면 `n`은 새로 생성된 모든 [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) 및 [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) 객체의 기본 최대값으로 설정된다.

```js
import { setMaxListeners, EventEmitter } from 'node:events';

const target = new EventTarget();
const emitter = new EventEmitter();

setMaxListeners(5, target, emitter);
```


### `events.addAbortListener(signal, listener)`[#](https://nodejs.org/docs/latest/api/events.html#eventsaddabortlistenersignal-listener)

추가된 버전: v20.5.0, v18.18.0

-   `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
-   반환값: [`<Disposable>`](https://tc39.es/proposal-explicit-resource-management/#sec-disposable-interface) `abort` 리스너를 제거하는 Disposable 객체

제공된 `signal`에서 `abort` 이벤트를 한 번만 수신합니다.

`abort` 이벤트를 수신하는 것은 안전하지 않으며, 리소스 누수로 이어질 수 있습니다. 이는 다른 제3자가 `signal`을 사용하여 [`e.stopImmediatePropagation()`](https://nodejs.org/docs/latest/api/events.html#eventstopimmediatepropagation)을 호출할 수 있기 때문입니다. Node.js는 웹 표준을 위반할 수 없어 이 문제를 해결할 수 없습니다. 또한, 기존 API는 리스너를 제거하는 것을 잊기 쉽게 만듭니다.

이 API는 `stopImmediatePropagation`이 리스너 실행을 방해하지 않도록 하여, Node.js API에서 `AbortSignal`을 안전하게 사용할 수 있도록 해줍니다.

더 쉽게 구독을 해제할 수 있도록 Disposable 객체를 반환합니다.

```js
import { addAbortListener } from 'node:events';

function example(signal) {
    let disposable;
    try {
        signal.addEventListener('abort', (e) => e.stopImmediatePropagation());
        disposable = addAbortListener(signal, (e) => {
            // signal이 중단될 때 수행할 작업
        });
    } finally {
        disposable?.[Symbol.dispose]();
    }
}
```


### 클래스: `events.EventEmitterAsyncResource extends EventEmitter`[#](https://nodejs.org/docs/latest/api/events.html#class-eventseventemitterasyncresource-extends-eventemitter)

추가된 버전: v17.4.0, v16.14.0

`EventEmitter`와 [`<AsyncResource>`](https://nodejs.org/docs/latest/api/async_hooks.html#class-asyncresource)를 통합하여 수동으로 비동기 추적이 필요한 `EventEmitter`를 위한 클래스입니다. 특히, `events.EventEmitterAsyncResource` 인스턴스에서 발생하는 모든 이벤트는 해당 [비동기 컨텍스트](https://nodejs.org/docs/latest/api/async_context.html) 내에서 실행됩니다.

```js
import { EventEmitterAsyncResource, EventEmitter } from 'node:events';
import { notStrictEqual, strictEqual } from 'node:assert';
import { executionAsyncId, triggerAsyncId } from 'node:async_hooks';

// 비동기 추적 도구는 이를 'Q'로 식별합니다.
const ee1 = new EventEmitterAsyncResource({ name: 'Q' });

// 'foo' 리스너는 EventEmitter의 비동기 컨텍스트 내에서 실행됩니다.
ee1.on('foo', () => {
    strictEqual(executionAsyncId(), ee1.asyncId);
    strictEqual(triggerAsyncId(), ee1.triggerAsyncId);
});

const ee2 = new EventEmitter();

// 일반 EventEmitter의 'foo' 리스너는 비동기 컨텍스트를 추적하지 않으므로,
// emit()과 동일한 비동기 컨텍스트에서 실행됩니다.
ee2.on('foo', () => {
    notStrictEqual(executionAsyncId(), ee2.asyncId);
    notStrictEqual(triggerAsyncId(), ee2.triggerAsyncId);
});

Promise.resolve().then(() => {
    ee1.emit('foo');
    ee2.emit('foo');
});
```

`EventEmitterAsyncResource` 클래스는 `EventEmitter`와 `AsyncResource`의 메서드와 옵션을 동일하게 사용합니다.


#### `new events.EventEmitterAsyncResource([options])`

- `options` [`<Object>`]
    - `captureRejections` [`<boolean>`] Promise 거부를 자동으로 캡처할지 여부를 설정합니다. **기본값:** `false`.
    - `name` [`<string>`] 비동기 이벤트의 타입을 지정합니다. **기본값:** [`new.target.name`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new.target).
    - `triggerAsyncId` [`<number>`] 이 비동기 이벤트를 생성한 실행 컨텍스트의 ID를 지정합니다. **기본값:** `executionAsyncId()`.
    - `requireManualDestroy` [`<boolean>`] `true`로 설정하면, 객체가 가비지 컬렉션될 때 `emitDestroy`를 비활성화합니다. 일반적으로 이 설정은 필요하지 않습니다 (`emitDestroy`를 수동으로 호출하는 경우에도). 하지만 리소스의 `asyncId`를 가져와서 민감한 API의 `emitDestroy`를 호출할 때는 이 설정이 필요합니다. `false`로 설정하면, 가비지 컬렉션 시 `emitDestroy` 호출은 적어도 하나의 활성 `destroy` 훅이 있을 때만 발생합니다. **기본값:** `false`.


#### `eventemitterasyncresource.asyncId`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourceasyncid)

-   타입: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 리소스에 할당된 고유한 `asyncId`입니다.


#### `eventemitterasyncresource.asyncResource`

- 타입: 기본 [`<AsyncResource>`](https://nodejs.org/docs/latest/api/async_hooks.html#class-asyncresource)

반환된 `AsyncResource` 객체는 이 `EventEmitterAsyncResource`에 대한 참조를 제공하는 추가적인 `eventEmitter` 속성을 가지고 있습니다.


#### `eventemitterasyncresource.emitDestroy()`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourceemitdestroy)

모든 `destroy` 훅을 호출합니다. 이 메서드는 **반드시 한 번만** 호출해야 합니다. 두 번 이상 호출하면 에러가 발생합니다. 이 메서드는 **수동으로 호출해야 합니다**. 만약 리소스가 가비지 컬렉터(GC)에 의해 수집되면 `destroy` 훅이 호출되지 않습니다.


#### `eventemitterasyncresource.triggerAsyncId`[#](https://nodejs.org/docs/latest/api/events.html#eventemitterasyncresourcetriggerasyncid)

-   타입: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `AsyncResource` 생성자에 전달된 `triggerAsyncId`와 동일한 값입니다.


### `EventTarget`과 `Event` API[#](https://nodejs.org/docs/latest/api/events.html#eventtarget-and-event-api)

`EventTarget`과 `Event` 객체는 Node.js에서 제공하는 특수 구현체로, [`EventTarget` Web API](https://dom.spec.whatwg.org/#eventtarget)를 기반으로 합니다. 이 API는 Node.js의 일부 코어 API에서 사용됩니다.

```js
const target = new EventTarget();
target.addEventListener('foo', (event) => {
    console.log('foo 이벤트가 발생했습니다!');
});
```


#### Node.js `EventTarget` vs. DOM `EventTarget`

Node.js의 `EventTarget`과 [DOM `EventTarget` Web API](https://dom.spec.whatwg.org/#eventtarget) 사이에는 두 가지 주요 차이점이 있습니다:

1. **계층 구조와 이벤트 전파**: DOM `EventTarget` 인스턴스는 계층적일 수 있지만, Node.js에서는 계층 구조와 이벤트 전파 개념이 없습니다. 즉, `EventTarget`에 전달된 이벤트는 각각 자신의 핸들러를 가질 수 있는 중첩된 대상 객체들의 계층을 통해 전파되지 않습니다.

2. **비동기 이벤트 리스너 처리**: Node.js `EventTarget`에서 이벤트 리스너가 비동기 함수이거나 `Promise`를 반환할 때, 반환된 `Promise`가 거부되면 해당 거부가 동기적으로 오류를 던지는 리스너와 동일한 방식으로 자동으로 캡처되고 처리됩니다. 자세한 내용은 [`EventTarget` 오류 처리](https://nodejs.org/docs/latest/api/events.html#eventtarget-error-handling)를 참조하세요.


#### `NodeEventTarget` vs. `EventEmitter`

`NodeEventTarget` 객체는 `EventEmitter` API의 수정된 부분 집합을 구현하여 특정 상황에서 `EventEmitter`를 *흉내 내도록* 설계되었습니다. 하지만 `NodeEventTarget`은 `EventEmitter`의 인스턴스가 아니며, 대부분의 경우 `EventEmitter` 대신 사용할 수 없습니다.

1. `EventEmitter`와 달리, 특정 `listener`는 각 이벤트 `type`당 최대 한 번만 등록할 수 있습니다. 여러 번 등록하려고 해도 무시됩니다.
2. `NodeEventTarget`은 `EventEmitter` API 전체를 흉내 내지 않습니다. 특히 `prependListener()`, `prependOnceListener()`, `rawListeners()`, `errorMonitor` API는 지원하지 않습니다. 또한 `'newListener'`와 `'removeListener'` 이벤트도 발생하지 않습니다.
3. `NodeEventTarget`은 `'error'` 타입의 이벤트에 대해 특별한 기본 동작을 구현하지 않습니다.
4. `NodeEventTarget`은 모든 이벤트 타입에 대해 `EventListener` 객체와 함수를 핸들러로 지원합니다.


#### 이벤트 리스너

이벤트 `타입`에 등록된 이벤트 리스너는 자바스크립트 함수이거나 `handleEvent` 프로퍼티를 가진 객체일 수 있습니다. 이 프로퍼티의 값은 함수여야 합니다.

어떤 경우든, 핸들러 함수는 `eventTarget.dispatchEvent()` 함수에 전달된 `event` 인자와 함께 호출됩니다.

비동기 함수도 이벤트 리스너로 사용할 수 있습니다. 만약 비동기 핸들러 함수가 거부(reject)되면, 이 거부는 [`EventTarget` 오류 처리](https://nodejs.org/docs/latest/api/events.html#eventtarget-error-handling)에 설명된 대로 캡처되고 처리됩니다.

하나의 핸들러 함수에서 발생한 오류는 다른 핸들러들이 호출되는 것을 막지 않습니다.

핸들러 함수의 반환 값은 무시됩니다.

핸들러는 항상 추가된 순서대로 호출됩니다.

핸들러 함수는 `event` 객체를 변경할 수 있습니다.

```js
function handler1(event) {
    console.log(event.type); // 'foo' 출력
    event.a = 1;
}

async function handler2(event) {
    console.log(event.type); // 'foo' 출력
    console.log(event.a); // 1 출력
}

const handler3 = {
    handleEvent(event) {
        console.log(event.type); // 'foo' 출력
    },
};

const handler4 = {
    async handleEvent(event) {
        console.log(event.type); // 'foo' 출력
    },
};

const target = new EventTarget();
target.addEventListener('foo', handler1);
target.addEventListener('foo', handler2);
target.addEventListener('foo', handler3);
target.addEventListener('foo', handler4, { once: true });
```


#### `EventTarget` 오류 처리[#](https://nodejs.org/docs/latest/api/events.html#eventtarget-error-handling)

등록된 이벤트 리스너가 오류를 던지거나(또는 거부된 Promise를 반환하면), 기본적으로 이 오류는 `process.nextTick()`에서 처리되지 않은 예외로 간주됩니다. 이는 `EventTarget`에서 처리되지 않은 예외가 기본적으로 Node.js 프로세스를 종료시킨다는 것을 의미합니다.

이벤트 리스너 내에서 오류를 던져도 다른 등록된 핸들러가 호출되는 것을 막지는 않습니다.

`EventTarget`은 `EventEmitter`와 달리 `'error'` 타입 이벤트에 대한 특별한 기본 처리를 구현하지 않습니다.

현재 오류는 `process.on('uncaughtException')`에 도달하기 전에 먼저 `process.on('error')` 이벤트로 전달됩니다. 이 동작은 더 이상 사용되지 않으며, 향후 릴리스에서 `EventTarget`을 다른 Node.js API와 일치시키기 위해 변경될 예정입니다. `process.on('error')` 이벤트에 의존하는 코드는 새로운 동작에 맞게 수정해야 합니다.


#### 클래스: `Event`[#](https://nodejs.org/docs/latest/api/events.html#class-event)

`Event` 객체는 [`Event` Web API](https://dom.spec.whatwg.org/#event)를 기반으로 만들어졌습니다. 이 객체의 인스턴스는 Node.js 내부에서 생성됩니다.


##### `event.bubbles`[#](https://nodejs.org/docs/latest/api/events.html#eventbubbles)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 항상 `false`를 반환합니다.

이 속성은 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.cancelBubble`[#](https://nodejs.org/docs/latest/api/events.html#eventcancelbubble)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`true`로 설정하면 `event.stopPropagation()`과 동일한 기능을 합니다. Node.js에서는 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.cancelable`[#](https://nodejs.org/docs/latest/api/events.html#eventcancelable)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    이벤트가 `cancelable` 옵션으로 생성되었다면 `true`를 반환합니다.


##### `event.composed`[#](https://nodejs.org/docs/latest/api/events.html#eventcomposed)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 항상 `false`를 반환합니다.

이 속성은 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.composedPath()`[#](https://nodejs.org/docs/latest/api/events.html#eventcomposedpath)

추가된 버전: v14.5.0

이 메서드는 현재 `EventTarget`을 유일한 항목으로 포함하는 배열을 반환합니다. 만약 이벤트가 전달되지 않았다면 빈 배열을 반환합니다. 이 기능은 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.currentTarget`[#](https://nodejs.org/docs/latest/api/events.html#eventcurrenttarget)

추가된 버전: v14.5.0

-   타입: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) 이벤트를 발생시키는 `EventTarget`입니다.

`event.target`의 별칭입니다.


##### `event.defaultPrevented`[#](https://nodejs.org/docs/latest/api/events.html#eventdefaultprevented)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`cancelable`이 `true`이고 `event.preventDefault()`가 호출된 경우 `true`가 됩니다.


##### `event.eventPhase`[#](https://nodejs.org/docs/latest/api/events.html#eventeventphase)

추가된 버전: v14.5.0

-   타입: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    이벤트가 발생하지 않을 때는 `0`을 반환하고, 이벤트가 발생 중일 때는 `2`를 반환합니다.

이 기능은 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.initEvent(type[, bubbles[, cancelable]])`[#](https://nodejs.org/docs/latest/api/events.html#eventiniteventtype-bubbles-cancelable)

추가된 버전: v19.5.0

[안정성: 3](https://nodejs.org/docs/latest/api/documentation.html#stability-index) - 레거시: WHATWG 스펙에서는 이 기능을 더 이상 사용하지 않도록 권장하며, 사용자들은 이를 전혀 사용하지 않는 것이 좋습니다.

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `bubbles` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   `cancelable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드는 이벤트 생성자와 중복되며, `composed` 속성을 설정할 수 없습니다. Node.js에서는 사용되지 않으며, 단순히 완전성을 위해 제공됩니다.


##### `event.isTrusted`[#](https://nodejs.org/docs/latest/api/events.html#eventistrusted)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal)의 `"abort"` 이벤트는 `isTrusted`가 `true`로 설정된 상태로 발생합니다. 다른 모든 경우에는 이 값이 `false`입니다.


##### `event.preventDefault()`[#](https://nodejs.org/docs/latest/api/events.html#eventpreventdefault)

추가된 버전: v14.5.0

`cancelable`이 `true`일 경우, `defaultPrevented` 속성을 `true`로 설정합니다.


##### `event.returnValue`[#](https://nodejs.org/docs/latest/api/events.html#eventreturnvalue)

추가된 버전: v14.5.0

-   타입: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 이벤트가 취소되지 않았다면 `true`를 반환합니다.

`event.returnValue`의 값은 항상 `event.defaultPrevented`와 반대입니다. 이 기능은 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.srcElement`[#](https://nodejs.org/docs/latest/api/events.html#eventsrcelement)

추가된 버전: v14.5.0

-   타입: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) 이벤트를 발생시키는 `EventTarget`입니다.

`event.target`의 별칭입니다.


##### `event.stopImmediatePropagation()`[#](https://nodejs.org/docs/latest/api/events.html#eventstopimmediatepropagation)

추가된 버전: v14.5.0

현재 이벤트 리스너가 완료된 후, 이후의 이벤트 리스너 호출을 중단합니다.


##### `event.stopPropagation()`[#](https://nodejs.org/docs/latest/api/events.html#eventstoppropagation)

추가된 버전: v14.5.0

이 메서드는 Node.js에서 사용되지 않으며, 완전성을 위해 제공됩니다.


##### `event.target`[#](https://nodejs.org/docs/latest/api/events.html#eventtarget)

추가된 버전: v14.5.0

-   타입: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)  
    이벤트를 발생시키는 `EventTarget`입니다.


##### `event.timeStamp`[#](https://nodejs.org/docs/latest/api/events.html#eventtimestamp)

추가된 버전: v14.5.0

-   타입: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`Event` 객체가 생성된 시점의 밀리초 단위 타임스탬프입니다.


##### `event.type`[#](https://nodejs.org/docs/latest/api/events.html#eventtype)

추가된 버전: v14.5.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이벤트 타입을 식별하는 문자열입니다.


#### Class: `EventTarget`[#](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)





### `eventTarget.addEventListener(type, listener[, options])`

- `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `once` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, 리스너가 처음 호출된 후 자동으로 제거됩니다. **기본값:** `false`.
  - `passive` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, 리스너가 `Event` 객체의 `preventDefault()` 메서드를 호출하지 않을 것임을 나타냅니다. **기본값:** `false`.
  - `capture` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Node.js에서 직접 사용되지 않습니다. API 완전성을 위해 추가되었습니다. **기본값:** `false`.
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) 주어진 `AbortSignal` 객체의 `abort()` 메서드가 호출되면 리스너가 제거됩니다.

`type` 이벤트에 대한 새로운 핸들러를 추가합니다. 주어진 `listener`는 `type`과 `capture` 옵션 값당 한 번만 추가됩니다.

`once` 옵션이 `true`로 설정되면, `type` 이벤트가 한 번 발생한 후 리스너가 제거됩니다.

`capture` 옵션은 Node.js에서 기능적으로 사용되지 않으며, `EventTarget` 명세에 따라 등록된 이벤트 리스너를 추적하는 데 사용됩니다. 구체적으로, `capture` 옵션은 리스너를 등록할 때 키의 일부로 사용됩니다. 각각의 `listener`는 `capture = false`와 `capture = true`로 한 번씩 추가될 수 있습니다.

```js
function handler(event) {}

const target = new EventTarget();

// 첫 번째 핸들러 추가
target.addEventListener('foo', handler, { capture: true });

// 두 번째 핸들러 추가
target.addEventListener('foo', handler, { capture: false });

// 두 번째 핸들러 제거
target.removeEventListener('foo', handler);

// 첫 번째 핸들러 제거
target.removeEventListener('foo', handler, { capture: true });
```


##### `eventTarget.dispatchEvent(event)`[#](https://nodejs.org/docs/latest/api/events.html#eventtargetdispatcheventevent)

추가된 버전: v14.5.0

-   `event` [`<Event>`](https://nodejs.org/docs/latest/api/events.html#class-event)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `event`의 `cancelable` 속성 값이 `false`이거나 `preventDefault()` 메서드가 호출되지 않았다면 `true`, 그렇지 않으면 `false`를 반환합니다.

`event`를 `event.type`에 등록된 핸들러 목록으로 전달합니다.

등록된 이벤트 리스너는 등록된 순서대로 동기적으로 호출됩니다.


##### `eventTarget.removeEventListener(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#eventtargetremoveeventlistenertype-listener-options)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `capture` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

지정된 이벤트 `type`에 대한 핸들러 목록에서 `listener`를 제거합니다.


#### 클래스: `CustomEvent`[#](https://nodejs.org/docs/latest/api/events.html#class-customevent)

-   상속: [`<Event>`](https://nodejs.org/docs/latest/api/events.html#class-event)

`CustomEvent` 객체는 [`CustomEvent` Web API](https://dom.spec.whatwg.org/#customevent)를 기반으로 구현되었습니다. 이 객체의 인스턴스는 Node.js 내부에서 생성됩니다.


##### `event.detail`[#](https://nodejs.org/docs/latest/api/events.html#eventdetail)

-   타입: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
    이벤트 초기화 시 전달된 커스텀 데이터를 반환합니다.

읽기 전용입니다.


#### 클래스: `NodeEventTarget`[#](https://nodejs.org/docs/latest/api/events.html#class-nodeeventtarget)

추가된 버전: v14.5.0

-   상속: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget)

`NodeEventTarget`은 Node.js에서 `EventTarget`을 확장한 클래스로, `EventEmitter` API의 일부 기능을 에뮬레이트합니다.


##### `nodeEventTarget.addListener(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetaddlistenertype-listener)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
    
-   반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this
    

`EventTarget` 클래스에 대한 Node.js 전용 확장으로, `EventEmitter` API와 동일한 기능을 에뮬레이트합니다. `addListener()`와 `addEventListener()`의 유일한 차이점은 `addListener()`가 `EventTarget`에 대한 참조를 반환한다는 점입니다.


##### `nodeEventTarget.emit(type, arg)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetemittype-arg)

추가된 버전: v15.2.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `arg` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `type`에 등록된 이벤트 리스너가 존재하면 `true`, 그렇지 않으면 `false`를 반환합니다.

`EventTarget` 클래스의 Node.js 전용 확장 기능으로, `type`에 대한 핸들러 목록에 `arg`를 전달합니다.


##### `nodeEventTarget.eventNames()`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargeteventnames)

추가된 버전: v14.5.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`EventTarget` 클래스에 대한 Node.js 전용 확장 기능입니다. 이 메서드는 이벤트 리스너가 등록된 이벤트 `타입` 이름들의 배열을 반환합니다.


##### `nodeEventTarget.listenerCount(type)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetlistenercounttype)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    

`EventTarget` 클래스에 대한 Node.js 전용 확장 기능으로, 특정 `type`에 등록된 이벤트 리스너의 수를 반환합니다.


##### `nodeEventTarget.setMaxListeners(n)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetsetmaxlistenersn)

추가된 버전: v14.5.0

-   `n` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`EventTarget` 클래스에 대한 Node.js 전용 확장 기능으로, 최대 이벤트 리스너 수를 `n`으로 설정합니다.


##### `nodeEventTarget.getMaxListeners()`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetgetmaxlisteners)

추가된 버전: v14.5.0

-   반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`EventTarget` 클래스에 대한 Node.js 전용 확장 기능으로, 최대 이벤트 리스너 수를 반환합니다.


##### `nodeEventTarget.off(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetofftype-listener-options)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
    
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    
    -   `capture` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this
    

`eventTarget.removeEventListener()`의 Node.js 전용 별칭입니다.


##### `nodeEventTarget.on(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetontype-listener)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
    
-   반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this
    

`eventTarget.addEventListener()`의 Node.js 전용 별칭입니다.


##### `nodeEventTarget.once(type, listener)`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetoncetype-listener)

추가된 버전: v14.5.0

- `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  이벤트 타입을 나타내는 문자열입니다.

- `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)  
  이벤트가 발생했을 때 실행될 함수 또는 이벤트 리스너입니다.

- 반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this  
  메서드 체이닝을 위해 `EventTarget` 인스턴스를 반환합니다.

이 메서드는 `EventTarget` 클래스에 추가된 Node.js 전용 확장 기능으로, 주어진 이벤트 `type`에 대해 **한 번만 실행되는** 리스너를 등록합니다. 이는 `once` 옵션을 `true`로 설정한 상태에서 `on` 메서드를 호출하는 것과 동일합니다.


##### `nodeEventTarget.removeAllListeners([type])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetremovealllistenerstype)

추가된 버전: v14.5.0

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this

`EventTarget` 클래스에 대한 Node.js 전용 확장 기능입니다. `type`이 지정되면 해당 타입에 등록된 모든 리스너를 제거합니다. `type`이 지정되지 않으면 등록된 모든 리스너를 제거합니다.


##### `nodeEventTarget.removeListener(type, listener[, options])`[#](https://nodejs.org/docs/latest/api/events.html#nodeeventtargetremovelistenertype-listener-options)

v14.5.0에서 추가됨

-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    
-   `listener` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<EventListener>`](https://nodejs.org/docs/latest/api/events.html#event-listener)
    
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    
    -   `capture` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   반환값: [`<EventTarget>`](https://nodejs.org/docs/latest/api/events.html#class-eventtarget) this
    

`EventTarget` 클래스에 대한 Node.js 전용 확장으로, 주어진 `type`에 대한 `listener`를 제거합니다. `removeListener()`와 `removeEventListener()`의 유일한 차이점은 `removeListener()`가 `EventTarget`에 대한 참조를 반환한다는 점입니다.


