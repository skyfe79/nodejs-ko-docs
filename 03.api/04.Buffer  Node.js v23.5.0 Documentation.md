# Table of Contents

- [Buffer](#buffer)
    - [버퍼와 문자 인코딩](#버퍼와-문자-인코딩)
    - [버퍼와 TypedArray](#버퍼와-typedarray)
    - [버퍼와 반복](#버퍼와-반복)
    - [클래스: `Blob`](#클래스-blob)
      - [`new buffer.Blob([sources[, options]])`](#new-bufferblobsources-options)
      - [`blob.arrayBuffer()`](#blobarraybuffer)
        - [`blob.bytes()`](#blobbytes)
      - [`blob.size`](#blobsize)
      - [`blob.slice([start[, end[, type]]])`](#blobslicestart-end-type)
      - [`blob.stream()`](#blobstream)
      - [`blob.text()`](#blobtext)
      - [`blob.type`](#blobtype)
      - [`Blob` 객체와 `MessageChannel`](#blob-객체와-messagechannel)
    - [클래스: `Buffer`](#클래스-buffer)
      - [정적 메서드: `Buffer.alloc(size[, fill[, encoding]])`](#정적-메서드-bufferallocsize-fill-encoding)
      - [정적 메서드: `Buffer.allocUnsafe(size)`](#정적-메서드-bufferallocunsafesize)
      - [정적 메서드: `Buffer.allocUnsafeSlow(size)`](#정적-메서드-bufferallocunsafeslowsize)
      - [정적 메서드: `Buffer.byteLength(string[, encoding])`](#정적-메서드-bufferbytelengthstring-encoding)
      - [정적 메서드: `Buffer.compare(buf1, buf2)`](#정적-메서드-buffercomparebuf1-buf2)
      - [정적 메서드: `Buffer.concat(list[, totalLength])`](#정적-메서드-bufferconcatlist-totallength)
      - [정적 메서드: `Buffer.copyBytesFrom(view[, offset[, length]])`](#정적-메서드-buffercopybytesfromview-offset-length)
      - [정적 메서드: `Buffer.from(array)`](#정적-메서드-bufferfromarray)
      - [정적 메서드: `Buffer.from(arrayBuffer[, byteOffset[, length]])`](#정적-메서드-bufferfromarraybuffer-byteoffset-length)
      - [정적 메서드: `Buffer.from(buffer)`](#정적-메서드-bufferfrombuffer)
      - [정적 메서드: `Buffer.from(object[, offsetOrEncoding[, length]])`](#정적-메서드-bufferfromobject-offsetorencoding-length)
      - [정적 메서드: `Buffer.from(string[, encoding])`](#정적-메서드-bufferfromstring-encoding)
      - [정적 메서드: `Buffer.isBuffer(obj)`](#정적-메서드-bufferisbufferobj)
      - [정적 메서드: `Buffer.isEncoding(encoding)`](#정적-메서드-bufferisencodingencoding)
      - [클래스 속성: `Buffer.poolSize`](#클래스-속성-bufferpoolsize)
      - [`buf[index]`](#bufindex)
      - [`buf.buffer`](#bufbuffer)
      - [`buf.byteOffset`](#bufbyteoffset)
      - [`buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])`](#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)
      - [`buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])`](#bufcopytarget-targetstart-sourcestart-sourceend)
      - [`buf.entries()`](#bufentries)
      - [`buf.equals(otherBuffer)`](#bufequalsotherbuffer)
      - [`buf.fill(value[, offset[, end]][, encoding])`](#buffillvalue-offset-end-encoding)
      - [`buf.includes(value[, byteOffset][, encoding])`](#bufincludesvalue-byteoffset-encoding)
      - [`buf.indexOf(value[, byteOffset][, encoding])`](#bufindexofvalue-byteoffset-encoding)
      - [`buf.keys()`](#bufkeys)
      - [`buf.lastIndexOf(value[, byteOffset][, encoding])`](#buflastindexofvalue-byteoffset-encoding)
      - [`buf.length`](#buflength)
      - [`buf.parent`](#bufparent)
      - [`buf.readBigInt64BE([offset])`](#bufreadbigint64beoffset)
      - [`buf.readBigInt64LE([offset])`](#bufreadbigint64leoffset)
      - [`buf.readBigUInt64BE([offset])`](#bufreadbiguint64beoffset)
      - [`buf.readBigUInt64LE([offset])`](#bufreadbiguint64leoffset)
      - [`buf.readDoubleBE([offset])`](#bufreaddoublebeoffset)
      - [`buf.readDoubleLE([offset])`](#bufreaddoubleleoffset)
      - [`buf.readFloatBE([offset])`](#bufreadfloatbeoffset)
      - [`buf.readFloatLE([offset])`](#bufreadfloatleoffset)
      - [`buf.readInt8([offset])`](#bufreadint8offset)
      - [`buf.readInt16BE([offset])`](#bufreadint16beoffset)
      - [`buf.readInt16LE([offset])`](#bufreadint16leoffset)
      - [`buf.readInt32BE([offset])`](#bufreadint32beoffset)
      - [`buf.readInt32LE([offset])`](#bufreadint32leoffset)
      - [`buf.readIntBE(offset, byteLength)`](#bufreadintbeoffset-bytelength)
      - [`buf.readIntLE(offset, byteLength)`](#bufreadintleoffset-bytelength)
      - [`buf.readUInt8([offset])`](#bufreaduint8offset)
      - [`buf.readUInt16BE([offset])`](#bufreaduint16beoffset)
      - [`buf.readUInt16LE([offset])`](#bufreaduint16leoffset)
      - [`buf.readUInt32BE([offset])`](#bufreaduint32beoffset)
      - [`buf.readUInt32LE([offset])`](#bufreaduint32leoffset)
      - [`buf.readUIntBE(offset, byteLength)`](#bufreaduintbeoffset-bytelength)
      - [`buf.readUIntLE(offset, byteLength)`](#bufreaduintleoffset-bytelength)
      - [`buf.subarray([start[, end]])`](#bufsubarraystart-end)
      - [`buf.slice([start[, end]])`](#bufslicestart-end)
      - [`buf.swap16()`](#bufswap16)
      - [`buf.swap32()`](#bufswap32)
      - [`buf.swap64()`](#bufswap64)
      - [`buf.toJSON()`](#buftojson)
      - [`buf.toString([encoding[, start[, end]]])`](#buftostringencoding-start-end)
      - [`buf.values()`](#bufvalues)
      - [`buf.write(string[, offset[, length]][, encoding])`](#bufwritestring-offset-length-encoding)
      - [`buf.writeBigInt64BE(value[, offset])`](#bufwritebigint64bevalue-offset)
      - [`buf.writeBigInt64LE(value[, offset])`](#bufwritebigint64levalue-offset)
      - [`buf.writeBigUInt64BE(value[, offset])`](#bufwritebiguint64bevalue-offset)
      - [`buf.writeBigUInt64LE(value[, offset])`](#bufwritebiguint64levalue-offset)
      - [`buf.writeDoubleBE(value[, offset])`](#bufwritedoublebevalue-offset)
      - [`buf.writeDoubleLE(value[, offset])`](#bufwritedoublelevalue-offset)
      - [`buf.writeFloatBE(value[, offset])`](#bufwritefloatbevalue-offset)
      - [`buf.writeFloatLE(value[, offset])`](#bufwritefloatlevalue-offset)
      - [`buf.writeInt8(value[, offset])`](#bufwriteint8value-offset)
      - [`buf.writeInt16BE(value[, offset])`](#bufwriteint16bevalue-offset)
      - [`buf.writeInt16LE(value[, offset])`](#bufwriteint16levalue-offset)
      - [`buf.writeInt32BE(value[, offset])`](#bufwriteint32bevalue-offset)
      - [`buf.writeInt32LE(value[, offset])`](#bufwriteint32levalue-offset)
      - [`buf.writeIntBE(value, offset, byteLength)`](#bufwriteintbevalue-offset-bytelength)
      - [`buf.writeIntLE(value, offset, byteLength)`](#bufwriteintlevalue-offset-bytelength)
      - [`buf.writeUInt8(value[, offset])`](#bufwriteuint8value-offset)
      - [`buf.writeUInt16BE(value[, offset])`](#bufwriteuint16bevalue-offset)
      - [`buf.writeUInt16LE(value[, offset])`](#bufwriteuint16levalue-offset)
      - [`buf.writeUInt32BE(value[, offset])`](#bufwriteuint32bevalue-offset)
      - [`buf.writeUInt32LE(value[, offset])`](#bufwriteuint32levalue-offset)
      - [`buf.writeUIntBE(value, offset, byteLength)`](#bufwriteuintbevalue-offset-bytelength)
      - [`buf.writeUIntLE(value, offset, byteLength)`](#bufwriteuintlevalue-offset-bytelength)
      - [`new Buffer(array)`](#new-bufferarray)
      - [`new Buffer(arrayBuffer[, byteOffset[, length]])`](#new-bufferarraybuffer-byteoffset-length)
      - [`new Buffer(buffer)`](#new-bufferbuffer)
      - [`new Buffer(size)`](#new-buffersize)
      - [`new Buffer(string[, encoding])`](#new-bufferstring-encoding)
    - [클래스: `File`](#클래스-file)
      - [`new buffer.File(sources, fileName[, options])`](#new-bufferfilesources-filename-options)
      - [`file.name`](#filename)
      - [`file.lastModified`](#filelastmodified)
    - [`node:buffer` 모듈 API](#nodebuffer-모듈-api)
      - [`buffer.atob(data)`](#bufferatobdata)
      - [`buffer.btoa(data)`](#bufferbtoadata)
      - [`buffer.isAscii(input)`](#bufferisasciiinput)
      - [`buffer.isUtf8(input)`](#bufferisutf8input)
      - [`buffer.INSPECT_MAX_BYTES`](#bufferinspect_max_bytes)
      - [`buffer.kMaxLength`](#bufferkmaxlength)
      - [`buffer.kStringMaxLength`](#bufferkstringmaxlength)
      - [`buffer.resolveObjectURL(id)`](#bufferresolveobjecturlid)
      - [`buffer.transcode(source, fromEnc, toEnc)`](#buffertranscodesource-fromenc-toenc)
      - [클래스: `SlowBuffer`](#클래스-slowbuffer)
        - [`new SlowBuffer(size)`](#new-slowbuffersize)
      - [Buffer 상수](#buffer-상수)
        - [`buffer.constants.MAX_LENGTH`](#bufferconstantsmax_length)
        - [`buffer.constants.MAX_STRING_LENGTH`](#bufferconstantsmax_string_length)
    - [`Buffer.from()`, `Buffer.alloc()`, 그리고 `Buffer.allocUnsafe()`](#bufferfrom-bufferalloc-그리고-bufferallocunsafe)
      - [`--zero-fill-buffers` 커맨드라인 옵션](#--zero-fill-buffers-커맨드라인-옵션)
      - [`Buffer.allocUnsafe()`와 `Buffer.allocUnsafeSlow()`이 "안전하지 않은" 이유는 무엇인가요?](#bufferallocunsafe와-bufferallocunsafeslow이-안전하지-않은-이유는-무엇인가요)

# Buffer

**소스 코드:** [lib/buffer.js](https://github.com/nodejs/node/blob/v23.5.0/lib/buffer.js)

`Buffer` 객체는 고정 길이의 바이트 시퀀스를 표현하는 데 사용됩니다. 많은 Node.js API가 `Buffer`를 지원합니다.

`Buffer` 클래스는 JavaScript의 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 클래스를 상속받으며, 추가적인 사용 사례를 다루는 메서드로 확장됩니다. Node.js API는 `Buffer`가 지원되는 곳에서 일반 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)도 함께 허용합니다.

`Buffer` 클래스는 전역 범위에서 사용할 수 있지만, 명시적으로 import 또는 require 문을 통해 참조하는 것이 좋습니다.

```js
import { Buffer } from 'node:buffer';

// 길이가 10인 0으로 채워진 Buffer를 생성합니다.
const buf1 = Buffer.alloc(10);

// 길이가 10이고, 모든 바이트 값이 `1`로 채워진 Buffer를 생성합니다.
const buf2 = Buffer.alloc(10, 1);

// 길이가 10인 초기화되지 않은 Buffer를 생성합니다.
// 이 방법은 Buffer.alloc()을 호출하는 것보다 빠르지만, 반환된 Buffer 인스턴스는
// 이전 데이터를 포함할 수 있으므로 fill(), write() 또는 Buffer의 내용을 채우는
// 다른 함수를 사용하여 덮어쓰는 작업이 필요합니다.
const buf3 = Buffer.allocUnsafe(10);

// 바이트 [1, 2, 3]을 포함하는 Buffer를 생성합니다.
const buf4 = Buffer.from([1, 2, 3]);

// 바이트 [1, 1, 1, 1]을 포함하는 Buffer를 생성합니다.
// 모든 항목은 `(value & 255)`를 사용하여 0–255 범위에 맞게 잘립니다.
const buf5 = Buffer.from([257, 257.5, -255, '1']);

// 문자열 'tést'의 UTF-8 인코딩된 바이트를 포함하는 Buffer를 생성합니다.
// 16진수 표기법: [0x74, 0xc3, 0xa9, 0x73, 0x74]
// 10진수 표기법: [116, 195, 169, 115, 116]
const buf6 = Buffer.from('tést');

// Latin-1 바이트 [0x74, 0xe9, 0x73, 0x74]를 포함하는 Buffer를 생성합니다.
const buf7 = Buffer.from('tést', 'latin1');
```


### 버퍼와 문자 인코딩

`Buffer`와 문자열 간 변환 시 문자 인코딩을 지정할 수 있습니다. 문자 인코딩을 지정하지 않으면 기본값으로 UTF-8이 사용됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('hello world', 'utf8');
console.log(buf.toString('hex')); // 출력: 68656c6c6f20776f726c64
console.log(buf.toString('base64')); // 출력: aGVsbG8gd29ybGQ=
console.log(Buffer.from('fhqwhgads', 'utf8')); // 출력: 
console.log(Buffer.from('fhqwhgads', 'utf16le')); // 출력: 
```

Node.js 버퍼는 받은 인코딩 문자열의 대소문자 변형을 모두 허용합니다. 예를 들어, UTF-8은 `'utf8'`, `'UTF8'`, `'uTf8'` 등으로 지정할 수 있습니다.

Node.js에서 현재 지원하는 문자 인코딩은 다음과 같습니다:

- `'utf8'` (별칭: `'utf-8'`): 멀티바이트로 인코딩된 유니코드 문자입니다. 많은 웹 페이지와 문서 형식이 UTF-8을 사용합니다. 이는 기본 문자 인코딩입니다. `Buffer`를 문자열로 디코딩할 때 유효한 UTF-8 데이터가 아닌 경우, 유니코드 대체 문자 `U+FFFD` �가 오류를 나타내는 데 사용됩니다.

- `'utf16le'` (별칭: `'utf-16le'`): 멀티바이트로 인코딩된 유니코드 문자입니다. `'utf8'`과 달리, 문자열의 각 문자는 2바이트 또는 4바이트로 인코딩됩니다. Node.js는 UTF-16의 리틀 엔디안(little-endian) 변형만 지원합니다.

- `'latin1'`: Latin-1은 ISO-8859-1을 의미합니다. 이 문자 인코딩은 `U+0000`부터 `U+00FF`까지의 유니코드 문자만 지원합니다. 각 문자는 단일 바이트로 인코딩됩니다. 해당 범위에 맞지 않는 문자는 잘리고, 범위 내의 문자로 매핑됩니다.

`Buffer`를 위의 인코딩 중 하나를 사용해 문자열로 변환하는 것을 디코딩이라고 하며, 문자열을 `Buffer`로 변환하는 것을 인코딩이라고 합니다.

Node.js는 또한 다음과 같은 바이너리-텍스트 인코딩을 지원합니다. 바이너리-텍스트 인코딩의 경우, 명명 규칙이 반대입니다: `Buffer`를 문자열로 변환하는 것을 일반적으로 인코딩이라고 하며, 문자열을 `Buffer`로 변환하는 것을 디코딩이라고 합니다.

- `'base64'`: Base64 인코딩입니다. 문자열에서 `Buffer`를 생성할 때, 이 인코딩은 RFC 4648, Section 5에 지정된 "URL 및 파일명 안전 알파벳"도 올바르게 받아들입니다. Base64로 인코딩된 문자열 내의 공백, 탭, 줄바꿈 문자는 무시됩니다.

- `'base64url'`: RFC 4648, Section 5에 지정된 base64url 인코딩입니다. 문자열에서 `Buffer`를 생성할 때, 이 인코딩은 일반적인 base64 인코딩 문자열도 올바르게 받아들입니다. `Buffer`를 문자열로 인코딩할 때, 이 인코딩은 패딩을 생략합니다.

- `'hex'`: 각 바이트를 두 개의 16진수 문자로 인코딩합니다. 16진수 문자의 짝수로만 구성되지 않은 문자열을 디코딩할 때 데이터가 잘릴 수 있습니다. 아래 예제를 참조하세요.

다음 레거시 문자 인코딩도 지원됩니다:

- `'ascii'`: 7비트 ASCII 데이터만을 위한 것입니다. 문자열을 `Buffer`로 인코딩할 때, 이는 `'latin1'`을 사용하는 것과 동일합니다. `Buffer`를 문자열로 디코딩할 때, 이 인코딩은 각 바이트의 최상위 비트를 해제한 후 `'latin1'`로 디코딩합니다. 일반적으로 이 인코딩을 사용할 이유는 없으며, ASCII 전용 텍스트를 인코딩하거나 디코딩할 때 `'utf8'`(또는 데이터가 항상 ASCII 전용임이 확실한 경우 `'latin1'`)이 더 나은 선택입니다. 이는 레거시 호환성을 위해 제공됩니다.

- `'binary'`: `'latin1'`의 별칭입니다. 이 인코딩의 이름은 매우 오해의 소지가 있습니다. 여기 나열된 모든 인코딩은 문자열과 바이너리 데이터 간 변환을 수행합니다. 문자열과 `Buffer` 간 변환에는 일반적으로 `'utf8'`이 적합합니다.

- `'ucs2'`, `'ucs-2'`: `'utf16le'`의 별칭입니다. UCS-2는 코드 포인트가 U+FFFF보다 큰 문자를 지원하지 않는 UTF-16의 변형을 가리키는 데 사용되었습니다. Node.js에서는 이러한 코드 포인트가 항상 지원됩니다.

```js
import { Buffer } from 'node:buffer';

Buffer.from('1ag123', 'hex'); // 출력: , 첫 번째 비 16진수 값('g')이 발견되면 데이터가 잘림
Buffer.from('1a7', 'hex'); // 출력: , 데이터가 단일 숫자('7')로 끝나면 데이터가 잘림
Buffer.from('1634', 'hex'); // 출력: , 모든 데이터가 표현됨
```

현대 웹 브라우저는 WHATWG 인코딩 표준을 따르며, `'latin1'`과 `'ISO-8859-1'`을 `'win-1252'`로 별칭 처리합니다. 이는 `http.get()`과 같은 작업을 수행할 때, 반환된 문자셋이 WHATWG 사양에 나열된 것 중 하나라면 서버가 실제로 `'win-1252'`로 인코딩된 데이터를 반환했을 가능성이 있으며, `'latin1'` 인코딩을 사용하면 문자를 잘못 디코딩할 수 있음을 의미합니다.


### 버퍼와 TypedArray

`Buffer` 인스턴스는 JavaScript의 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)와 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 인스턴스이기도 합니다. 모든 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 메서드를 `Buffer`에서 사용할 수 있습니다. 하지만 `Buffer` API와 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) API 사이에는 미묘한 차이가 있습니다.

특히 다음과 같은 점이 다릅니다:

- [`TypedArray.prototype.slice()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice)는 `TypedArray`의 일부를 복사하지만, [`Buffer.prototype.slice()`](https://nodejs.org/docs/latest/api/buffer.html#bufslicestart-end)는 기존 `Buffer`를 복사하지 않고 뷰를 생성합니다. 이 동작은 예상치 못한 결과를 초래할 수 있으며, 레거시 호환성을 위해 존재합니다. [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray)를 사용하면 `Buffer`와 다른 `TypedArray`에서 [`Buffer.prototype.slice()`](https://nodejs.org/docs/latest/api/buffer.html#bufslicestart-end)와 같은 동작을 얻을 수 있으며, 이 방법을 권장합니다.
- [`buf.toString()`](https://nodejs.org/docs/latest/api/buffer.html#buftostringencoding-start-end)은 `TypedArray`의 동등한 메서드와 호환되지 않습니다.
- [`buf.indexOf()`](https://nodejs.org/docs/latest/api/buffer.html#bufindexofvalue-byteoffset-encoding)와 같은 여러 메서드는 추가 인자를 지원합니다.

`Buffer`에서 새로운 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 인스턴스를 생성하는 두 가지 방법이 있습니다:

1. `Buffer`를 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 생성자에 전달하면 `Buffer`의 내용을 복사합니다. 이때 `Buffer`의 내용은 바이트 시퀀스가 아니라 정수 배열로 해석됩니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.from([1, 2, 3, 4]);
const uint32array = new Uint32Array(buf);
console.log(uint32array); // 출력: Uint32Array(4) [ 1, 2, 3, 4 ]
```

2. `Buffer`의 내부 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)를 전달하면 `Buffer`와 메모리를 공유하는 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)를 생성합니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.from('hello', 'utf16le');
const uint16array = new Uint16Array(
  buf.buffer,
  buf.byteOffset,
  buf.length / Uint16Array.BYTES_PER_ELEMENT
);
console.log(uint16array); // 출력: Uint16Array(5) [ 104, 101, 108, 108, 111 ]
```

`TypedArray` 객체의 `.buffer` 속성을 사용하여 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 인스턴스와 동일한 메모리를 공유하는 새로운 `Buffer`를 생성할 수도 있습니다. 이 경우 [`Buffer.from()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length)는 `new Uint8Array()`와 동일하게 동작합니다.

```js
import { Buffer } from 'node:buffer';
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

// `arr`의 내용을 복사합니다.
const buf1 = Buffer.from(arr);

// `arr`과 메모리를 공유합니다.
const buf2 = Buffer.from(arr.buffer);

console.log(buf1); // 출력: 
console.log(buf2); // 출력: 

arr[1] = 6000;
console.log(buf1); // 출력: 
console.log(buf2); // 출력: 
```

[`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)의 `.buffer`를 사용하여 `Buffer`를 생성할 때, `byteOffset`과 `length` 매개변수를 전달하여 내부 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)의 일부만 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';
const arr = new Uint16Array(20);
const buf = Buffer.from(arr.buffer, 0, 16);
console.log(buf.length); // 출력: 16
```

`Buffer.from()`과 [`TypedArray.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/from)은 서로 다른 시그니처와 구현을 가지고 있습니다. 특히, [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 변형은 두 번째 인자로 매핑 함수를 받아 각 요소에 적용합니다:

- `TypedArray.from(source[, mapFn[, thisArg]])`

반면 `Buffer.from()` 메서드는 매핑 함수를 지원하지 않습니다:

- [`Buffer.from(array)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray)
- [`Buffer.from(buffer)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfrombuffer)
- [`Buffer.from(arrayBuffer[, byteOffset[, length]])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length)
- [`Buffer.from(string[, encoding])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)


### 버퍼와 반복

`Buffer` 인스턴스는 `for..of` 구문을 사용하여 반복할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, 2, 3]);

for (const b of buf) {
    console.log(b);
}
// 출력:
// 1
// 2
// 3
```

또한, [`buf.values()`](https://nodejs.org/docs/latest/api/buffer.html#bufvalues), [`buf.keys()`](https://nodejs.org/docs/latest/api/buffer.html#bufkeys), 그리고 [`buf.entries()`](https://nodejs.org/docs/latest/api/buffer.html#bufentries) 메서드를 사용하여 반복자를 생성할 수 있습니다.


### 클래스: `Blob`[#](https://nodejs.org/docs/latest/api/buffer.html#class-blob)

[`Blob`](https://developer.mozilla.org/en-US/docs/Web/API/Blob)은 불변의 원시 데이터를 캡슐화하며, 여러 워커 스레드 간에 안전하게 공유할 수 있습니다.


#### `new buffer.Blob([sources[, options]])`

- `sources` [`<string[]>`] | [`<ArrayBuffer[]>`] | [`<TypedArray[]>`] | [`<DataView[]>`] | [`<Blob[]>`]  
  문자열, `ArrayBuffer`, `TypedArray`, `DataView`, 또는 `Blob` 객체의 배열 또는 이들의 혼합으로, 이 데이터들이 `Blob` 안에 저장됩니다.

- `options` [`<Object>`]
  - `endings` [`<string>`]  
    `'transparent'` 또는 `'native'` 중 하나입니다. `'native'`로 설정하면 문자열 소스 부분의 줄 바꿈이 `require('node:os').EOL`에 지정된 플랫폼 기본 줄 바꿈으로 변환됩니다.
  - `type` [`<string>`]  
    Blob의 콘텐츠 타입입니다. `type`은 데이터의 MIME 미디어 타입을 전달하기 위한 것이지만, 타입 형식에 대한 검증은 수행되지 않습니다.

주어진 소스들을 연결하여 새로운 `Blob` 객체를 생성합니다.

`ArrayBuffer`, `TypedArray`, `DataView`, 그리고 `Buffer` 소스는 `Blob` 안으로 복사되므로, `Blob`이 생성된 후에도 안전하게 수정할 수 있습니다.

문자열 소스는 UTF-8 바이트 시퀀스로 인코딩되어 `Blob`에 복사됩니다. 각 문자열 부분에서 짝이 맞지 않는 서로게이트 쌍은 유니코드 U+FFFD 대체 문자로 교체됩니다.


#### `blob.arrayBuffer()`[#](https://nodejs.org/docs/latest/api/buffer.html#blobarraybuffer)

추가된 버전: v15.7.0, v14.18.0

-   반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

`Blob` 데이터의 복사본을 포함하는 [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)로 이행되는 Promise를 반환합니다.


##### `blob.bytes()`[#](https://nodejs.org/docs/latest/api/buffer.html#blobbytes)

추가된 버전: v22.3.0, v20.16.0

`blob.bytes()` 메서드는 `Blob` 객체의 바이트를 `Promise<Uint8Array>`로 반환합니다.

```js
const blob = new Blob(['hello']);
blob.bytes().then((bytes) => {
    console.log(bytes); // 출력: Uint8Array(5) [ 104, 101, 108, 108, 111 ]
});
```


#### `blob.size`[#](https://nodejs.org/docs/latest/api/buffer.html#blobsize)

추가된 버전: v15.7.0, v14.18.0

`Blob`의 전체 크기를 바이트 단위로 반환합니다.


#### `blob.slice([start[, end[, type]]])`[#](https://nodejs.org/docs/latest/api/buffer.html#blobslicestart-end-type)

추가된 버전: v15.7.0, v14.18.0

-   `start` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 시작 인덱스
-   `end` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 끝 인덱스
-   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 새로운 `Blob`의 콘텐츠 타입

이 메서드는 현재 `Blob` 객체의 데이터 일부를 포함하는 새로운 `Blob`을 생성하고 반환합니다. 원본 `Blob`은 변경되지 않습니다.


#### `blob.stream()`[#](https://nodejs.org/docs/latest/api/buffer.html#blobstream)

추가된 버전: v16.7.0

-   반환값: [`<ReadableStream>`](https://nodejs.org/docs/latest/api/webstreams.html#class-readablestream)

`Blob`의 내용을 읽을 수 있는 새로운 `ReadableStream`을 반환합니다.


#### `blob.text()`[#](https://nodejs.org/docs/latest/api/buffer.html#blobtext)

추가된 버전: v15.7.0, v14.18.0

-   반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

`Blob`의 내용을 UTF-8 문자열로 디코딩하여 이행되는 Promise를 반환합니다.


#### `blob.type`[#](https://nodejs.org/docs/latest/api/buffer.html#blobtype)

추가된 버전: v15.7.0, v14.18.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`Blob`의 콘텐츠 타입을 나타냅니다.


#### `Blob` 객체와 `MessageChannel`

[`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob) 객체가 생성되면, 데이터를 전송하거나 즉시 복사하지 않고도 `MessagePort`를 통해 여러 목적지로 보낼 수 있습니다. `Blob`에 포함된 데이터는 `arrayBuffer()`나 `text()` 메서드가 호출될 때만 복사됩니다.

```js
import { Blob } from 'node:buffer';
import { setTimeout as delay } from 'node:timers/promises';

const blob = new Blob(['hello there']);
const mc1 = new MessageChannel();
const mc2 = new MessageChannel();

mc1.port1.onmessage = async ({ data }) => {
    console.log(await data.arrayBuffer());
    mc1.port1.close();
};

mc2.port1.onmessage = async ({ data }) => {
    await delay(1000);
    console.log(await data.arrayBuffer());
    mc2.port1.close();
};

mc1.port2.postMessage(blob);
mc2.port2.postMessage(blob);

// Blob은 전송 후에도 여전히 사용 가능합니다.
blob.text().then(console.log);
```


### 클래스: `Buffer`[#](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`Buffer` 클래스는 바이너리 데이터를 직접 다루기 위한 전역 타입입니다. 다양한 방법으로 생성할 수 있습니다.


#### 정적 메서드: `Buffer.alloc(size[, fill[, encoding]])`

- `size` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로 생성할 `Buffer`의 길이입니다.
- `fill` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새 `Buffer`를 미리 채울 값입니다. **기본값:** `0`.
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `fill`이 문자열일 경우, 해당 문자열의 인코딩입니다. **기본값:** `'utf8'`.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`size` 바이트 크기의 새로운 `Buffer`를 할당합니다. `fill`이 `undefined`인 경우, `Buffer`는 0으로 채워집니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.alloc(5);
console.log(buf); // 출력: <Buffer 00 00 00 00 00>
```

`size`가 [`buffer.constants.MAX_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_length)보다 크거나 0보다 작으면 [`ERR_OUT_OF_RANGE`](https://nodejs.org/docs/latest/api/errors.html#err_out_of_range) 오류가 발생합니다.

`fill`이 지정된 경우, 할당된 `Buffer`는 [`buf.fill(fill)`](https://nodejs.org/docs/latest/api/buffer.html#buffillvalue-offset-end-encoding)을 호출하여 초기화됩니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.alloc(5, 'a');
console.log(buf); // 출력: <Buffer 61 61 61 61 61>
```

`fill`과 `encoding`이 모두 지정된 경우, 할당된 `Buffer`는 [`buf.fill(fill, encoding)`](https://nodejs.org/docs/latest/api/buffer.html#buffillvalue-offset-end-encoding)을 호출하여 초기화됩니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf); // 출력: <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

[`Buffer.alloc()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding)을 호출하는 것은 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)에 비해 상대적으로 느릴 수 있지만, 새로 생성된 `Buffer` 인스턴스가 이전 할당에서의 민감한 데이터를 포함하지 않도록 보장합니다. 이는 `Buffer`에 할당되지 않았을 수도 있는 데이터까지 포함합니다.

`size`가 숫자가 아닌 경우 `TypeError`가 발생합니다.


#### 정적 메서드: `Buffer.allocUnsafe(size)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)

-   `size` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`의 원하는 길이
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`size` 바이트 크기의 새로운 `Buffer`를 할당합니다. `size`가 [`buffer.constants.MAX_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_length)보다 크거나 0보다 작으면 [`ERR_OUT_OF_RANGE`](https://nodejs.org/docs/latest/api/errors.html#err_out_of_range) 오류가 발생합니다.

이 방식으로 생성된 `Buffer` 인스턴스의 메모리는 **초기화되지 않습니다**. 새로 생성된 `Buffer`의 내용은 알 수 없으며 **민감한 데이터가 포함될 수 있습니다**. `Buffer` 인스턴스를 0으로 초기화하려면 [`Buffer.alloc()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding)을 대신 사용하세요.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(10);
console.log(buf); // 출력 (내용은 다를 수 있음): <Buffer 00 00 00 00 00 00 00 00 00 00>

buf.fill(0);
console.log(buf); // 출력: <Buffer 00 00 00 00 00 00 00 00 00 00>
```

`size`가 숫자가 아닌 경우 `TypeError`가 발생합니다.

`Buffer` 모듈은 [`Buffer.poolSize`](https://nodejs.org/docs/latest/api/buffer.html#class-property-bufferpoolsize) 크기의 내부 `Buffer` 인스턴스를 미리 할당합니다. 이는 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize), [`Buffer.from(array)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray), [`Buffer.from(string)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding), 그리고 [`Buffer.concat()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferconcatlist-totallength)를 사용하여 새로운 `Buffer` 인스턴스를 빠르게 할당할 때 사용됩니다. 단, `size`가 `Buffer.poolSize >>> 1` (즉, [`Buffer.poolSize`](https://nodejs.org/docs/latest/api/buffer.html#class-property-bufferpoolsize)를 2로 나눈 값)보다 작은 경우에만 적용됩니다.

이 미리 할당된 내부 메모리 풀을 사용하는 것은 `Buffer.alloc(size, fill)`과 `Buffer.allocUnsafe(size).fill(fill)`의 주요 차이점입니다. 특히, `Buffer.alloc(size, fill)`은 내부 `Buffer` 풀을 **절대** 사용하지 않지만, `Buffer.allocUnsafe(size).fill(fill)`은 `size`가 [`Buffer.poolSize`](https://nodejs.org/docs/latest/api/buffer.html#class-property-bufferpoolsize)의 절반 이하일 때 내부 `Buffer` 풀을 사용합니다. 이 차이는 미묘하지만, 애플리케이션이 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)가 제공하는 추가 성능을 필요로 할 때 중요할 수 있습니다.


#### 정적 메서드: `Buffer.allocUnsafeSlow(size)`

- `size` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로 생성할 `Buffer`의 길이
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`size` 바이트 크기의 새로운 `Buffer`를 할당합니다. `size`가 [`buffer.constants.MAX_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_length)보다 크거나 0보다 작으면 [`ERR_OUT_OF_RANGE`](https://nodejs.org/docs/latest/api/errors.html#err_out_of_range) 오류가 발생합니다. `size`가 0이면 길이가 0인 `Buffer`가 생성됩니다.

이 방식으로 생성된 `Buffer` 인스턴스의 메모리는 **초기화되지 않습니다**. 새로 생성된 `Buffer`의 내용은 알 수 없으며 **민감한 데이터가 포함될 수 있습니다**. 이러한 `Buffer` 인스턴스를 0으로 초기화하려면 [`buf.fill(0)`](https://nodejs.org/docs/latest/api/buffer.html#buffillvalue-offset-end-encoding)을 사용하세요.

[`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)를 사용하여 새로운 `Buffer` 인스턴스를 할당할 때, `Buffer.poolSize >>> 1` (기본 `poolSize`를 사용할 경우 4KiB)보다 작은 크기의 할당은 미리 할당된 단일 `Buffer`에서 잘라냅니다. 이 방식은 애플리케이션이 여러 개별 `Buffer` 인스턴스를 생성할 때 발생하는 가비지 컬렉션 오버헤드를 피할 수 있게 합니다. 이 접근 방식은 많은 개별 `ArrayBuffer` 객체를 추적하고 정리할 필요를 없애 성능과 메모리 사용량을 모두 개선합니다.

그러나 개발자가 풀에서 작은 메모리 청크를 불특정 시간 동안 유지해야 하는 경우, `Buffer.allocUnsafeSlow()`을 사용하여 풀링되지 않은 `Buffer` 인스턴스를 생성한 후 필요한 부분을 복사하는 것이 적절할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

// 몇 개의 작은 메모리 청크를 유지해야 하는 경우
const store = [];

socket.on('readable', () => {
    let data;
    while (null !== (data = readable.read())) {
        // 유지할 데이터를 위한 할당
        const sb = Buffer.allocUnsafeSlow(10);
        // 데이터를 새로운 할당에 복사
        data.copy(sb, 0, 0, 10);
        store.push(sb);
    }
});
```

`size`가 숫자가 아닌 경우 `TypeError`가 발생합니다.


#### 정적 메서드: `Buffer.byteLength(string[, encoding])`

- `string` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)  
  바이트 길이를 계산할 값입니다.

- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  `string`이 문자열인 경우, 이 인자는 문자열의 인코딩을 지정합니다. **기본값:** `'utf8'`.

- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `string`에 포함된 바이트 수를 반환합니다.

이 메서드는 주어진 `encoding`을 사용하여 문자열을 인코딩했을 때의 바이트 길이를 반환합니다. 이는 [`String.prototype.length`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/length)와 다릅니다. `String.prototype.length`는 문자열을 바이트로 변환하는 데 사용된 인코딩을 고려하지 않습니다.

`'base64'`, `'base64url'`, `'hex'` 인코딩의 경우, 이 함수는 유효한 입력을 가정합니다. 만약 문자열에 비-base64/hex 인코딩 데이터(예: 공백)가 포함되어 있다면, 반환값은 해당 문자열로 생성된 `Buffer`의 길이보다 클 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const str = '\u00bd + \u00bc = \u00be';
console.log(`${str}: ${str.length} characters, ` + `${Buffer.byteLength(str, 'utf8')} bytes`);
// 출력: ½ + ¼ = ¾: 9 characters, 12 bytes
```

`string`이 `Buffer`, [`DataView`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView), [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)인 경우, `.byteLength`가 보고하는 바이트 길이를 반환합니다.


#### 정적 메서드: `Buffer.compare(buf1, buf2)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-buffercomparebuf1-buf2)

-   `buf1` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `buf2` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 비교 결과에 따라 `-1`, `0`, 또는 `1`을 반환합니다. 자세한 내용은 [`buf.compare()`](https://nodejs.org/docs/latest/api/buffer.html#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)를 참고하세요.

`buf1`과 `buf2`를 비교하며, 주로 `Buffer` 인스턴스 배열을 정렬할 때 사용합니다. 이 메서드는 [`buf1.compare(buf2)`](https://nodejs.org/docs/latest/api/buffer.html#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)를 호출하는 것과 동일합니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from('1234');
const buf2 = Buffer.from('0123');
const arr = [buf1, buf2];

console.log(arr.sort(Buffer.compare)); // 출력: [ ,  ] // (이 결과는 [buf2, buf1]과 동일합니다.)
```


#### 정적 메서드: `Buffer.concat(list[, totalLength])`

- `list` [`<Buffer\[\]>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)  
  연결할 `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 인스턴스의 리스트입니다.
- `totalLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `list`에 있는 `Buffer` 인스턴스들을 연결했을 때의 총 길이입니다.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`list`에 있는 모든 `Buffer` 인스턴스들을 연결한 결과로 새로운 `Buffer`를 반환합니다.

만약 리스트에 항목이 없거나 `totalLength`가 0이라면, 길이가 0인 새로운 `Buffer`가 반환됩니다.

`totalLength`가 제공되지 않으면, `list`에 있는 `Buffer` 인스턴스들의 길이를 더해 계산합니다.

`totalLength`가 제공되면, 이 값은 부호 없는 정수로 강제 변환됩니다. 만약 `list`에 있는 `Buffer`들의 총 길이가 `totalLength`를 초과하면, 결과는 `totalLength`로 잘립니다. 반대로 `Buffer`들의 총 길이가 `totalLength`보다 작으면, 남은 공간은 0으로 채워집니다.

```js
import { Buffer } from 'node:buffer';

// 세 개의 `Buffer` 인스턴스 리스트로부터 하나의 `Buffer`를 생성합니다.
const buf1 = Buffer.alloc(10);
const buf2 = Buffer.alloc(14);
const buf3 = Buffer.alloc(18);

const totalLength = buf1.length + buf2.length + buf3.length;
console.log(totalLength); // 출력: 42

const bufA = Buffer.concat([buf1, buf2, buf3], totalLength);
console.log(bufA); // 출력: <Buffer 00 00 00 00 ...>
console.log(bufA.length); // 출력: 42
```

`Buffer.concat()`은 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)와 마찬가지로 내부 `Buffer` 풀을 사용할 수 있습니다.


#### 정적 메서드: `Buffer.copyBytesFrom(view[, offset[, length]])`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-buffercopybytesfromview-offset-length)

추가된 버전: v19.8.0, v18.16.0

-   `view` [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 복사할 [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)입니다.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `view` 내에서 복사를 시작할 위치입니다. **기본값:** `0`.
-   `length` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `view`에서 복사할 요소의 개수입니다. **기본값:** `view.length - offset`.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`view`의 메모리를 새로운 `Buffer`로 복사합니다.

```js
const u16 = new Uint16Array([0, 0xffff]);
const buf = Buffer.copyBytesFrom(u16, 1, 1);
u16[1] = 0;
console.log(buf.length); // 2
console.log(buf[0]); // 255
console.log(buf[1]); // 255
```


#### 정적 메서드: `Buffer.from(array)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray)

추가된 버전: v5.10.0

-   `array` [`<integer\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`0`부터 `255` 범위의 바이트 배열을 사용하여 새로운 `Buffer`를 할당합니다. 이 범위를 벗어나는 배열 항목은 범위에 맞게 잘립니다.

```js
import { Buffer } from 'node:buffer'; // 문자열 'buffer'의 UTF-8 바이트를 포함하는 새로운 Buffer를 생성합니다.
const buf = Buffer.from([0x62, 0x75, 0x66, 0x66, 0x65, 0x72]);
```

`array`가 `Array`와 유사한 객체(즉, `number` 타입의 `length` 속성을 가진 객체)인 경우, `Buffer`나 `Uint8Array`가 아니라면 배열로 취급됩니다. 이는 다른 모든 `TypedArray` 변형이 배열로 처리된다는 의미입니다. `TypedArray`의 바이트를 기반으로 `Buffer`를 생성하려면 [`Buffer.copyBytesFrom()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-buffercopybytesfromview-offset-length)을 사용하세요.

`array`가 `Array`이거나 `Buffer.from()` 변형에 적합한 타입이 아닌 경우 `TypeError`가 발생합니다.

`Buffer.from(array)`와 [`Buffer.from(string)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)은 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)와 마찬가지로 내부 `Buffer` 풀을 사용할 수 있습니다.


#### 정적 메서드: `Buffer.from(arrayBuffer[, byteOffset[, length]])`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length)

추가된 버전: v5.10.0

-   `arrayBuffer` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 또는 [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)를 의미합니다. 예를 들어, [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)의 `.buffer` 속성입니다.
-   `byteOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 노출할 첫 번째 바이트의 인덱스입니다. **기본값:** `0`.
-   `length` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 노출할 바이트 수입니다. **기본값:** `arrayBuffer.byteLength - byteOffset`.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 메서드는 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)의 메모리를 복사하지 않고 뷰를 생성합니다. 예를 들어, [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 인스턴스의 `.buffer` 속성을 참조로 전달하면, 새로 생성된 `Buffer`는 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)의 `ArrayBuffer`와 동일한 메모리를 공유합니다.

```js
import { Buffer } from 'node:buffer';

const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

// `arr`과 메모리를 공유합니다.
const buf = Buffer.from(arr.buffer);
console.log(buf); // 출력: 

// 원본 Uint16Array를 변경하면 Buffer도 변경됩니다.
arr[1] = 6000;
console.log(buf); // 출력: 
```

선택적 인자인 `byteOffset`과 `length`는 `arrayBuffer` 내에서 `Buffer`와 공유될 메모리 범위를 지정합니다.

```js
import { Buffer } from 'node:buffer';

const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length); // 출력: 2
```

`arrayBuffer`가 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)나 [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) 또는 `Buffer.from()` 변형에 적합한 타입이 아닌 경우, `TypeError`가 발생합니다.

`TypedArray` 뷰의 범위를 넘어서는 메모리 범위를 커버할 수 있는 `ArrayBuffer`를 기억하는 것이 중요합니다. `TypedArray`의 `buffer` 속성을 사용하여 생성된 새로운 `Buffer`는 `TypedArray`의 범위를 넘어설 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const arrA = Uint8Array.from([0x63, 0x64, 0x65, 0x66]); // 4개의 요소
const arrB = new Uint8Array(arrA.buffer, 1, 2); // 2개의 요소
console.log(arrA.buffer === arrB.buffer); // true

const buf = Buffer.from(arrB.buffer);
console.log(buf); // 출력: 
```


#### 정적 메서드: `Buffer.from(buffer)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfrombuffer)

추가된 버전: v5.10.0

-   `buffer` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 복사할 데이터를 가진 기존의 `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

전달된 `buffer` 데이터를 새로운 `Buffer` 인스턴스에 복사한다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;

console.log(buf1.toString()); // 출력: auffer
console.log(buf2.toString()); // 출력: buffer
```

`buffer`가 `Buffer` 또는 `Buffer.from()` 변형에 적합한 타입이 아닌 경우 `TypeError`가 발생한다.


#### 정적 메서드: `Buffer.from(object[, offsetOrEncoding[, length]])`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromobject-offsetorencoding-length)

추가된 버전: v8.2.0

-   `object` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `Symbol.toPrimitive` 또는 `valueOf()`를 지원하는 객체.
-   `offsetOrEncoding` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 바이트 오프셋 또는 인코딩.
-   `length` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 길이.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`valueOf()` 함수가 `object`와 완전히 동일하지 않은 값을 반환하는 객체의 경우, `Buffer.from(object.valueOf(), offsetOrEncoding, length)`를 반환합니다.

```js
import { Buffer } from 'node:buffer';
const buf = Buffer.from(new String('this is a test'));
// 출력: 
```

`Symbol.toPrimitive`를 지원하는 객체의 경우, `Buffer.from(object[Symbol.toPrimitive]('string'), offsetOrEncoding)`를 반환합니다.

```js
import { Buffer } from 'node:buffer';
class Foo {
  [Symbol.toPrimitive]() {
    return 'this is a test';
  }
}
const buf = Buffer.from(new Foo(), 'utf8');
// 출력: 
```

`object`가 위에서 언급한 메서드를 가지고 있지 않거나 `Buffer.from()` 변형에 적합한 타입이 아닌 경우, `TypeError`가 발생합니다.


#### 정적 메서드: `Buffer.from(string[, encoding])`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)

추가된 버전: v5.10.0

-   `string` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 인코딩할 문자열.
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `string`의 인코딩 방식. **기본값:** `'utf8'`.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`string`을 포함하는 새로운 `Buffer`를 생성합니다. `encoding` 매개변수는 문자열을 바이트로 변환할 때 사용할 문자 인코딩을 지정합니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from('this is a tést');
const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');

console.log(buf1.toString()); // 출력: this is a tést
console.log(buf2.toString()); // 출력: this is a tést
console.log(buf1.toString('latin1')); // 출력: this is a tÃ©st
```

`string`이 문자열이 아니거나 `Buffer.from()` 변형에 적합하지 않은 타입인 경우 `TypeError`가 발생합니다.

[`Buffer.from(string)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)은 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)와 마찬가지로 내부 `Buffer` 풀을 사용할 수 있습니다.


#### 정적 메서드: `Buffer.isBuffer(obj)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferisbufferobj)

추가된 버전: v0.1.101

-   `obj` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`obj`가 `Buffer`인 경우 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.

```js
import { Buffer } from 'node:buffer';

Buffer.isBuffer(Buffer.alloc(10)); // true
Buffer.isBuffer(Buffer.from('foo')); // true
Buffer.isBuffer('a string'); // false
Buffer.isBuffer([]); // false
Buffer.isBuffer(new Uint8Array(1024)); // false
```


#### 정적 메서드: `Buffer.isEncoding(encoding)`[#](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferisencodingencoding)

추가된 버전: v0.9.1

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 확인할 문자 인코딩 이름
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`encoding`이 지원되는 문자 인코딩 이름이면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.

```js
import { Buffer } from 'node:buffer';

console.log(Buffer.isEncoding('utf8')); // 출력: true
console.log(Buffer.isEncoding('hex')); // 출력: true
console.log(Buffer.isEncoding('utf/8')); // 출력: false
console.log(Buffer.isEncoding('')); // 출력: false
```


#### 클래스 속성: `Buffer.poolSize`[#](https://nodejs.org/docs/latest/api/buffer.html#class-property-bufferpoolsize)

추가된 버전: v0.11.3

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `8192`

이 속성은 풀링(pooling)을 위해 미리 할당된 내부 `Buffer` 인스턴스의 크기(바이트 단위)를 나타냅니다. 이 값은 변경할 수 있습니다.


#### `buf[index]`[#](https://nodejs.org/docs/latest/api/buffer.html#bufindex)

-   `index` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf[index]` 연산자는 `buf`에서 `index` 위치에 있는 바이트를 가져오거나 설정할 때 사용됩니다. 이 값은 개별 바이트를 참조하므로, 유효한 값의 범위는 `0x00`부터 `0xFF`(16진수) 또는 `0`부터 `255`(10진수) 사이입니다.

이 연산자는 `Uint8Array`에서 상속되었기 때문에, 범위를 벗어난 접근 시의 동작도 `Uint8Array`와 동일합니다. 즉, `index`가 음수이거나 `buf.length`보다 크거나 같을 때 `buf[index]`는 `undefined`를 반환하며, `index`가 음수이거나 `>= buf.length`일 때 `buf[index] = value`는 버퍼를 수정하지 않습니다.

```js
import { Buffer } from 'node:buffer';

// ASCII 문자열을 한 바이트씩 `Buffer`에 복사합니다.
// (이 방법은 ASCII 문자열에만 적용됩니다. 일반적으로는 `Buffer.from()`을 사용하여 변환을 수행합니다.)
const str = 'Node.js';
const buf = Buffer.allocUnsafe(str.length);

for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
}

console.log(buf.toString('utf8')); // 출력: Node.js
```


#### `buf.buffer`[#](https://nodejs.org/docs/latest/api/buffer.html#bufbuffer)

- [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 이 `Buffer` 객체가 생성된 기반이 되는 `ArrayBuffer` 객체입니다.

이 `ArrayBuffer`는 원본 `Buffer`와 정확히 일치한다고 보장할 수 없습니다. 자세한 내용은 `buf.byteOffset`에 대한 설명을 참고하세요.

```js
import { Buffer } from 'node:buffer';

const arrayBuffer = new ArrayBuffer(16);
const buffer = Buffer.from(arrayBuffer);

console.log(buffer.buffer === arrayBuffer); // true 출력
```


#### `buf.byteOffset`[#](https://nodejs.org/docs/latest/api/buffer.html#bufbyteoffset)

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `Buffer`의 기본 `ArrayBuffer` 객체의 `byteOffset`을 나타냅니다.

`Buffer.from(ArrayBuffer, byteOffset, length)`에서 `byteOffset`을 설정하거나, `Buffer.poolSize`보다 작은 `Buffer`를 할당할 때, 버퍼는 기본 `ArrayBuffer`의 0 오프셋에서 시작하지 않을 수 있습니다.

이로 인해 `buf.buffer`를 사용하여 기본 `ArrayBuffer`에 직접 접근할 때 문제가 발생할 수 있습니다. `ArrayBuffer`의 다른 부분이 `Buffer` 객체 자체와 관련이 없을 수 있기 때문입니다.

`Buffer`와 메모리를 공유하는 `TypedArray` 객체를 생성할 때 흔히 발생하는 문제는, 이 경우 `byteOffset`을 올바르게 지정해야 한다는 점입니다:

```js
import { Buffer } from 'node:buffer';

// `Buffer.poolSize`보다 작은 버퍼를 생성합니다.
const nodeBuffer = Buffer.from([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);

// Node.js Buffer를 Int8Array로 캐스팅할 때, `byteOffset`을 사용하여
// `nodeBuffer.buffer`의 `nodeBuffer`에 해당하는 메모리 부분만 참조합니다.
new Int8Array(nodeBuffer.buffer, nodeBuffer.byteOffset, nodeBuffer.length);
```


#### `buf.compare(target[, targetStart[, targetEnd[, sourceStart[, sourceEnd]]]])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)

-   `target` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)  
    `buf`와 비교할 `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)입니다.
-   `targetStart` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    `target` 내에서 비교를 시작할 위치입니다. **기본값:** `0`.
-   `targetEnd` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    `target` 내에서 비교를 종료할 위치입니다 (포함되지 않음). **기본값:** `target.length`.
-   `sourceStart` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    `buf` 내에서 비교를 시작할 위치입니다. **기본값:** `0`.
-   `sourceEnd` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    `buf` 내에서 비교를 종료할 위치입니다 (포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`와 `target`을 비교하여 정렬 순서에서 `buf`가 `target`보다 앞에 오는지, 뒤에 오는지, 또는 동일한지를 나타내는 숫자를 반환합니다. 비교는 각 `Buffer`의 실제 바이트 시퀀스를 기반으로 합니다.

-   `target`이 `buf`와 동일하면 `0`을 반환합니다.
-   `target`이 `buf`보다 앞에 오면 `1`을 반환합니다.
-   `target`이 `buf`보다 뒤에 오면 `-1`을 반환합니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('BCD');
const buf3 = Buffer.from('ABCD');

console.log(buf1.compare(buf1)); // 출력: 0
console.log(buf1.compare(buf2)); // 출력: -1
console.log(buf1.compare(buf3)); // 출력: -1
console.log(buf2.compare(buf1)); // 출력: 1
console.log(buf2.compare(buf3)); // 출력: 1
console.log([buf1, buf2, buf3].sort(Buffer.compare)); // 출력: [ , ,  ] 
// (이 결과는 [buf1, buf3, buf2]와 동일합니다.)
```

선택적 인수 `targetStart`, `targetEnd`, `sourceStart`, `sourceEnd`를 사용하여 `target`과 `buf` 내의 특정 범위로 비교를 제한할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8, 9]);
const buf2 = Buffer.from([5, 6, 7, 8, 9, 1, 2, 3, 4]);

console.log(buf1.compare(buf2, 5, 9, 0, 4)); // 출력: 0
console.log(buf1.compare(buf2, 0, 6, 4)); // 출력: -1
console.log(buf1.compare(buf2, 5, 6, 5)); // 출력: 1
```

`targetStart < 0`, `sourceStart < 0`, `targetEnd > target.byteLength`, 또는 `sourceEnd > source.byteLength`인 경우 [`ERR_OUT_OF_RANGE`](https://nodejs.org/docs/latest/api/errors.html#err_out_of_range) 오류가 발생합니다.


#### `buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufcopytarget-targetstart-sourcestart-sourceend)

추가된 버전: v0.1.90

-   `target` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 복사할 대상 `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).
-   `targetStart` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `target` 내에서 쓰기를 시작할 위치. **기본값:** `0`.
-   `sourceStart` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf` 내에서 복사를 시작할 위치. **기본값:** `0`.
-   `sourceEnd` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf` 내에서 복사를 멈출 위치 (포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 복사된 바이트 수.

`buf`의 특정 영역에서 `target`의 특정 영역으로 데이터를 복사합니다. `target` 메모리 영역이 `buf`와 겹치는 경우에도 동작합니다.

[`TypedArray.prototype.set()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/set)도 동일한 작업을 수행하며, Node.js `Buffer`를 포함한 모든 TypedArray에서 사용 가능합니다. 단, 함수 인자가 다릅니다.

```js
import { Buffer } from 'node:buffer';

// 두 개의 `Buffer` 인스턴스 생성
const buf1 = Buffer.allocUnsafe(26);
const buf2 = Buffer.allocUnsafe(26).fill('!');

for (let i = 0; i < 26; i++) {
    // 97은 'a'의 ASCII 값
    buf1[i] = i + 97;
}

// `buf1`의 16번째부터 19번째 바이트를 `buf2`의 8번째 바이트부터 복사
buf1.copy(buf2, 8, 16, 20);

// 다음 코드와 동일:
// buf2.set(buf1.subarray(16, 20), 8);

console.log(buf2.toString('ascii', 0, 25));
// 출력: !!!!!!!!qrst!!!!!!!!!!!!!
```

```js
import { Buffer } from 'node:buffer';

// `Buffer`를 생성하고 동일한 `Buffer` 내에서 한 영역에서 다른 영역으로 데이터 복사
const buf = Buffer.allocUnsafe(26);

for (let i = 0; i < 26; i++) {
    // 97은 'a'의 ASCII 값
    buf[i] = i + 97;
}

buf.copy(buf, 0, 4, 10);

console.log(buf.toString());
// 출력: efghijghijklmnopqrstuvwxyz
```


#### `buf.entries()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufentries)

추가된 버전: v1.1.0

-   반환값: [`<Iterator>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol)

`buf`의 내용을 기반으로 `[index, byte]` 쌍의 [이터레이터](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)를 생성하고 반환합니다.

```javascript
import { Buffer } from 'node:buffer';

// `Buffer`의 전체 내용을 로그로 출력합니다.
const buf = Buffer.from('buffer');
for (const pair of buf.entries()) {
    console.log(pair);
}

// 출력 결과:
// [0, 98]
// [1, 117]
// [2, 102]
// [3, 102]
// [4, 101]
// [5, 114]
```


#### `buf.equals(otherBuffer)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufequalsotherbuffer)

-   `otherBuffer` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) 타입의 객체로, `buf`와 비교할 대상입니다.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`buf`와 `otherBuffer`가 정확히 동일한 바이트를 가지고 있다면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다. 이는 [`buf.compare(otherBuffer) === 0`](https://nodejs.org/docs/latest/api/buffer.html#bufcomparetarget-targetstart-targetend-sourcestart-sourceend)과 동일한 기능을 합니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from('ABC');
const buf2 = Buffer.from('414243', 'hex');
const buf3 = Buffer.from('ABCD');

console.log(buf1.equals(buf2)); // true 출력
console.log(buf1.equals(buf3)); // false 출력
```


#### `buf.fill(value[, offset[, end]][, encoding])`

- `value` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`를 채울 값입니다. 빈 값(문자열, Uint8Array, Buffer)은 `0`으로 변환됩니다.
  
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`를 채우기 전에 건너뛸 바이트 수입니다. **기본값:** `0`.
  
- `end` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`를 채우기를 멈출 위치입니다(포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
  
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  `value`가 문자열일 경우 사용할 인코딩입니다. **기본값:** `'utf8'`.
  
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)  
  `buf`에 대한 참조를 반환합니다.

`buf`를 지정된 `value`로 채웁니다. `offset`과 `end`가 주어지지 않으면 `buf` 전체가 채워집니다:

```js
import { Buffer } from 'node:buffer';

// `Buffer`를 ASCII 문자 'h'로 채웁니다.
const b = Buffer.allocUnsafe(50).fill('h');
console.log(b.toString()); // 출력: hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh

// 빈 문자열로 버퍼를 채웁니다.
const c = Buffer.allocUnsafe(5).fill('');
console.log(c.fill('')); // 출력: 
```

`value`가 문자열, `Buffer`, 또는 정수가 아닌 경우 `uint32` 값으로 변환됩니다. 결과 정수가 `255`(10진수)보다 크면 `buf`는 `value & 255`로 채워집니다.

`fill()` 작업의 마지막 쓰기가 멀티바이트 문자에 걸쳐 있다면, `buf`에 맞는 바이트만 쓰입니다:

```js
import { Buffer } from 'node:buffer';

// UTF-8에서 두 바이트를 차지하는 문자로 `Buffer`를 채웁니다.
console.log(Buffer.allocUnsafe(5).fill('\u0222')); // 출력: 
```

`value`에 유효하지 않은 문자가 포함되어 있다면 잘립니다. 유효한 채우기 데이터가 남아 있지 않으면 예외가 발생합니다:

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(5);
console.log(buf.fill('a')); // 출력: 
console.log(buf.fill('aazz', 'hex')); // 출력: 
console.log(buf.fill('zz', 'hex')); // 예외를 발생시킵니다.
```


#### `buf.includes(value[, byteOffset][, encoding])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufincludesvalue-byteoffset-encoding)

추가된 버전: v5.3.0

-   `value` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 검색할 값.
-   `byteOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에서 검색을 시작할 위치. 음수일 경우, `buf`의 끝에서부터 오프셋을 계산. **기본값:** `0`.
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `value`가 문자열일 경우, 해당 문자열의 인코딩. **기본값:** `'utf8'`.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `buf`에서 `value`를 찾으면 `true`, 그렇지 않으면 `false`.

[`buf.indexOf() !== -1`](https://nodejs.org/docs/latest/api/buffer.html#bufindexofvalue-byteoffset-encoding)와 동일한 기능.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('this is a buffer');

console.log(buf.includes('this')); // 출력: true
console.log(buf.includes('is')); // 출력: true
console.log(buf.includes(Buffer.from('a buffer'))); // 출력: true
console.log(buf.includes(97)); // 출력: true (97은 'a'의 ASCII 값)
console.log(buf.includes(Buffer.from('a buffer example'))); // 출력: false
console.log(buf.includes(Buffer.from('a buffer example').slice(0, 8))); // 출력: true
console.log(buf.includes('this', 4)); // 출력: false
```


#### `buf.indexOf(value[, byteOffset][, encoding])`

- `value` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  검색할 값입니다.
  
- `byteOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`에서 검색을 시작할 위치입니다. 음수일 경우, `buf`의 끝에서부터 오프셋을 계산합니다. **기본값:** `0`.
  
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  `value`가 문자열일 경우, 이 인코딩을 사용하여 문자열의 바이너리 표현을 결정합니다. **기본값:** `'utf8'`.
  
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`에서 `value`가 처음 나타나는 인덱스를 반환합니다. `buf`에 `value`가 없으면 `-1`을 반환합니다.

`value`가 다음과 같은 경우:

- 문자열일 때, `value`는 `encoding`에 지정된 문자 인코딩에 따라 해석됩니다.
- `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)일 때, `value` 전체가 사용됩니다. 부분 `Buffer`를 비교하려면 [`buf.subarray`](https://nodejs.org/docs/latest/api/buffer.html#bufsubarraystart-end)를 사용하세요.
- 숫자일 때, `value`는 `0`에서 `255` 사이의 부호 없는 8비트 정수 값으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('this is a buffer');

console.log(buf.indexOf('this')); // 출력: 0
console.log(buf.indexOf('is')); // 출력: 2
console.log(buf.indexOf(Buffer.from('a buffer'))); // 출력: 8
console.log(buf.indexOf(97)); // 출력: 8 (97은 'a'의 ASCII 값)
console.log(buf.indexOf(Buffer.from('a buffer example'))); // 출력: -1
console.log(buf.indexOf(Buffer.from('a buffer example').slice(0, 8))); // 출력: 8

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
console.log(utf16Buffer.indexOf('\u03a3', 0, 'utf16le')); // 출력: 4
console.log(utf16Buffer.indexOf('\u03a3', -4, 'utf16le')); // 출력: 6
```

`value`가 문자열, 숫자, `Buffer`가 아닌 경우, 이 메서드는 `TypeError`를 발생시킵니다. `value`가 숫자일 경우, `0`에서 `255` 사이의 유효한 바이트 값으로 강제 변환됩니다.

`byteOffset`이 숫자가 아닌 경우, 숫자로 강제 변환됩니다. 강제 변환 결과가 `NaN` 또는 `0`이면 전체 버퍼를 검색합니다. 이 동작은 [`String.prototype.indexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)와 일치합니다.

```js
import { Buffer } from 'node:buffer';

const b = Buffer.from('abcdef');

// 유효한 바이트가 아닌 숫자를 전달.
// 출력: 2, 99 또는 'c'를 검색하는 것과 동일.
console.log(b.indexOf(99.9));
console.log(b.indexOf(256 + 99));

// NaN 또는 0으로 강제 변환되는 byteOffset을 전달.
// 출력: 1, 전체 버퍼를 검색.
console.log(b.indexOf('b', undefined));
console.log(b.indexOf('b', {}));
console.log(b.indexOf('b', null));
console.log(b.indexOf('b', []));
```

`value`가 빈 문자열 또는 빈 `Buffer`이고 `byteOffset`이 `buf.length`보다 작으면 `byteOffset`을 반환합니다. `value`가 비어 있고 `byteOffset`이 `buf.length` 이상이면 `buf.length`를 반환합니다.


#### `buf.keys()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufkeys)

추가된 버전: v1.1.0

-   반환값: [`<Iterator>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol)

`buf`의 키(인덱스)를 순회할 수 있는 [이터레이터](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)를 생성하고 반환합니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.from('buffer');

for (const key of buf.keys()) {
    console.log(key);
}
// 출력:
// 0
// 1
// 2
// 3
// 4
// 5
```


#### `buf.lastIndexOf(value[, byteOffset][, encoding])`

- `value` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  검색할 값입니다.
  
- `byteOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`에서 검색을 시작할 위치입니다. 음수일 경우, `buf`의 끝에서부터 오프셋을 계산합니다.  
  **기본값:** `buf.length - 1`

- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  `value`가 문자열일 경우, 이 인코딩을 사용하여 `buf`에서 검색할 문자열의 바이너리 표현을 결정합니다.  
  **기본값:** `'utf8'`

- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  `buf`에서 `value`가 마지막으로 나타나는 위치의 인덱스를 반환합니다. `buf`에 `value`가 없으면 `-1`을 반환합니다.

이 메서드는 [`buf.indexOf()`](https://nodejs.org/docs/latest/api/buffer.html#bufindexofvalue-byteoffset-encoding)와 유사하지만, `value`의 첫 번째가 아닌 마지막 위치를 찾습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('this buffer is a buffer');

console.log(buf.lastIndexOf('this')); // 출력: 0
console.log(buf.lastIndexOf('buffer')); // 출력: 17
console.log(buf.lastIndexOf(Buffer.from('buffer'))); // 출력: 17
console.log(buf.lastIndexOf(97)); // 출력: 15 (97은 'a'의 ASCII 값)
console.log(buf.lastIndexOf(Buffer.from('yolo'))); // 출력: -1
console.log(buf.lastIndexOf('buffer', 5)); // 출력: 5
console.log(buf.lastIndexOf('buffer', 4)); // 출력: -1

const utf16Buffer = Buffer.from('\u039a\u0391\u03a3\u03a3\u0395', 'utf16le');
console.log(utf16Buffer.lastIndexOf('\u03a3', undefined, 'utf16le')); // 출력: 6
console.log(utf16Buffer.lastIndexOf('\u03a3', -5, 'utf16le')); // 출력: 4
```

`value`가 문자열, 숫자, `Buffer`가 아닌 경우, 이 메서드는 `TypeError`를 발생시킵니다. `value`가 숫자일 경우, 0에서 255 사이의 유효한 바이트 값으로 강제 변환됩니다.

`byteOffset`이 숫자가 아닌 경우, 숫자로 강제 변환됩니다. `{}`나 `undefined`처럼 `NaN`으로 변환되는 인자는 전체 버퍼를 검색합니다. 이 동작은 [`String.prototype.lastIndexOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/lastIndexOf)와 일치합니다.

```js
import { Buffer } from 'node:buffer';

const b = Buffer.from('abcdef');

// 유효한 바이트가 아닌 숫자를 전달
// 출력: 2, 99 또는 'c'를 검색한 것과 동일
console.log(b.lastIndexOf(99.9));
console.log(b.lastIndexOf(256 + 99));

// NaN으로 강제 변환되는 byteOffset 전달
// 출력: 1, 전체 버퍼를 검색
console.log(b.lastIndexOf('b', undefined));
console.log(b.lastIndexOf('b', {}));

// 0으로 강제 변환되는 byteOffset 전달
// 출력: -1, 0을 전달한 것과 동일
console.log(b.lastIndexOf('b', null));
console.log(b.lastIndexOf('b', []));
```

`value`가 빈 문자열이거나 빈 `Buffer`일 경우, `byteOffset`을 반환합니다.


#### `buf.length`[#](https://nodejs.org/docs/latest/api/buffer.html#buflength)

추가된 버전: v0.1.90

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`의 바이트 수를 반환합니다.

```javascript
import { Buffer } from 'node:buffer';

// `Buffer`를 생성하고 UTF-8로 짧은 문자열을 씁니다.
const buf = Buffer.alloc(1234);
console.log(buf.length); // 출력: 1234

buf.write('some string', 0, 'utf8');
console.log(buf.length); // 출력: 1234
```


#### `buf.parent`[#](https://nodejs.org/docs/latest/api/buffer.html#bufparent)

**v8.0.0부터 더 이상 사용되지 않음**

`buf.parent` 속성은 `buf.buffer`의 별칭으로, 현재는 더 이상 사용되지 않습니다.


#### `buf.readBigInt64BE([offset])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreadbigint64beoffset)

추가된 버전: v12.0.0, v10.20.0

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
-   반환값: [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

`buf`에서 지정된 `offset` 위치에 있는 부호 있는 빅엔디안(big-endian) 64비트 정수를 읽어옵니다.

`Buffer`에서 읽은 정수는 2의 보수(two's complement) 부호 있는 값으로 해석됩니다.


#### `buf.readBigInt64LE([offset])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreadbigint64leoffset)

추가된 버전: v12.0.0, v10.20.0

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
-   반환값: [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)

`buf`에서 지정된 `offset` 위치부터 **부호 있는 64비트 정수**를 **리틀 엔디안** 형식으로 읽어옵니다.

`Buffer`에서 읽은 정수는 **2의 보수** 부호 있는 값으로 해석됩니다.


#### `buf.readBigUInt64BE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<bigint>`]

`buf`에서 지정된 `offset` 위치부터 빅 엔디안 방식의 부호 없는 64비트 정수를 읽어옵니다.

이 함수는 `readBigUint64BE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
console.log(buf.readBigUInt64BE(0)); // 출력: 4294967295n
```


#### `buf.readBigUInt64LE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<bigint>`]

`buf`에서 지정된 `offset` 위치부터 **리틀 엔디안** 방식으로 64비트 부호 없는 정수를 읽어옵니다.

이 함수는 `readBigUint64LE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff]);
console.log(buf.readBigUInt64LE(0)); // 출력: 18446744069414584320n
```


#### `buf.readDoubleBE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<number>`]

`buf`에서 지정된 `offset` 위치에서 64비트 빅엔디언(big-endian) 방식의 double 값을 읽어옵니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
console.log(buf.readDoubleBE(0)); // 출력: 8.20788039913184e-304
```


#### `buf.readDoubleLE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<number>`]

`buf`에서 지정된 `offset` 위치부터 64비트 리틀 엔디언 형식의 double 값을 읽어옵니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, 2, 3, 4, 5, 6, 7, 8]);
console.log(buf.readDoubleLE(0)); // 출력: 5.447603722011605e-270
console.log(buf.readDoubleLE(1)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readFloatBE([offset])`

- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  읽기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 32비트 빅엔디안(big-endian) 방식의 부동소수점(float) 값을 읽어옵니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, 2, 3, 4]);
console.log(buf.readFloatBE(0)); // 출력: 2.387939260590663e-38
```


#### `buf.readFloatLE([offset])`

- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  읽기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  

`buf`에서 지정된 `offset` 위치부터 32비트 리틀 엔디언(little-endian) 방식의 부동소수점(float) 값을 읽어옵니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, 2, 3, 4]);
console.log(buf.readFloatLE(0)); // 출력: 1.539989614439558e-36
console.log(buf.readFloatLE(1)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readInt8([offset])`

- **`offset`** [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 1` 조건을 만족해야 함. **기본값:** `0`.
- **반환값:** [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치에 있는 부호 있는 8비트 정수를 읽어옵니다.

`Buffer`에서 읽은 정수는 2의 보수 부호 있는 값으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([-1, 5]);

console.log(buf.readInt8(0)); // 출력: -1
console.log(buf.readInt8(1)); // 출력: 5
console.log(buf.readInt8(2)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readInt16BE([offset])`

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 2` 조건을 만족해야 함. **기본값:** `0`.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 **부호 있는 빅엔디안(big-endian) 16비트 정수**를 읽어옵니다.

`Buffer`에서 읽은 정수는 **2의 보수(two's complement) 부호 있는 값**으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0, 5]);
console.log(buf.readInt16BE(0)); // 출력: 5
```


#### `buf.readInt16LE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 2` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`]

`buf`에서 지정된 `offset` 위치부터 **리틀 엔디안(little-endian)** 방식으로 부호 있는 16비트 정수를 읽어옵니다.

`Buffer`에서 읽은 정수는 **2의 보수(two's complement)** 방식으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0, 5]);

console.log(buf.readInt16LE(0)); // 1280 출력
console.log(buf.readInt16LE(1)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readInt32BE([offset])`

- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 4` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 **부호 있는 빅엔디안(big-endian) 32비트 정수**를 읽어옵니다.

`Buffer`에서 읽은 정수는 **2의 보수(two's complement)** 부호 있는 값으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0, 0, 0, 5]);
console.log(buf.readInt32BE(0)); // 출력: 5
```


#### `buf.readInt32LE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 4` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`]

`buf`에서 지정된 `offset` 위치부터 부호 있는 32비트 정수(little-endian 방식)를 읽어옵니다.

`Buffer`에서 읽은 정수는 2의 보수 부호 있는 값으로 해석됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0, 0, 0, 5]);

console.log(buf.readInt32LE(0)); // 출력: 83886080
console.log(buf.readInt32LE(1)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readIntBE(offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreadintbeoffset-bytelength)

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    읽기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 합니다.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    읽을 바이트 수입니다. `0 < byteLength <= 6` 조건을 만족해야 합니다.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  

`buf`에서 지정된 `offset` 위치부터 `byteLength` 바이트를 읽어서, 이를 빅엔디안 방식의 2의 보수 부호 있는 정수로 해석합니다. 최대 48비트 정확도를 지원합니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

console.log(buf.readIntBE(0, 6).toString(16)); // 출력: 1234567890ab
console.log(buf.readIntBE(1, 6).toString(16)); // ERR_OUT_OF_RANGE 오류 발생
console.log(buf.readIntBE(1, 0).toString(16)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readIntLE(offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreadintleoffset-bytelength)

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 함.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽을 바이트 수. `0 < byteLength <= 6` 조건을 만족해야 함.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 `byteLength` 바이트를 읽어서, 이를 리틀 엔디안(little-endian) 방식의 2의 보수 부호 있는 정수로 해석합니다. 최대 48비트 정확도를 지원합니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
console.log(buf.readIntLE(0, 6).toString(16)); // 출력: -546f87a9cbee
```


#### `buf.readUInt8([offset])`

- **`offset`** [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 1` 조건을 만족해야 함. **기본값:** `0`.
- **반환값:** [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치에 있는 부호 없는 8비트 정수를 읽어옵니다.

이 함수는 `readUint8`이라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([1, -2]);

console.log(buf.readUInt8(0)); // 출력: 1
console.log(buf.readUInt8(1)); // 출력: 254
console.log(buf.readUInt8(2)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readUInt16BE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 2` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`]

`buf`에서 지정된 `offset` 위치부터 빅 엔디안 방식으로 부호 없는 16비트 정수를 읽어옵니다.

이 함수는 `readUint16BE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16BE(0).toString(16)); // 1234 출력
console.log(buf.readUInt16BE(1).toString(16)); // 3456 출력
```


#### `buf.readUInt16LE([offset])`

- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 2` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 리틀 엔디안 방식으로 부호 없는 16비트 정수를 읽어옵니다.

이 함수는 `readUint16LE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56]);

console.log(buf.readUInt16LE(0).toString(16)); // 출력: 3412
console.log(buf.readUInt16LE(1).toString(16)); // 출력: 5634
console.log(buf.readUInt16LE(2).toString(16)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readUInt32BE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 4` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`]

`buf`에서 지정된 `offset` 위치부터 빅 엔디안 방식의 부호 없는 32비트 정수를 읽어옵니다.

이 함수는 `readUint32BE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);
console.log(buf.readUInt32BE(0).toString(16)); // 출력: 12345678
```


#### `buf.readUInt32LE([offset])`

- `offset` [`<integer>`] 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 4` 조건을 만족해야 함. **기본값:** `0`.
- 반환값: [`<integer>`]

`buf`에서 지정된 `offset` 위치부터 리틀 엔디안 방식의 부호 없는 32비트 정수를 읽어옵니다.

이 함수는 `readUint32LE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78]);

console.log(buf.readUInt32LE(0).toString(16)); // 출력: 78563412
console.log(buf.readUInt32LE(1).toString(16)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readUIntBE(offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreaduintbeoffset-bytelength)

-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 한다.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 읽을 바이트 수. `0 < byteLength <= 6` 조건을 만족해야 한다.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`buf`에서 지정된 `offset` 위치부터 `byteLength` 바이트를 읽어서, 이를 **빅엔디언 방식의 부호 없는 정수**로 해석한다. 이 함수는 최대 48비트의 정확도를 지원한다.

이 함수는 `readUintBE`라는 별칭으로도 사용할 수 있다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);

// 0번째 바이트부터 6바이트를 읽어서 16진수로 출력
console.log(buf.readUIntBE(0, 6).toString(16)); // 출력: 1234567890ab

// 1번째 바이트부터 6바이트를 읽으려고 시도하면 범위를 벗어나므로 오류 발생
console.log(buf.readUIntBE(1, 6).toString(16)); // ERR_OUT_OF_RANGE 오류 발생
```


#### `buf.readUIntLE(offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufreaduintleoffset-bytelength)

- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  읽기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 합니다.
  
- `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  읽을 바이트 수입니다. `0 < byteLength <= 6` 조건을 만족해야 합니다.
  
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  

`buf`에서 지정된 `offset` 위치부터 `byteLength` 바이트를 읽어서, 이를 **리틀 엔디언(Little-Endian)** 방식의 부호 없는 정수로 해석합니다. 이 함수는 최대 48비트 정확도를 지원합니다.

이 함수는 `readUintLE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x12, 0x34, 0x56, 0x78, 0x90, 0xab]);
console.log(buf.readUIntLE(0, 6).toString(16)); // 출력: ab9078563412
```


#### `buf.subarray([start[, end]])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufsubarraystart-end)

추가된 버전: v3.0.0

-   `start` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`가 시작할 위치. **기본값:** `0`.
-   `end` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`가 끝날 위치 (포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

원본 `Buffer`와 동일한 메모리를 참조하지만, `start`와 `end` 인덱스로 오프셋과 크롭된 새로운 `Buffer`를 반환합니다.

`end`를 [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength)보다 크게 지정하면, `end`가 [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength)와 동일한 결과를 반환합니다.

이 메서드는 [`TypedArray.prototype.subarray()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray)에서 상속되었습니다.

새로운 `Buffer` 슬라이스를 수정하면 원본 `Buffer`의 메모리도 수정됩니다. 두 객체의 할당된 메모리가 겹치기 때문입니다.

```js
import { Buffer } from 'node:buffer';

// ASCII 알파벳으로 `Buffer`를 생성하고, 슬라이스를 취한 후 원본 `Buffer`의 한 바이트를 수정합니다.
const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i < 26; i++) {
    // 97은 'a'의 ASCII 값입니다.
    buf1[i] = i + 97;
}

const buf2 = buf1.subarray(0, 3);
console.log(buf2.toString('ascii', 0, buf2.length)); // 출력: abc

buf1[0] = 33;
console.log(buf2.toString('ascii', 0, buf2.length)); // 출력: !bc
```

음수 인덱스를 지정하면 슬라이스가 `buf`의 끝을 기준으로 생성됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('buffer');

console.log(buf.subarray(-6, -1).toString()); // 출력: buffe
// (buf.subarray(0, 5)와 동일합니다.)

console.log(buf.subarray(-6, -2).toString()); // 출력: buff
// (buf.subarray(0, 4)와 동일합니다.)

console.log(buf.subarray(-5, -2).toString()); // 출력: uff
// (buf.subarray(1, 4)와 동일합니다.)
```


#### `buf.slice([start[, end]])`

- `start` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`가 시작될 위치. **기본값:** `0`.
- `end` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`가 끝날 위치 (포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

원본 `Buffer`와 동일한 메모리를 참조하지만, `start`와 `end` 인덱스로 오프셋과 크롭이 적용된 새로운 `Buffer`를 반환합니다.

이 메서드는 `Buffer`의 상위 클래스인 `Uint8Array.prototype.slice()`와 호환되지 않습니다. 슬라이스를 복사하려면 `Uint8Array.prototype.slice()`를 사용하세요.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('buffer');

// Uint8Array.prototype.slice를 사용하여 복사
const copiedBuf = Uint8Array.prototype.slice.call(buf);
copiedBuf[0]++;
console.log(copiedBuf.toString()); // 출력: cuffer
console.log(buf.toString()); // 출력: buffer

// buf.slice()를 사용하면 원본 버퍼가 수정됨
const notReallyCopiedBuf = buf.slice();
notReallyCopiedBuf[0]++;
console.log(notReallyCopiedBuf.toString()); // 출력: cuffer
console.log(buf.toString()); // 출력: cuffer (!)
```


#### `buf.swap16()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufswap16)

추가된 버전: v5.10.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `buf`에 대한 참조

`buf`를 부호 없는 16비트 정수 배열로 해석하고, 바이트 순서를 **제자리에서** 바꿉니다. [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength)가 2의 배수가 아닌 경우 [`ERR_INVALID_BUFFER_SIZE`](https://nodejs.org/docs/latest/api/errors.html#err_invalid_buffer_size) 오류를 발생시킵니다.

```javascript
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf1); // 출력: 
buf1.swap16();
console.log(buf1); // 출력: 

const buf2 = Buffer.from([0x1, 0x2, 0x3]);
buf2.swap16(); // ERR_INVALID_BUFFER_SIZE 오류 발생
```

`buf.swap16()`의 편리한 사용 사례 중 하나는 UTF-16 리틀 엔디안과 UTF-16 빅 엔디안 간의 빠른 제자리 변환을 수행하는 것입니다:

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.from('This is little-endian UTF-16', 'utf16le');
buf.swap16(); // 빅 엔디안 UTF-16 텍스트로 변환
```


#### `buf.swap32()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufswap32)

추가된 버전: v5.10.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `buf`에 대한 참조를 반환합니다.

`buf`를 부호 없는 32비트 정수 배열로 해석하고, 바이트 순서를 **제자리에서** 바꿉니다. [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength)가 4의 배수가 아닌 경우 [`ERR_INVALID_BUFFER_SIZE`](https://nodejs.org/docs/latest/api/errors.html#err_invalid_buffer_size) 에러를 발생시킵니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf1); // 출력: 
buf1.swap32();
console.log(buf1); // 출력: 

const buf2 = Buffer.from([0x1, 0x2, 0x3]);
buf2.swap32(); // ERR_INVALID_BUFFER_SIZE 에러 발생
```


#### `buf.swap64()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufswap64)

추가된 버전: v6.3.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) `buf`에 대한 참조를 반환합니다.

`buf`를 64비트 숫자 배열로 해석하고, 바이트 순서를 **제자리에서** 바꿉니다. [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength)가 8의 배수가 아닌 경우 [`ERR_INVALID_BUFFER_SIZE`](https://nodejs.org/docs/latest/api/errors.html#err_invalid_buffer_size) 오류를 발생시킵니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8]);
console.log(buf1); // 출력: 
buf1.swap64();
console.log(buf1); // 출력: 

const buf2 = Buffer.from([0x1, 0x2, 0x3]);
buf2.swap64(); // ERR_INVALID_BUFFER_SIZE 오류 발생
```


#### `buf.toJSON()`[#](https://nodejs.org/docs/latest/api/buffer.html#buftojson)

추가된 버전: v0.9.2

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

`buf`의 JSON 표현을 반환합니다. [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)는 `Buffer` 인스턴스를 문자열로 변환할 때 이 함수를 암묵적으로 호출합니다.

`Buffer.from()`은 이 메서드가 반환한 형식의 객체를 받아들입니다. 특히, `Buffer.from(buf.toJSON())`은 `Buffer.from(buf)`와 동일하게 동작합니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);
const json = JSON.stringify(buf);
console.log(json); // 출력: {"type":"Buffer","data":[1,2,3,4,5]}

const copy = JSON.parse(json, (key, value) => {
    return value && value.type === 'Buffer' ? Buffer.from(value) : value;
});
console.log(copy); // 출력: <Buffer 01 02 03 04 05>
```


#### `buf.toString([encoding[, start[, end]]])`[#](https://nodejs.org/docs/latest/api/buffer.html#buftostringencoding-start-end)

추가된 버전: v0.1.90

-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 문자 인코딩. **기본값:** `'utf8'`.
-   `start` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 디코딩을 시작할 바이트 오프셋. **기본값:** `0`.
-   `end` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 디코딩을 종료할 바이트 오프셋 (포함되지 않음). **기본값:** [`buf.length`](https://nodejs.org/docs/latest/api/buffer.html#buflength).
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`buf`를 `encoding`에 지정된 문자 인코딩에 따라 문자열로 디코딩합니다. `start`와 `end`를 전달하여 `buf`의 일부만 디코딩할 수 있습니다.

`encoding`이 `'utf8'`이고 입력된 바이트 시퀀스가 유효한 UTF-8이 아닌 경우, 각 유효하지 않은 바이트는 대체 문자 `U+FFFD`로 교체됩니다.

문자열 인스턴스의 최대 길이(UTF-16 코드 단위 기준)는 [`buffer.constants.MAX_STRING_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_string_length)에서 확인할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf1 = Buffer.allocUnsafe(26);

for (let i = 0; i < 26; i++) {
    // 97은 'a'의 ASCII 값입니다.
    buf1[i] = i + 97;
}

console.log(buf1.toString('utf8')); // 출력: abcdefghijklmnopqrstuvwxyz
console.log(buf1.toString('utf8', 0, 5)); // 출력: abcde

const buf2 = Buffer.from('tést');
console.log(buf2.toString('hex')); // 출력: 74c3a97374
console.log(buf2.toString('utf8', 0, 3)); // 출력: té
console.log(buf2.toString(undefined, 0, 3)); // 출력: té
```


#### `buf.values()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufvalues)

추가된 버전: v1.1.0

-   반환값: [`<Iterator>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#The_iterator_protocol)

`buf`의 값(바이트)에 대한 [이터레이터](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)를 생성하고 반환합니다. 이 함수는 `Buffer`가 `for..of` 문에서 사용될 때 자동으로 호출됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.from('buffer');

for (const value of buf.values()) {
    console.log(value);
}
// 출력:
// 98
// 117
// 102
// 102
// 101
// 114

for (const value of buf) {
    console.log(value);
}
// 출력:
// 98
// 117
// 102
// 102
// 101
// 114
```


#### `buf.write(string[, offset[, length]][, encoding])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwritestring-offset-length-encoding)

추가된 버전: v0.1.90

-   `string` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `buf`에 쓸 문자열.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 문자열을 쓰기 전에 건너뛸 바이트 수. **기본값:** `0`.
-   `length` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓸 최대 바이트 수 (쓰여지는 바이트 수는 `buf.length - offset`을 초과하지 않음). **기본값:** `buf.length - offset`.
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 문자열의 문자 인코딩. **기본값:** `'utf8'`.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓴 바이트 수.

`buf`의 `offset` 위치에 `encoding` 인코딩 방식으로 `string`을 씁니다. `length` 매개변수는 쓸 바이트 수를 지정합니다. `buf`에 전체 문자열을 담을 공간이 부족하면 문자열의 일부만 쓰여집니다. 하지만 부분적으로 인코딩된 문자는 쓰이지 않습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.alloc(256);
const len = buf.write('\u00bd + \u00bc = \u00be', 0);
console.log(`${len} bytes: ${buf.toString('utf8', 0, len)}`);
// 출력: 12 bytes: ½ + ¼ = ¾

const buffer = Buffer.alloc(10);
const length = buffer.write('abcd', 8);
console.log(`${length} bytes: ${buffer.toString('utf8', 8, 10)}`);
// 출력: 2 bytes : ab
```


#### `buf.writeBigInt64BE(value[, offset])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwritebigint64bevalue-offset)

추가된 버전: v12.0.0, v10.20.0

-   `value` [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) `buf`에 쓸 숫자입니다.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 8` 조건을 만족해야 합니다. **기본값:** `0`.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 빅엔디안(big-endian) 형식으로 씁니다.

`value`는 2의 보수 부호 있는 정수로 해석되어 기록됩니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeBigInt64BE(0x0102030405060708n, 0);

console.log(buf);
// 출력: 
```


#### `buf.writeBigInt64LE(value[, offset])`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwritebigint64levalue-offset)

추가된 버전: v12.0.0, v10.20.0

-   `value` [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) `buf`에 쓸 숫자.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - 8` 조건을 만족해야 함. **기본값:** `0`.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값.

`buf`의 지정된 `offset` 위치에 `value`를 리틀 엔디안(little-endian) 형식으로 씁니다.

`value`는 2의 보수 부호 있는 정수로 해석되어 기록됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeBigInt64LE(0x0102030405060708n, 0);

console.log(buf);
// 출력: 
```


#### `buf.writeBigUInt64BE(value[, offset])`

- `value` [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 8` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 빅 엔디안(big-endian) 형식으로 씁니다.

이 함수는 `writeBigUint64BE`라는 별칭으로도 사용할 수 있습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeBigUInt64BE(0xdecafafecacefaden, 0);

console.log(buf); // 출력: 
```


#### `buf.writeBigUInt64LE(value[, offset])`

- `value` [`<bigint>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 8` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 리틀 엔디언(little-endian) 형식으로 씁니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeBigUInt64LE(0xdecafafecacefaden, 0);
console.log(buf); // 출력: 
```

이 함수는 `writeBigUint64LE`라는 별칭으로도 사용할 수 있습니다.


#### `buf.writeDoubleBE(value[, offset])`

- `value` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 8` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 빅엔디안(big-endian) 형식으로 씁니다. `value`는 반드시 자바스크립트 숫자여야 합니다. `value`가 자바스크립트 숫자가 아닌 경우 동작은 정의되지 않습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeDoubleBE(123.456, 0);
console.log(buf); // 출력: 
```


#### `buf.writeDoubleLE(value[, offset])`

- `value` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 8` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 리틀 엔디안(little-endian) 방식으로 씁니다. `value`는 반드시 자바스크립트 숫자여야 합니다. `value`가 자바스크립트 숫자가 아닌 경우 동작은 정의되지 않습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(8);
buf.writeDoubleLE(123.456, 0);

console.log(buf); // 출력: 
```


#### `buf.writeFloatBE(value[, offset])`

- `value` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅엔디안(big-endian) 방식으로 씁니다. `value`가 자바스크립트 숫자가 아닌 경우 동작은 정의되지 않습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeFloatBE(0xcafebabe, 0);
console.log(buf); // 출력: 
```


#### `buf.writeFloatLE(value[, offset])`

- `value` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 리틀 엔디언(little-endian) 방식으로 씁니다. `value`가 JavaScript 숫자가 아닌 경우 동작은 정의되지 않습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeFloatLE(0xcafebabe, 0);
console.log(buf); // 출력: 
```


#### `buf.writeInt8(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 1` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 씁니다. `value`는 반드시 유효한 부호 있는 8비트 정수여야 합니다. `value`가 부호 있는 8비트 정수가 아닌 경우 동작은 정의되지 않습니다.

`value`는 2의 보수 부호 있는 정수로 해석되어 기록됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(2);
buf.writeInt8(2, 0);
buf.writeInt8(-2, 1);

console.log(buf); // 출력: 
```


#### `buf.writeInt16BE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 2` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅엔디안(big-endian) 형식으로 씁니다. `value`는 반드시 유효한 부호 있는 16비트 정수여야 합니다. `value`가 부호 있는 16비트 정수가 아닌 경우 동작은 정의되지 않습니다.

`value`는 2의 보수 부호 있는 정수로 해석되어 기록됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(2);
buf.writeInt16BE(0x0102, 0);
console.log(buf); // 출력: <Buffer 01 02>
```


#### `buf.writeInt16LE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 2` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 리틀 엔디안(little-endian) 형식으로 씁니다. `value`는 유효한 부호 있는 16비트 정수여야 합니다. `value`가 부호 있는 16비트 정수가 아닌 경우 동작은 정의되지 않습니다.

`value`는 2의 보수(two's complement) 부호 있는 정수로 해석되어 기록됩니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(2);
buf.writeInt16LE(0x0304, 0);
console.log(buf); // 출력: <Buffer 04 03>
```


#### `buf.writeInt32BE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅엔디안(big-endian) 형식으로 씁니다. `value`는 반드시 유효한 부호 있는 32비트 정수여야 합니다. `value`가 부호 있는 32비트 정수가 아닌 경우 동작은 정의되지 않습니다.

`value`는 2의 보수 부호 있는 정수로 해석되어 기록됩니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeInt32BE(0x01020304, 0);
console.log(buf); // 출력: <Buffer 01 02 03 04>
```


#### `buf.writeInt32LE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 리틀 엔디언(little-endian) 방식으로 씁니다. `value`는 반드시 유효한 부호 있는 32비트 정수여야 합니다. `value`가 부호 있는 32비트 정수가 아닌 경우 동작은 정의되지 않습니다.

`value`는 2의 보수(two's complement) 부호 있는 정수로 해석되어 기록됩니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeInt32LE(0x05060708, 0);
console.log(buf); // 출력: 
```


#### `buf.writeIntBE(value, offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwriteintbevalue-offset-bytelength)

-   `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 합니다.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓸 바이트 수입니다. `0 < byteLength <= 6` 조건을 만족해야 합니다.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅엔디안(big-endian) 형식으로 `byteLength` 바이트만큼 씁니다. 최대 48비트의 정확도를 지원합니다. `value`가 부호 있는 정수(signed integer)가 아닌 경우 동작은 정의되지 않습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(6);
buf.writeIntBE(0x1234567890ab, 0, 6);
console.log(buf); // 출력: 
```


#### `buf.writeIntLE(value, offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwriteintlevalue-offset-bytelength)

-   `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 함.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓸 바이트 수. `0 < byteLength <= 6` 조건을 만족해야 함.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값.

지정된 `offset` 위치부터 `buf`에 `value`를 리틀 엔디안(little-endian) 방식으로 `byteLength` 바이트만큼 씁니다. 최대 48비트 정확도를 지원합니다. `value`가 부호 있는 정수가 아닌 경우 동작은 정의되지 않습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(6);
buf.writeIntLE(0x1234567890ab, 0, 6);
console.log(buf); // 출력: 
```


#### `buf.writeUInt8(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 1` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 씁니다. `value`는 반드시 유효한 8비트 부호 없는 정수여야 합니다. `value`가 8비트 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUint8`이라는 별칭으로도 사용할 수 있습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeUInt8(0x3, 0);
buf.writeUInt8(0x4, 1);
buf.writeUInt8(0x23, 2);
buf.writeUInt8(0x42, 3);

console.log(buf); // 출력: 
```


#### `buf.writeUInt16BE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 2` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅 엔디안(big-endian) 형식으로 씁니다. `value`는 반드시 유효한 16비트 부호 없는 정수여야 합니다. `value`가 16비트 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUint16BE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeUInt16BE(0xdead, 0);
buf.writeUInt16BE(0xbeef, 2);

console.log(buf); // 출력: 
```


#### `buf.writeUInt16LE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자 값입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 2` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 리틀 엔디안(little-endian) 방식으로 씁니다. `value`는 반드시 유효한 16비트 부호 없는 정수여야 합니다. `value`가 16비트 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUint16LE`라는 별칭으로도 사용할 수 있습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeUInt16LE(0xdead, 0);
buf.writeUInt16LE(0xbeef, 2);

console.log(buf); // 출력: <Buffer ad de ef be>
```


#### `buf.writeUInt32BE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`buf`의 지정된 `offset` 위치에 `value`를 빅엔디안(big-endian) 형식으로 씁니다. `value`는 반드시 유효한 32비트 부호 없는 정수여야 합니다. `value`가 32비트 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUint32BE`라는 별칭으로도 사용할 수 있습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeUInt32BE(0xfeedface, 0);
console.log(buf); // 출력: <Buffer fe ed fa ce>
```


#### `buf.writeUInt32LE(value[, offset])`

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - 4` 조건을 만족해야 합니다. **기본값:** `0`.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

`value`를 `buf`의 지정된 `offset` 위치에 리틀 엔디언(little-endian) 방식으로 씁니다. `value`는 반드시 유효한 32비트 부호 없는 정수여야 합니다. `value`가 32비트 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUint32LE`라는 별칭으로도 사용할 수 있습니다.

```javascript
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(4);
buf.writeUInt32LE(0xfeedface, 0);
console.log(buf); // 출력: <Buffer ce fa ed fe>
```


#### `buf.writeUIntBE(value, offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwriteuintbevalue-offset-bytelength)

- `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): `buf`에 쓸 숫자 값.
- `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 쓰기를 시작하기 전에 건너뛸 바이트 수. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 함.
- `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 쓸 바이트 수. `0 < byteLength <= 6` 조건을 만족해야 함.
- 반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): `offset`에 쓴 바이트 수를 더한 값.

`buf`의 지정된 `offset` 위치에 `value`를 빅 엔디안(big-endian) 형식으로 `byteLength` 바이트만큼 씁니다. 최대 48비트 정확도를 지원합니다. `value`가 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUintBE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(6);
buf.writeUIntBE(0x1234567890ab, 0, 6);
console.log(buf); // 출력: <Buffer 12 34 56 78 90 ab>
```


#### `buf.writeUIntLE(value, offset, byteLength)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufwriteuintlevalue-offset-bytelength)

-   `value` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `buf`에 쓸 숫자입니다.
-   `offset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓰기를 시작하기 전에 건너뛸 바이트 수입니다. `0 <= offset <= buf.length - byteLength` 조건을 만족해야 합니다.
-   `byteLength` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 쓸 바이트 수입니다. `0 < byteLength <= 6` 조건을 만족해야 합니다.
-   반환값: [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `offset`에 쓴 바이트 수를 더한 값입니다.

지정된 `offset` 위치에 `value`를 리틀 엔디안(little-endian) 형식으로 `byteLength` 바이트만큼 `buf`에 씁니다. 최대 48비트 정확도를 지원합니다. `value`가 부호 없는 정수가 아닌 경우 동작은 정의되지 않습니다.

이 함수는 `writeUintLE`라는 별칭으로도 사용할 수 있습니다.

```js
import { Buffer } from 'node:buffer';

const buf = Buffer.allocUnsafe(6);
buf.writeUIntLE(0x1234567890ab, 0, 6);
console.log(buf); // 출력: 
```


#### `new Buffer(array)`[#](https://nodejs.org/docs/latest/api/buffer.html#new-bufferarray)

- `array` [`<integer[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 복사할 바이트 배열입니다.

[`Buffer.from(array)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray)를 참고하세요.


#### `new Buffer(arrayBuffer[, byteOffset[, length]])`

- `arrayBuffer` [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<SharedArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)  
  [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer), 또는 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)의 `.buffer` 속성을 사용할 수 있습니다.

- `byteOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  첫 번째로 노출할 바이트의 인덱스입니다. **기본값:** `0`.

- `length` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
  노출할 바이트의 수입니다. **기본값:** `arrayBuffer.byteLength - byteOffset`.

자세한 내용은 [`Buffer.from(arrayBuffer[, byteOffset[, length]])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length)를 참고하세요.


#### `new Buffer(buffer)`[#](https://nodejs.org/docs/latest/api/buffer.html#new-bufferbuffer)

-   `buffer` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)  
    기존의 `Buffer` 또는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)에서 데이터를 복사합니다.

[`Buffer.from(buffer)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfrombuffer)를 참고하세요.


#### `new Buffer(size)`[#](https://nodejs.org/docs/latest/api/buffer.html#new-buffersize)

-   `size` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `Buffer`의 원하는 길이입니다.

[`Buffer.alloc()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding)과 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)를 참고하세요. 이 생성자 변형은 [`Buffer.alloc()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding)와 동일합니다.


#### `new Buffer(string[, encoding])`[#](https://nodejs.org/docs/latest/api/buffer.html#new-bufferstring-encoding)

-   `string` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 인코딩할 문자열.
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `string`의 인코딩 방식. **기본값:** `'utf8'`.

자세한 내용은 [`Buffer.from(string[, encoding])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)을 참고하세요.


### 클래스: `File`[#](https://nodejs.org/docs/latest/api/buffer.html#class-file)

-   상속: [`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob)

[`File`](https://developer.mozilla.org/en-US/docs/Web/API/File) 클래스는 파일에 대한 정보를 제공합니다.


#### `new buffer.File(sources, fileName[, options])`[#](https://nodejs.org/docs/latest/api/buffer.html#new-bufferfilesources-filename-options)

추가된 버전: v19.2.0, v18.13.0

-   `sources` [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<TypedArray\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) | [`<Blob\[\]>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob) | [`<File\[\]>`](https://nodejs.org/docs/latest/api/buffer.html#class-file)  
    문자열, [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView), [`<File>`](https://nodejs.org/docs/latest/api/buffer.html#class-file), 또는 [`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob) 객체의 배열, 또는 이러한 객체들의 혼합으로, 이들은 `File` 내에 저장됩니다.

-   `fileName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    파일의 이름입니다.

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `endings` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
        `'transparent'` 또는 `'native'` 중 하나입니다. `'native'`로 설정하면 문자열 소스 부분의 줄 끝이 `require('node:os').EOL`에 지정된 플랫폼 기본 줄 끝으로 변환됩니다.
    -   `type` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
        파일의 콘텐츠 타입입니다.
    -   `lastModified` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
        파일의 마지막 수정 날짜입니다. **기본값:** `Date.now()`


#### `file.name`[#](https://nodejs.org/docs/latest/api/buffer.html#filename)

추가된 버전: v19.2.0, v18.13.0

-   타입: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`File`의 이름을 나타냅니다.


#### `file.lastModified`[#](https://nodejs.org/docs/latest/api/buffer.html#filelastmodified)

추가된 버전: v19.2.0, v18.13.0

-   타입: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`File`의 마지막 수정 날짜를 나타냅니다.


### `node:buffer` 모듈 API[#](https://nodejs.org/docs/latest/api/buffer.html#nodebuffer-module-apis)

`Buffer` 객체는 전역으로 사용할 수 있지만, `require('node:buffer')`를 통해 접근할 수 있는 `node:buffer` 모듈에서만 사용 가능한 추가적인 `Buffer` 관련 API가 있습니다.


#### `buffer.atob(data)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferatobdata)

추가된 버전: v15.13.0, v14.17.0

[안정성: 3](https://nodejs.org/docs/latest/api/documentation.html#stability-index) - 레거시. 대신 `Buffer.from(data, 'base64')`를 사용하세요.

-   `data` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) Base64로 인코딩된 입력 문자열.

Base64로 인코딩된 데이터 문자열을 바이트로 디코딩하고, 그 바이트를 Latin-1 (ISO-8859-1)을 사용하여 문자열로 인코딩합니다.

`data`는 문자열로 강제 변환될 수 있는 모든 JavaScript 값이 될 수 있습니다.

**이 함수는 레거시 웹 플랫폼 API와의 호환성을 위해 제공되며, 새로운 코드에서는 절대 사용해서는 안 됩니다. 이 함수는 바이너리 데이터를 문자열로 표현하며, JavaScript에 타입 배열이 도입되기 전에 사용되었습니다. Node.js API를 사용하는 코드에서는 Base64로 인코딩된 문자열과 바이너리 데이터 간의 변환을 `Buffer.from(str, 'base64')`와 `buf.toString('base64')`를 사용하여 수행해야 합니다.**


#### `buffer.btoa(data)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferbtoadata)

추가된 버전: v15.13.0, v14.17.0

[안정성: 3](https://nodejs.org/docs/latest/api/documentation.html#stability-index) - 레거시. 대신 `buf.toString('base64')`를 사용하세요.

-   `data` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) ASCII (Latin1) 문자열.

Latin-1 (ISO-8859)을 사용하여 문자열을 바이트로 디코딩하고, 그 바이트를 Base64로 인코딩하여 문자열로 변환합니다.

`data`는 문자열로 강제 변환될 수 있는 모든 JavaScript 값이 될 수 있습니다.

**이 함수는 레거시 웹 플랫폼 API와의 호환성을 위해 제공되며, 새로운 코드에서는 절대 사용해서는 안 됩니다. 이 함수는 문자열을 사용하여 바이너리 데이터를 표현하며, JavaScript에 타입 배열이 도입되기 전에 만들어졌기 때문입니다. Node.js API를 사용하여 실행되는 코드에서는 Base64로 인코딩된 문자열과 바이너리 데이터 간의 변환을 `Buffer.from(str, 'base64')`와 `buf.toString('base64')`를 사용하여 수행해야 합니다.**


#### `buffer.isAscii(input)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferisasciiinput)

추가된 버전: v19.6.0, v18.15.0

-   `input` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)  
    검증할 입력값입니다.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  

이 함수는 `input`이 유효한 ASCII 인코딩 데이터만 포함하고 있거나 비어 있는 경우 `true`를 반환합니다.

`input`이 분리된 ArrayBuffer인 경우 예외를 발생시킵니다.


#### `buffer.isUtf8(input)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferisutf8input)

추가된 버전: v19.4.0, v18.14.0

-   `input` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray)  
    검증할 입력값입니다.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  

이 함수는 `input`이 유효한 UTF-8로 인코딩된 데이터만 포함하고 있을 경우 `true`를 반환합니다. `input`이 빈 값인 경우에도 `true`를 반환합니다.

`input`이 분리된 배열 버퍼(detached array buffer)일 경우 예외를 발생시킵니다.


#### `buffer.INSPECT_MAX_BYTES`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferinspect_max_bytes)

추가된 버전: v0.5.4

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `50`

`buf.inspect()`가 호출될 때 반환되는 최대 바이트 수를 반환합니다. 이 값은 사용자 모듈에서 재정의할 수 있습니다. `buf.inspect()`의 동작에 대한 자세한 내용은 [`util.inspect()`](https://nodejs.org/docs/latest/api/util.html#utilinspectobject-options)를 참고하세요.


#### `buffer.kMaxLength`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferkmaxlength)

추가된 버전: v3.0.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 단일 `Buffer` 인스턴스가 가질 수 있는 최대 크기.

[`buffer.constants.MAX_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_length)의 별칭입니다.


#### `buffer.kStringMaxLength`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferkstringmaxlength)

추가된 버전: v3.0.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 단일 `string` 인스턴스에 허용되는 최대 길이입니다.

[`buffer.constants.MAX_STRING_LENGTH`](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_string_length)의 별칭입니다.


#### `buffer.resolveObjectURL(id)`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferresolveobjecturlid)

추가된 버전: v16.7.0

-   `id` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `URL.createObjectURL()`을 호출하여 반환된 `'blob:nodedata:...'` URL 문자열
-   반환값: [`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob)

`'blob:nodedata:...'` URL과 연결된 [`<Blob>`](https://nodejs.org/docs/latest/api/buffer.html#class-blob) 객체를 반환합니다. 이 객체는 이전에 `URL.createObjectURL()`을 호출하여 등록된 것입니다.


#### `buffer.transcode(source, fromEnc, toEnc)`[#](https://nodejs.org/docs/latest/api/buffer.html#buffertranscodesource-fromenc-toenc)

- `source` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)  
  `Buffer` 또는 `Uint8Array` 인스턴스입니다.
  
- `fromEnc` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  현재 인코딩입니다.
  
- `toEnc` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
  목표 인코딩입니다.
  
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)  
  새로운 `Buffer` 인스턴스를 반환합니다.

주어진 `Buffer` 또는 `Uint8Array` 인스턴스를 한 문자 인코딩에서 다른 문자 인코딩으로 다시 인코딩합니다. 새로운 `Buffer` 인스턴스를 반환합니다.

`fromEnc` 또는 `toEnc`가 유효하지 않은 문자 인코딩을 지정하거나 `fromEnc`에서 `toEnc`로의 변환이 허용되지 않을 경우 예외를 던집니다.

`buffer.transcode()`가 지원하는 인코딩은 다음과 같습니다: `'ascii'`, `'utf8'`, `'utf16le'`, `'ucs2'`, `'latin1'`, `'binary'`.

트랜스코딩 과정에서 특정 바이트 시퀀스를 목표 인코딩으로 충분히 표현할 수 없는 경우, 대체 문자를 사용합니다. 예를 들어:

```js
import { Buffer, transcode } from 'node:buffer';

const newBuf = transcode(Buffer.from('€'), 'utf8', 'ascii');
console.log(newBuf.toString('ascii')); // 출력: '?'
```

유로 (`€`) 기호는 US-ASCII로 표현할 수 없기 때문에, 트랜스코딩된 `Buffer`에서 `?`로 대체됩니다.


#### 클래스: `SlowBuffer`[#](https://nodejs.org/docs/latest/api/buffer.html#class-slowbuffer)

**v6.0.0부터 deprecated됨**

[`Buffer.allocUnsafeSlow()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize)를 참고하세요. 이 클래스는 생성자가 항상 `SlowBuffer` 인스턴스가 아닌 `Buffer` 인스턴스를 반환했기 때문에, 엄밀히 말해 클래스라고 할 수 없습니다.


##### `new SlowBuffer(size)`[#](https://nodejs.org/docs/latest/api/buffer.html#new-slowbuffersize)

v6.0.0부터 더 이상 사용되지 않음(deprecated)

-   `size` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 새로운 `SlowBuffer`의 원하는 길이

[`Buffer.allocUnsafeSlow()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize)를 참고하세요.


#### Buffer 상수[#](https://nodejs.org/docs/latest/api/buffer.html#buffer-constants)

추가된 버전: v8.2.0


##### `buffer.constants.MAX_LENGTH`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_length)

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 단일 `Buffer` 인스턴스가 가질 수 있는 최대 크기입니다.

32비트 아키텍처에서는 현재 이 값이 2<sup>30</sup> - 1 (약 1 GiB)입니다.

64비트 아키텍처에서는 현재 이 값이 2<sup>53</sup> - 1 (약 8 PiB)입니다.

이 값은 내부적으로 [`v8::TypedArray::kMaxLength`](https://v8.github.io/api/head/classv8_1_1TypedArray.html#a54a48f4373da0850663c4393d843b9b0)를 반영합니다.

이 값은 [`buffer.kMaxLength`](https://nodejs.org/docs/latest/api/buffer.html#bufferkmaxlength)로도 사용할 수 있습니다.


##### `buffer.constants.MAX_STRING_LENGTH`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferconstantsmax_string_length)

추가된 버전: v8.2.0

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 단일 `string` 인스턴스가 가질 수 있는 최대 길이입니다.

이 값은 UTF-16 코드 단위로 계산된 `string` 원시 타입이 가질 수 있는 가장 큰 `length`를 나타냅니다.

이 값은 사용 중인 JS 엔진에 따라 달라질 수 있습니다.


### `Buffer.from()`, `Buffer.alloc()`, 그리고 `Buffer.allocUnsafe()`[#](https://nodejs.org/docs/latest/api/buffer.html#bufferfrom-bufferalloc-and-bufferallocunsafe)

Node.js 6.0.0 이전 버전에서는 `Buffer` 인스턴스를 `Buffer` 생성자 함수를 사용해 생성했습니다. 이 생성자는 전달된 인자에 따라 반환된 `Buffer`를 다르게 할당합니다.

-   `Buffer()`의 첫 번째 인자로 숫자를 전달하면 (예: `new Buffer(10)`) 지정된 크기의 새로운 `Buffer` 객체를 할당합니다. Node.js 8.0.0 이전에는 이러한 `Buffer` 인스턴스에 할당된 메모리가 초기화되지 않아 **민감한 데이터가 포함될 수 있습니다**. 따라서 이러한 `Buffer` 인스턴스는 반드시 [`buf.fill(0)`](https://nodejs.org/docs/latest/api/buffer.html#buffillvalue-offset-end-encoding)을 사용하거나 `Buffer` 전체에 데이터를 쓰는 방식으로 초기화해야 합니다. 이 동작은 성능 향상을 위해 **의도적으로 설계**되었지만, 개발 경험상 빠르지만 초기화되지 않은 `Buffer`와 느리지만 안전한 `Buffer`를 명확히 구분할 필요가 있었습니다. Node.js 8.0.0부터는 `Buffer(num)`과 `new Buffer(num)`이 초기화된 메모리를 가진 `Buffer`를 반환합니다.
-   첫 번째 인자로 문자열, 배열, 또는 `Buffer`를 전달하면 전달된 객체의 데이터를 복사하여 `Buffer`를 생성합니다.
-   [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)나 [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)를 전달하면 주어진 배열 버퍼와 메모리를 공유하는 `Buffer`를 반환합니다.

`new Buffer()`의 동작은 첫 번째 인자의 타입에 따라 다르기 때문에, 인자 검증이나 `Buffer` 초기화가 수행되지 않으면 애플리케이션에 보안 및 신뢰성 문제가 발생할 수 있습니다.

예를 들어, 공격자가 애플리케이션에 문자열 대신 숫자를 전달할 수 있다면, 애플리케이션은 `new Buffer("100")` 대신 `new Buffer(100)`을 호출하여 3바이트 버퍼 대신 100바이트 버퍼를 할당할 수 있습니다. 이는 JSON API 호출을 통해 흔히 발생할 수 있습니다. JSON은 숫자와 문자열 타입을 구분하기 때문에, 입력 검증이 충분하지 않은 애플리케이션에서는 항상 문자열을 받을 것으로 예상하지만 숫자가 주입될 수 있습니다. Node.js 8.0.0 이전에는 100바이트 버퍼에 임의의 기존 메모리 데이터가 포함될 수 있어, 원격 공격자에게 메모리 내 비밀 정보가 노출될 가능성이 있었습니다. Node.js 8.0.0부터는 데이터가 0으로 초기화되기 때문에 메모리 노출이 발생하지 않습니다. 그러나 여전히 서버가 매우 큰 버퍼를 할당하도록 유도하여 성능 저하나 메모리 고갈로 인한 충돌을 일으키는 등의 공격이 가능합니다.

`Buffer` 인스턴스 생성을 더 안전하고 오류가 적도록 만들기 위해, `new Buffer()` 생성자의 다양한 형태는 **더 이상 사용되지 않으며(deprecated)**, 대신 `Buffer.from()`, [`Buffer.alloc()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding), 그리고 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize) 메서드로 대체되었습니다.

*개발자는 기존의 `new Buffer()` 생성자 사용을 새로운 API 중 하나로 마이그레이션해야 합니다.*

-   [`Buffer.from(array)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray)는 제공된 옥텟(octets)의 **복사본**을 포함하는 새로운 `Buffer`를 반환합니다.
-   [`Buffer.from(arrayBuffer[, byteOffset[, length]])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length)는 주어진 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)와 **동일한 메모리를 공유**하는 새로운 `Buffer`를 반환합니다.
-   [`Buffer.from(buffer)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfrombuffer)는 주어진 `Buffer`의 내용을 **복사**한 새로운 `Buffer`를 반환합니다.
-   [`Buffer.from(string[, encoding])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding)는 제공된 문자열의 **복사본**을 포함하는 새로운 `Buffer`를 반환합니다.
-   [`Buffer.alloc(size[, fill[, encoding]])`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocsize-fill-encoding)는 지정된 크기의 초기화된 `Buffer`를 반환합니다. 이 메서드는 [`Buffer.allocUnsafe(size)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)보다 느리지만, 새로 생성된 `Buffer` 인스턴스에 민감한 데이터가 포함되지 않음을 보장합니다. `size`가 숫자가 아닌 경우 `TypeError`가 발생합니다.
-   [`Buffer.allocUnsafe(size)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)와 [`Buffer.allocUnsafeSlow(size)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize)는 각각 지정된 `size`의 초기화되지 않은 `Buffer`를 반환합니다. `Buffer`가 초기화되지 않았기 때문에 할당된 메모리 세그먼트에 민감한 데이터가 포함될 수 있습니다.

[`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize), [`Buffer.from(string)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromstring-encoding), [`Buffer.concat()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferconcatlist-totallength), 그리고 [`Buffer.from(array)`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferfromarray)가 반환한 `Buffer` 인스턴스는 `size`가 [`Buffer.poolSize`](https://nodejs.org/docs/latest/api/buffer.html#class-property-bufferpoolsize)의 절반 이하일 경우 **공유 내부 메모리 풀**에서 할당될 수 있습니다. 반면, [`Buffer.allocUnsafeSlow()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize)가 반환한 인스턴스는 절대 공유 내부 메모리 풀을 사용하지 않습니다.


#### `--zero-fill-buffers` 커맨드라인 옵션[#](https://nodejs.org/docs/latest/api/buffer.html#the---zero-fill-buffers-command-line-option)

추가된 버전: v5.10.0

Node.js는 `--zero-fill-buffers` 커맨드라인 옵션을 사용해 시작할 수 있습니다. 이 옵션을 사용하면 새로 할당된 `Buffer` 인스턴스가 기본적으로 생성 시 0으로 채워집니다. 이 옵션을 사용하지 않으면 [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize), [`Buffer.allocUnsafeSlow()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize), 그리고 `new SlowBuffer(size)`로 생성된 버퍼는 0으로 채워지지 않습니다. 이 플래그를 사용하면 성능에 측정 가능한 부정적인 영향을 미칠 수 있습니다. 새로 할당된 `Buffer` 인스턴스가 잠재적으로 민감한 이전 데이터를 포함하지 않도록 강제해야 할 때만 `--zero-fill-buffers` 옵션을 사용하세요.

```console
$ node --zero-fill-buffers > Buffer.allocUnsafe(5); 
```


#### `Buffer.allocUnsafe()`와 `Buffer.allocUnsafeSlow()`이 "안전하지 않은" 이유는 무엇인가요?

[`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)와 [`Buffer.allocUnsafeSlow()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafeslowsize)를 호출하면, 할당된 메모리 영역이 **초기화되지 않은 상태**로 남아 있습니다(즉, 0으로 채워지지 않음). 이 설계는 메모리 할당 속도를 매우 빠르게 만들지만, 할당된 메모리 영역에는 이전에 사용된 민감한 데이터가 포함되어 있을 가능성이 있습니다. [`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)로 생성된 `Buffer`를 사용할 때 메모리를 **완전히 덮어쓰지 않으면**, `Buffer` 메모리를 읽을 때 이전 데이터가 유출될 수 있습니다.

[`Buffer.allocUnsafe()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferallocunsafesize)를 사용하면 성능상의 이점이 분명하지만, 애플리케이션에 보안 취약점을 도입하지 않도록 **특별히 주의**해야 합니다.


