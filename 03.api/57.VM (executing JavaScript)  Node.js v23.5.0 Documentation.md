# Table of Contents

- [VM (자바스크립트 실행)](#vm-자바스크립트-실행)
    - [클래스: `vm.Script`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmscript)](#클래스-vmscripthttpsnodejsorgdocslatestapivmhtmlclass-vmscript)
      - [`new vm.Script(code[, options])`](#new-vmscriptcode-options)
      - [`script.cachedDataRejected`[#](https://nodejs.org/docs/latest/api/vm.html#scriptcacheddatarejected)](#scriptcacheddatarejectedhttpsnodejsorgdocslatestapivmhtmlscriptcacheddatarejected)
      - [`script.createCachedData()`[#](https://nodejs.org/docs/latest/api/vm.html#scriptcreatecacheddata)](#scriptcreatecacheddatahttpsnodejsorgdocslatestapivmhtmlscriptcreatecacheddata)
      - [`script.runInContext(contextifiedObject[, options])`](#scriptrunincontextcontextifiedobject-options)
      - [`script.runInNewContext([contextObject[, options]])`](#scriptruninnewcontextcontextobject-options)
      - [`script.runInThisContext([options])`](#scriptruninthiscontextoptions)
      - [`script.sourceMapURL`[#](https://nodejs.org/docs/latest/api/vm.html#scriptsourcemapurl)](#scriptsourcemapurlhttpsnodejsorgdocslatestapivmhtmlscriptsourcemapurl)
    - [클래스: `vm.Module`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule)](#클래스-vmmodulehttpsnodejsorgdocslatestapivmhtmlclass-vmmodule)
      - [`module.dependencySpecifiers`[#](https://nodejs.org/docs/latest/api/vm.html#moduledependencyspecifiers)](#moduledependencyspecifiershttpsnodejsorgdocslatestapivmhtmlmoduledependencyspecifiers)
      - [`module.error`[#](https://nodejs.org/docs/latest/api/vm.html#moduleerror)](#moduleerrorhttpsnodejsorgdocslatestapivmhtmlmoduleerror)
      - [`module.evaluate([options])`[#](https://nodejs.org/docs/latest/api/vm.html#moduleevaluateoptions)](#moduleevaluateoptionshttpsnodejsorgdocslatestapivmhtmlmoduleevaluateoptions)
      - [`module.identifier`[#](https://nodejs.org/docs/latest/api/vm.html#moduleidentifier)](#moduleidentifierhttpsnodejsorgdocslatestapivmhtmlmoduleidentifier)
      - [`module.link(linker)`[#](https://nodejs.org/docs/latest/api/vm.html#modulelinklinker)](#modulelinklinkerhttpsnodejsorgdocslatestapivmhtmlmodulelinklinker)
      - [`module.namespace`[#](https://nodejs.org/docs/latest/api/vm.html#modulenamespace)](#modulenamespacehttpsnodejsorgdocslatestapivmhtmlmodulenamespace)
      - [`module.status`[#](https://nodejs.org/docs/latest/api/vm.html#modulestatus)](#modulestatushttpsnodejsorgdocslatestapivmhtmlmodulestatus)
    - [클래스: `vm.SourceTextModule`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmsourcetextmodule)](#클래스-vmsourcetextmodulehttpsnodejsorgdocslatestapivmhtmlclass-vmsourcetextmodule)
      - [`new vm.SourceTextModule(code[, options])`](#new-vmsourcetextmodulecode-options)
      - [`sourceTextModule.createCachedData()`[#](https://nodejs.org/docs/latest/api/vm.html#sourcetextmodulecreatecacheddata)](#sourcetextmodulecreatecacheddatahttpsnodejsorgdocslatestapivmhtmlsourcetextmodulecreatecacheddata)
    - [클래스: `vm.SyntheticModule`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmsyntheticmodule)](#클래스-vmsyntheticmodulehttpsnodejsorgdocslatestapivmhtmlclass-vmsyntheticmodule)
      - [`new vm.SyntheticModule(exportNames, evaluateCallback[, options])`[#](https://nodejs.org/docs/latest/api/vm.html#new-vmsyntheticmoduleexportnames-evaluatecallback-options)](#new-vmsyntheticmoduleexportnames-evaluatecallback-optionshttpsnodejsorgdocslatestapivmhtmlnew-vmsyntheticmoduleexportnames-evaluatecallback-options)
      - [`syntheticModule.setExport(name, value)`[#](https://nodejs.org/docs/latest/api/vm.html#syntheticmodulesetexportname-value)](#syntheticmodulesetexportname-valuehttpsnodejsorgdocslatestapivmhtmlsyntheticmodulesetexportname-value)
    - [`vm.compileFunction(code[, params[, options]])`](#vmcompilefunctioncode-params-options)
    - [`vm.constants`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstants)](#vmconstantshttpsnodejsorgdocslatestapivmhtmlvmconstants)
      - [`vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader)](#vmconstantsuse_main_context_default_loaderhttpsnodejsorgdocslatestapivmhtmlvmconstantsuse_main_context_default_loader)
    - [`vm.createContext([contextObject[, options]])`](#vmcreatecontextcontextobject-options)
    - [`vm.isContext(object)`[#](https://nodejs.org/docs/latest/api/vm.html#vmiscontextobject)](#vmiscontextobjecthttpsnodejsorgdocslatestapivmhtmlvmiscontextobject)
    - [`vm.measureMemory([options])`](#vmmeasurememoryoptions)
    - [`vm.runInContext(code, contextifiedObject[, options])`](#vmrunincontextcode-contextifiedobject-options)
    - [`vm.runInNewContext(code[, contextObject[, options]])`](#vmruninnewcontextcode-contextobject-options)
    - [`vm.runInThisContext(code[, options])`](#vmruninthiscontextcode-options)
    - [예제: VM 내에서 HTTP 서버 실행하기](#예제-vm-내에서-http-서버-실행하기)
    - [객체를 "컨텍스트화"한다는 것은 무슨 의미일까요?](#객체를-컨텍스트화한다는-것은-무슨-의미일까요)
      - [`vm.constants.DONT_CONTEXTIFY`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify)](#vmconstantsdont_contextifyhttpsnodejsorgdocslatestapivmhtmlvmconstantsdont_contextify)
    - [비동기 작업과 Promise의 타임아웃 상호작용](#비동기-작업과-promise의-타임아웃-상호작용)
    - [컴파일 API에서 동적 `import()` 지원](#컴파일-api에서-동적-import-지원)
      - [`importModuleDynamically`가 `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`일 때[#](https://nodejs.org/docs/latest/api/vm.html#when-importmoduledynamically-is-vmconstantsuse_main_context_default_loader)](#importmoduledynamically가-vmconstantsuse_main_context_default_loader일-때httpsnodejsorgdocslatestapivmhtmlwhen-importmoduledynamically-is-vmconstantsuse_main_context_default_loader)
      - [`importModuleDynamically`가 함수일 때[#](https://nodejs.org/docs/latest/api/vm.html#when-importmoduledynamically-is-a-function)](#importmoduledynamically가-함수일-때httpsnodejsorgdocslatestapivmhtmlwhen-importmoduledynamically-is-a-function)

# VM (자바스크립트 실행)

**소스 코드:** [lib/vm.js](https://github.com/nodejs/node/blob/v23.5.0/lib/vm.js)

`node:vm` 모듈은 V8 가상 머신 컨텍스트 내에서 코드를 컴파일하고 실행할 수 있게 해줍니다.

**`node:vm` 모듈은 보안 메커니즘이 아닙니다. 신뢰할 수 없는 코드를 실행하는 데 사용하지 마세요.**

자바스크립트 코드는 즉시 컴파일하고 실행하거나, 컴파일한 후 나중에 실행할 수 있습니다.

일반적인 사용 사례는 코드를 다른 V8 컨텍스트에서 실행하는 것입니다. 이는 호출된 코드가 호출하는 코드와 다른 전역 객체를 가짐을 의미합니다.

객체를 [*컨텍스트화*](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)하여 컨텍스트를 제공할 수 있습니다. 호출된 코드는 컨텍스트 내의 모든 속성을 전역 변수처럼 취급합니다. 호출된 코드에 의해 전역 변수가 변경되면, 이 변경 사항은 컨텍스트 객체에 반영됩니다.

```js
const vm = require('node:vm');
const x = 1;
const context = { x: 2 };
vm.createContext(context); // 객체를 컨텍스트화합니다.
const code = 'x += 40; var y = 17;'; // `x`와 `y`는 컨텍스트 내의 전역 변수입니다.
// 초기에는 x의 값이 2입니다. 이는 context.x의 값이기 때문입니다.
vm.runInContext(code, context);
console.log(context.x); // 42
console.log(context.y); // 17
console.log(x); // 1; y는 정의되지 않았습니다.
```


### 클래스: `vm.Script`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmscript)

추가된 버전: v0.3.1

`vm.Script` 클래스의 인스턴스는 특정 컨텍스트에서 실행할 수 있는 사전 컴파일된 스크립트를 포함합니다.


#### `new vm.Script(code[, options])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 컴파일할 JavaScript 코드입니다.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    - `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 스크립트에서 생성된 스택 트레이스에 사용될 파일명을 지정합니다. **기본값:** `'evalmachine.<anonymous>'`.
    - `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 첫 번째 줄의 컬럼 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) V8의 코드 캐시 데이터를 포함한 `Buffer`, `TypedArray`, 또는 `DataView`를 제공합니다. 이 값이 제공되면, V8이 데이터를 수락했는지 여부에 따라 `cachedDataRejected` 값이 `true` 또는 `false`로 설정됩니다.
    - `produceCachedData` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정되고 `cachedData`가 없는 경우, V8은 `code`에 대한 코드 캐시 데이터를 생성하려고 시도합니다. 성공하면, V8의 코드 캐시 데이터를 포함한 `Buffer`가 생성되어 반환된 `vm.Script` 인스턴스의 `cachedData` 속성에 저장됩니다. 코드 캐시 데이터가 성공적으로 생성되었는지 여부에 따라 `cachedDataProduced` 값이 `true` 또는 `false`로 설정됩니다. 이 옵션은 `script.createCachedData()`를 대신 사용하는 것이 권장되며, **더 이상 사용되지 않습니다**. **기본값:** `false`.
    - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader) 이 스크립트를 평가하는 동안 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정하는 데 사용됩니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하는 것은 권장하지 않습니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.

`options`가 문자열인 경우, 파일명을 지정합니다.

새로운 `vm.Script` 객체를 생성하면 `code`가 컴파일되지만 실행되지는 않습니다. 컴파일된 `vm.Script`는 나중에 여러 번 실행할 수 있습니다. `code`는 어떤 전역 객체에도 바인딩되지 않으며, 각 실행 전에 해당 실행을 위해 바인딩됩니다.


#### `script.cachedDataRejected`[#](https://nodejs.org/docs/latest/api/vm.html#scriptcacheddatarejected)

추가된 버전: v5.7.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

`vm.Script`를 생성할 때 `cachedData`가 제공되면, 이 값은 V8이 데이터를 수락했는지 여부에 따라 `true` 또는 `false`로 설정됩니다. 그렇지 않은 경우 값은 `undefined`입니다.


#### `script.createCachedData()`[#](https://nodejs.org/docs/latest/api/vm.html#scriptcreatecacheddata)

추가된 버전: v10.6.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`Script` 생성자의 `cachedData` 옵션과 함께 사용할 수 있는 코드 캐시를 생성합니다. 이 메서드는 `Buffer`를 반환하며, 언제든지 여러 번 호출할 수 있습니다.

`Script`의 코드 캐시는 JavaScript에서 관찰 가능한 상태를 포함하지 않습니다. 따라서 코드 캐시는 스크립트 소스와 함께 안전하게 저장할 수 있으며, 여러 번 새로운 `Script` 인스턴스를 생성하는 데 사용할 수 있습니다.

`Script` 소스 내의 함수는 지연 컴파일(lazily compiled)로 표시될 수 있으며, 이 경우 `Script` 생성 시점에 컴파일되지 않습니다. 이러한 함수는 처음 호출될 때 컴파일됩니다. 코드 캐시는 V8이 현재 알고 있는 `Script`에 대한 메타데이터를 직렬화하여, 향후 컴파일 속도를 높이는 데 사용할 수 있습니다.

```js
const script = new vm.Script(`
    function add(a, b) {
        return a + b;
    }
    const x = add(1, 2);
`);

const cacheWithoutAdd = script.createCachedData();
// `cacheWithoutAdd`에서는 `add()` 함수가 호출 시 완전히 컴파일되도록 표시되어 있습니다.

script.runInThisContext();

const cacheWithAdd = script.createCachedData();
// `cacheWithAdd`에는 완전히 컴파일된 `add()` 함수가 포함되어 있습니다.
```


#### `script.runInContext(contextifiedObject[, options])`

- `contextifiedObject` [`<Object>`] `vm.createContext()` 메서드가 반환한 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체입니다.
- `options` [`<Object>`]
  - `displayErrors` [`<boolean>`] `true`로 설정하면, 코드 컴파일 중에 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생했을 때, 스택 트레이스에 오류를 일으킨 코드 라인이 추가됩니다. **기본값:** `true`.
  - `timeout` [`<integer>`] 코드 실행을 종료하기 전까지의 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`] `true`로 설정하면, `SIGINT` (Ctrl+C)를 받았을 때 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행 후에는 다시 작동합니다. **기본값:** `false`.
- 반환값: [`<any>`] 스크립트에서 실행된 마지막 문장의 결과를 반환합니다.

`vm.Script` 객체에 포함된 컴파일된 코드를 주어진 `contextifiedObject` 내에서 실행하고 결과를 반환합니다. 실행된 코드는 로컬 스코프에 접근할 수 없습니다.

다음 예제는 전역 변수를 증가시키고, 다른 전역 변수의 값을 설정하는 코드를 컴파일한 후, 여러 번 실행합니다. 전역 변수들은 `context` 객체 안에 포함되어 있습니다.

```js
const vm = require('node:vm');
const context = { animal: 'cat', count: 2 };
const script = new vm.Script('count += 1; name = "kitty";');

vm.createContext(context);

for (let i = 0; i < 10; ++i) {
    script.runInContext(context);
}

console.log(context); // 출력: { animal: 'cat', count: 12, name: 'kitty' }
```

`timeout` 또는 `breakOnSigint` 옵션을 사용하면 새로운 이벤트 루프와 해당 스레드가 시작되며, 이는 성능에 약간의 오버헤드를 발생시킵니다.


#### `script.runInNewContext([contextObject[, options]])`

- `contextObject` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<vm.constants.DONT_CONTEXTIFY>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  `vm.constants.DONT_CONTEXTIFY` 또는 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)될 객체를 지정합니다. `undefined`일 경우, 이전 버전과의 호환성을 위해 빈 컨텍스트화된 객체가 생성됩니다.

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `displayErrors` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    `true`로 설정하면, 코드 컴파일 중 에러가 발생했을 때 스택 트레이스에 에러를 발생시킨 코드 라인이 포함됩니다. **기본값:** `true`.
  - `timeout` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)  
    코드 실행을 종료하기 전까지의 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 `Error`가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
    `true`로 설정하면, `SIGINT`(Ctrl+C)를 받았을 때 실행이 종료되고 `Error`가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행 후에는 다시 작동합니다. **기본값:** `false`.
  - `contextName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    새로 생성된 컨텍스트의 사람이 읽을 수 있는 이름입니다. **기본값:** `'VM Context i'`, 여기서 `i`는 생성된 컨텍스트의 오름차순 숫자 인덱스입니다.
  - `contextOrigin` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    새로 생성된 컨텍스트에 해당하는 [오리진](https://developer.mozilla.org/en-US/docs/Glossary/Origin)을 표시 목적으로 지정합니다. 오리진은 URL 형식이어야 하지만, 스키마, 호스트, 포트(필요한 경우)만 포함해야 합니다. 예를 들어, [`url.origin`](https://nodejs.org/docs/latest/api/url.html#urlorigin) 속성의 값과 같습니다. 특히, 이 문자열은 경로를 나타내는 마지막 슬래시를 생략해야 합니다. **기본값:** `''`.
  - `contextCodeGeneration` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `strings` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
      `false`로 설정하면, `eval` 또는 함수 생성자(`Function`, `GeneratorFunction` 등)를 호출할 때 `EvalError`가 발생합니다. **기본값:** `true`.
    - `wasm` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
      `false`로 설정하면, WebAssembly 모듈을 컴파일하려고 할 때 `WebAssembly.CompileError`가 발생합니다. **기본값:** `true`.
  - `microtaskMode` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    `afterEvaluate`로 설정하면, 스크립트 실행 후 즉시 마이크로태스크(`Promise` 및 `async function`을 통해 예약된 작업)가 실행됩니다. 이 경우 마이크로태스크는 `timeout` 및 `breakOnSigint` 범위에 포함됩니다.

- 반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
  스크립트에서 실행된 마지막 문장의 결과를 반환합니다.

이 메서드는 `script.runInContext(vm.createContext(options), options)`의 단축 형태입니다. 이 메서드는 다음과 같은 작업을 한 번에 수행합니다:

1. 새로운 컨텍스트를 생성합니다.
2. `contextObject`가 객체인 경우, 새로운 컨텍스트로 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)합니다. `contextObject`가 `undefined`인 경우, 새로운 객체를 생성하고 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)합니다. `contextObject`가 `vm.constants.DONT_CONTEXTIFY`인 경우, 아무것도 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)하지 않습니다.
3. `vm.Script` 객체에 포함된 컴파일된 코드를 생성된 컨텍스트 내에서 실행합니다. 이 코드는 이 메서드가 호출된 스코프에 접근할 수 없습니다.
4. 결과를 반환합니다.

다음 예제는 전역 변수를 설정하는 코드를 컴파일한 후, 서로 다른 컨텍스트에서 여러 번 실행합니다. 전역 변수는 각각의 개별 컨텍스트에 설정되고 포함됩니다.

```js
const vm = require('node:vm');
const script = new vm.Script('globalVar = "set"');
const contexts = [{}, {}, {}];

contexts.forEach((context) => {
    script.runInNewContext(context);
});

console.log(contexts); // 출력: [{ globalVar: 'set' }, { globalVar: 'set' }, { globalVar: 'set' }]

// 컨텍스트화된 객체로부터 컨텍스트를 생성하면 에러가 발생합니다.
// vm.constants.DONT_CONTEXTIFY를 사용하면 일반적인 전역 객체로 컨텍스트를 생성할 수 있으며, 이 객체는 동결될 수 있습니다.
const freezeScript = new vm.Script('Object.freeze(globalThis); globalThis;');
const frozenContext = freezeScript.runInNewContext(vm.constants.DONT_CONTEXTIFY);
```


#### `script.runInThisContext([options])`

- `options` [`<Object>`]
  - `displayErrors` [`<boolean>`] `true`로 설정하면, `code`를 컴파일하는 동안 에러가 발생했을 때 스택 트레이스에 에러를 일으킨 코드 라인이 추가됩니다. **기본값:** `true`.
  - `timeout` [`<integer>`] 코드 실행을 종료하기 전까지의 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`] `true`로 설정하면, `SIGINT`(Ctrl+C)를 받았을 때 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행이 끝난 후에는 다시 작동합니다. **기본값:** `false`.
- 반환값: [`<any>`] 스크립트에서 실행된 마지막 문장의 결과를 반환합니다.

`vm.Script`에 포함된 컴파일된 코드를 현재 `global` 객체의 컨텍스트에서 실행합니다. 실행된 코드는 로컬 스코프에 접근할 수 없지만, 현재 `global` 객체에는 접근할 수 있습니다.

다음 예제는 `global` 변수를 증가시키는 코드를 컴파일하고, 그 코드를 여러 번 실행합니다:

```js
const vm = require('node:vm');

global.globalVar = 0;
const script = new vm.Script('globalVar += 1', { filename: 'myfile.vm' });

for (let i = 0; i < 1000; ++i) {
    script.runInThisContext();
}

console.log(globalVar); // 1000
```


#### `script.sourceMapURL`[#](https://nodejs.org/docs/latest/api/vm.html#scriptsourcemapurl)

추가된 버전: v19.1.0, v18.13.0

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

스크립트가 소스 맵 매직 주석을 포함한 소스로부터 컴파일될 때, 이 속성은 소스 맵의 URL로 설정됩니다.

```js
import vm from 'node:vm';

const script = new vm.Script(`
    function myFunc() {}
    //# sourceMappingURL=sourcemap.json
`);

console.log(script.sourceMapURL); // 출력: sourcemap.json
```


### 클래스: `vm.Module`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule)

추가된 버전: v13.0.0, v12.16.0

이 기능은 `--experimental-vm-modules` 커맨드라인 플래그가 활성화된 경우에만 사용할 수 있습니다.

`vm.Module` 클래스는 VM 컨텍스트에서 ECMAScript 모듈을 사용하기 위한 저수준 인터페이스를 제공합니다. 이 클래스는 ECMAScript 명세에서 정의된 [모듈 레코드](https://262.ecma-international.org/14.0/#sec-abstract-module-records)와 유사한 `vm.Script` 클래스의 대응체입니다.

그러나 `vm.Script`와 달리, 모든 `vm.Module` 객체는 생성 시점부터 컨텍스트에 바인딩됩니다. `vm.Module` 객체에 대한 작업은 본질적으로 비동기적이며, 이는 `vm.Script` 객체의 동기적 특성과 대조됩니다. `vm.Module` 객체를 다룰 때는 'async' 함수를 사용하는 것이 도움이 됩니다.

`vm.Module` 객체를 사용하려면 세 가지 단계가 필요합니다: 생성/파싱, 링크, 그리고 평가. 이 세 단계는 아래 예제에서 설명됩니다.

이 구현은 [ECMAScript 모듈 로더](https://nodejs.org/docs/latest/api/esm.html#modules-ecmascript-modules)보다 더 낮은 수준에 위치합니다. 또한 현재는 로더와 상호작용할 방법이 없지만, 지원이 계획되어 있습니다.

```js
import vm from 'node:vm';

const contextifiedObject = vm.createContext({
  secret: 42,
  print: console.log,
});

// 1단계: 생성/파싱
// 새로운 `vm.SourceTextModule` 객체를 생성하여 모듈을 만듭니다.
// 이 과정에서 제공된 소스 텍스트를 파싱하며, 문제가 발생하면 `SyntaxError`를 던집니다.
// 기본적으로 모듈은 최상위 컨텍스트에서 생성되지만, 여기서는 `contextifiedObject`를 이 모듈의 컨텍스트로 지정합니다.
// 이 예제에서는 모듈 "foo"에서 기본 내보내기를 가져와 로컬 바인딩 "secret"에 넣습니다.
const bar = new vm.SourceTextModule(
  `import s from 'foo'; s; print(s);`,
  { context: contextifiedObject }
);

// 2단계: 링크
// 이 모듈의 의존성을 링크합니다.
// 제공된 링크 콜백(링커)은 두 개의 인자를 받습니다: 부모 모듈(`bar`)과 가져온 모듈의 스펙ifier 문자열.
// 콜백은 제공된 스펙ifier에 해당하는 모듈을 반환해야 하며, 이에 대한 요구사항은 `module.link()`에 문서화되어 있습니다.
// 반환된 모듈에 대해 링크가 시작되지 않았다면, 동일한 링크 콜백이 반환된 모듈에 대해 호출됩니다.
// 의존성이 없는 최상위 모듈도 명시적으로 링크해야 하지만, 이 경우 콜백은 호출되지 않습니다.
// `link()` 메서드는 링크가 완료되면 resolve되는 Promise를 반환합니다.
// 참고: 이 예제는 링크 함수가 호출될 때마다 새로운 "foo" 모듈을 생성하는 인위적인 예제입니다.
// 실제 모듈 시스템에서는 중복 모듈을 방지하기 위해 캐시를 사용할 것입니다.
async function linker(specifier, referencingModule) {
  if (specifier === 'foo') {
    return new vm.SourceTextModule(
      `export default secret;`,
      { context: referencingModule.context }
    );
  }
  throw new Error(`Unable to resolve dependency: ${specifier}`);
}

await bar.link(linker);

// 3단계: 평가
// 모듈을 평가합니다. `evaluate()` 메서드는 모듈 평가가 완료된 후 resolve되는 Promise를 반환합니다.
// 42를 출력합니다.
await bar.evaluate();
```


#### `module.dependencySpecifiers`[#](https://nodejs.org/docs/latest/api/vm.html#moduledependencyspecifiers)

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 모듈의 모든 의존성을 나타내는 식별자들입니다. 반환된 배열은 변경할 수 없도록 고정(frozen)되어 있습니다.

이 값은 ECMAScript 명세에서 [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)의 `[[RequestedModules]]` 필드에 해당합니다.


#### `module.error`[#](https://nodejs.org/docs/latest/api/vm.html#moduleerror)

-   [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

`module.status`가 `'errored'`인 경우, 이 속성은 모듈 평가 중 발생한 예외를 포함합니다. 상태가 다른 값이라면, 이 속성에 접근하면 예외가 발생합니다.

`throw undefined;`와의 모호성을 피하기 위해, 예외가 발생하지 않은 경우에는 `undefined` 값을 사용할 수 없습니다.

이 속성은 ECMAScript 명세의 [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)에서 `[[EvaluationError]]` 필드에 해당합니다.


#### `module.evaluate([options])`[#](https://nodejs.org/docs/latest/api/vm.html#moduleevaluateoptions)

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `timeout` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 실행을 종료하기 전에 평가할 시간을 밀리초 단위로 지정합니다. 실행이 중단되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면 `SIGINT` (Ctrl+C)를 받았을 때 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행이 끝난 후에는 다시 작동합니다. **기본값:** `false`.
- 반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 성공 시 `undefined`로 이행됩니다.

모듈을 평가합니다.

이 메서드는 모듈이 연결된 후에 호출해야 합니다. 그렇지 않으면 거부됩니다. 이미 평가된 모듈에서도 호출할 수 있습니다. 이 경우 초기 평가가 성공적으로 끝났다면(`module.status`가 `'evaluated'`) 아무 작업도 수행하지 않고, 초기 평가에서 예외가 발생했다면(`module.status`가 `'errored'`) 해당 예외를 다시 발생시킵니다.

이 메서드는 모듈이 평가 중일 때(`module.status`가 `'evaluating'`) 호출할 수 없습니다.

이 메서드는 ECMAScript 명세에서 [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)의 [Evaluate() 구체적 메서드](https://tc39.es/ecma262/#sec-moduleevaluation) 필드에 해당합니다.


#### `module.identifier`[#](https://nodejs.org/docs/latest/api/vm.html#moduleidentifier)

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

현재 모듈의 식별자로, 생성자에서 설정된 값을 가집니다.


#### `module.link(linker)`[#](https://nodejs.org/docs/latest/api/vm.html#modulelinklinker)

-   `linker` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
    -   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청된 모듈의 지정자:
        
        ```js
        import foo from 'foo'; // ^^^^^ 모듈 지정자
        ```
        
    -   `referencingModule` [`<vm.Module>`](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule) `link()`가 호출된 `Module` 객체.
        
    -   `extra` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
        
        -   `attributes` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 속성 데이터:
            
            ```js
            import foo from 'foo' with { name: 'value' }; // ^^^^^^^^^^^^^^^^^ 속성
            ```
            
            ECMA-262에 따르면, 지원되지 않는 속성이 있을 경우 호스트는 에러를 발생시켜야 합니다.
        -   `assert` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `extra.attributes`의 별칭.
    -   반환값: [`<vm.Module>`](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule) | [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
        
-   반환값: [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

모듈 의존성을 연결합니다. 이 메서드는 평가 전에 호출해야 하며, 모듈당 한 번만 호출할 수 있습니다.

이 함수는 `Module` 객체 또는 `Module` 객체로 해결되는 `Promise`를 반환해야 합니다. 반환된 `Module`은 다음 두 가지 조건을 만족해야 합니다:

-   부모 `Module`과 동일한 컨텍스트에 속해야 합니다.
-   `status`가 `'errored'` 상태가 아니어야 합니다.

반환된 `Module`의 `status`가 `'unlinked'`인 경우, 이 메서드는 동일한 `linker` 함수를 사용해 반환된 `Module`에 대해 재귀적으로 호출됩니다.

`link()`는 모든 연결 인스턴스가 유효한 `Module`로 해결되면 해결되는 `Promise`를 반환합니다. 만약 `linker` 함수가 예외를 던지거나 유효하지 않은 `Module`을 반환하면 `Promise`는 거부됩니다.

`linker` 함수는 ECMAScript 명세의 [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) 추상 연산과 대략적으로 일치하지만, 몇 가지 주요 차이점이 있습니다:

-   `linker` 함수는 비동기적으로 동작할 수 있지만, [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule)은 동기적입니다.

모듈 연결 중 사용되는 실제 [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) 구현은 연결 중에 연결된 모듈을 반환합니다. 이 시점에서 모든 모듈은 이미 완전히 연결되었기 때문에, [HostResolveImportedModule](https://tc39.es/ecma262/#sec-hostresolveimportedmodule) 구현은 명세에 따라 완전히 동기적입니다.

이 메서드는 ECMAScript 명세의 [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)의 [Link() 구체적 메서드](https://tc39.es/ecma262/#sec-moduledeclarationlinking) 필드에 해당합니다.


#### `module.namespace`[#](https://nodejs.org/docs/latest/api/vm.html#modulenamespace)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

모듈의 네임스페이스 객체입니다. 이 객체는 모듈 연결(`module.link()`)이 완료된 후에만 사용할 수 있습니다.

ECMAScript 명세의 [GetModuleNamespace](https://tc39.es/ecma262/#sec-getmodulenamespace) 추상 연산에 해당합니다.


#### `module.status`[#](https://nodejs.org/docs/latest/api/vm.html#modulestatus)

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

모듈의 현재 상태를 나타냅니다. 다음 중 하나의 값이 됩니다:

-   `'unlinked'`: `module.link()`가 아직 호출되지 않은 상태입니다.
    
-   `'linking'`: `module.link()`가 호출되었지만, 링커 함수가 반환한 모든 Promise가 아직 해결되지 않은 상태입니다.
    
-   `'linked'`: 모듈이 성공적으로 링크되었고, 모든 의존성도 링크되었지만, `module.evaluate()`가 아직 호출되지 않은 상태입니다.
    
-   `'evaluating'`: 모듈이 `module.evaluate()`를 통해 평가 중이거나 상위 모듈에서 평가 중인 상태입니다.
    
-   `'evaluated'`: 모듈이 성공적으로 평가된 상태입니다.
    
-   `'errored'`: 모듈이 평가되었지만, 예외가 발생한 상태입니다.
    

`'errored'`를 제외한 이 상태 문자열은 명세서의 [Cyclic Module Record](https://tc39.es/ecma262/#sec-cyclic-module-records)의 `[[Status]]` 필드와 일치합니다. `'errored'`는 명세서에서 `'evaluated'`에 해당하지만, `[[EvaluationError]]`가 `undefined`가 아닌 값으로 설정된 경우입니다.


### 클래스: `vm.SourceTextModule`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmsourcetextmodule)

추가된 버전: v9.6.0

이 기능은 `--experimental-vm-modules` 커맨드라인 플래그가 활성화된 경우에만 사용할 수 있습니다.

-   상속: [`<vm.Module>`](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule)

`vm.SourceTextModule` 클래스는 ECMAScript 명세에서 정의된 [Source Text Module Record](https://tc39.es/ecma262/#sec-source-text-module-records)를 제공합니다.


#### `new vm.SourceTextModule(code[, options])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 파싱할 JavaScript 모듈 코드
- `options`
  - `identifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 스택 트레이스에 사용될 문자열. **기본값:** `'vm:module(i)'` (여기서 `i`는 컨텍스트별로 증가하는 인덱스)
  - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) V8의 코드 캐시 데이터를 제공하는 `Buffer`, `TypedArray`, 또는 `DataView`. `code`는 이 `cachedData`가 생성된 모듈과 동일해야 함.
  - `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `vm.createContext()` 메서드로 반환된 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체. 이 모듈을 컴파일하고 평가할 때 사용. 컨텍스트가 지정되지 않으면 현재 실행 컨텍스트에서 평가됨.
  - `lineOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 모듈에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋. **기본값:** `0`
  - `columnOffset` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 모듈에서 생성된 스택 트레이스에 표시될 첫 줄 컬럼 번호 오프셋. **기본값:** `0`
  - `initializeImportMeta` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 이 모듈을 평가하는 동안 `import.meta`를 초기화하기 위해 호출됨.
    - `meta` [`<import.meta>`](https://nodejs.org/docs/latest/api/esm.html#importmeta)
    - `module` [`<vm.SourceTextModule>`](https://nodejs.org/docs/latest/api/vm.html#class-vmsourcetextmodule)
  - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 이 모듈을 평가하는 동안 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정. 이 옵션은 실험적인 모듈 API의 일부. 프로덕션 환경에서 사용하지 않는 것을 권장. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis) 참조.

새로운 `SourceTextModule` 인스턴스를 생성한다.

`import.meta` 객체에 할당된 프로퍼티 중 객체인 경우, 모듈이 지정된 `context` 외부의 정보에 접근할 수 있게 할 수 있다. 특정 컨텍스트에서 객체를 생성하려면 `vm.runInContext()`를 사용하라.

```js
import vm from 'node:vm';

const contextifiedObject = vm.createContext({ secret: 42 });

const module = new vm.SourceTextModule(
  'Object.getPrototypeOf(import.meta.prop).secret = secret;',
  {
    initializeImportMeta(meta) {
      // 주의: 이 객체는 최상위 컨텍스트에서 생성됨.
      // 따라서 Object.getPrototypeOf(import.meta.prop)는
      // 컨텍스트화된 객체가 아닌 최상위 컨텍스트의 Object.prototype을 가리킴.
      meta.prop = {};
    },
  }
);

// 모듈에 의존성이 없으므로 링커 함수는 호출되지 않음.
await module.link(() => {});
await module.evaluate();

// 이제 Object.prototype.secret은 42가 됨.
//
// 이 문제를 해결하려면 위의
// meta.prop = {};
// 를 아래 코드로 대체하라.
// meta.prop = vm.runInContext('{}', contextifiedObject);
```


#### `sourceTextModule.createCachedData()`[#](https://nodejs.org/docs/latest/api/vm.html#sourcetextmodulecreatecacheddata)

추가된 버전: v13.7.0, v12.17.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`SourceTextModule` 생성자의 `cachedData` 옵션과 함께 사용할 수 있는 코드 캐시를 생성합니다. 이 메서드는 모듈이 평가되기 전에 여러 번 호출할 수 있습니다. 반환값은 `Buffer`입니다.

`SourceTextModule`의 코드 캐시는 자바스크립트에서 관찰 가능한 상태를 포함하지 않습니다. 따라서 이 코드 캐시는 스크립트 소스와 함께 안전하게 저장할 수 있으며, 여러 번 새로운 `SourceTextModule` 인스턴스를 생성하는 데 사용할 수 있습니다.

`SourceTextModule` 소스 내의 함수는 지연 컴파일(lazily compiled)로 표시될 수 있으며, 이 경우 `SourceTextModule`이 생성될 때 컴파일되지 않습니다. 이러한 함수는 처음 호출될 때 컴파일됩니다. 코드 캐시는 V8이 현재 알고 있는 `SourceTextModule`에 대한 메타데이터를 직렬화하여, 향후 컴파일 속도를 높이는 데 사용할 수 있습니다.

```js
// 초기 모듈 생성
const module = new vm.SourceTextModule('const a = 1;');

// 이 모듈에서 캐시 데이터 생성
const cachedData = module.createCachedData();

// 캐시 데이터를 사용하여 새로운 모듈 생성. 코드는 동일해야 함.
const module2 = new vm.SourceTextModule('const a = 1;', { cachedData });
```


### 클래스: `vm.SyntheticModule`[#](https://nodejs.org/docs/latest/api/vm.html#class-vmsyntheticmodule)

추가된 버전: v13.0.0, v12.16.0

이 기능은 `--experimental-vm-modules` 커맨드라인 플래그가 활성화된 경우에만 사용할 수 있습니다.

-   상속: [`<vm.Module>`](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule)

`vm.SyntheticModule` 클래스는 WebIDL 명세에서 정의된 [Synthetic Module Record](https://heycam.github.io/webidl/#synthetic-module-records)를 제공합니다. 합성 모듈의 목적은 비자바스크립트 소스를 ECMAScript 모듈 그래프에 노출시키기 위한 일반적인 인터페이스를 제공하는 것입니다.

```js
const vm = require('node:vm');
const source = '{ "a": 1 }';
const module = new vm.SyntheticModule(['default'], function() {
    const obj = JSON.parse(source);
    this.setExport('default', obj);
});
// `module`을 링크에 사용...
```


#### `new vm.SyntheticModule(exportNames, evaluateCallback[, options])`[#](https://nodejs.org/docs/latest/api/vm.html#new-vmsyntheticmoduleexportnames-evaluatecallback-options)

추가된 버전: v13.0.0, v12.16.0

-   `exportNames` [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 모듈에서 내보낼 이름들의 배열입니다.
-   `evaluateCallback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 모듈이 평가될 때 호출되는 함수입니다.
-   `options`
    -   `identifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 스택 트레이스에 사용될 문자열입니다. **기본값:** `'vm:module(i)'` 여기서 `i`는 컨텍스트에 따라 증가하는 인덱스입니다.
    -   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `vm.createContext()` 메서드로 반환된 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체로, 이 `Module`을 컴파일하고 평가할 때 사용됩니다.

새로운 `SyntheticModule` 인스턴스를 생성합니다.

이 인스턴스의 exports에 할당된 객체들은 모듈을 가져오는 쪽에서 지정된 `context` 외부의 정보에 접근할 수 있도록 허용할 수 있습니다. 특정 컨텍스트에서 객체를 생성하려면 `vm.runInContext()`를 사용하세요.


#### `syntheticModule.setExport(name, value)`[#](https://nodejs.org/docs/latest/api/vm.html#syntheticmodulesetexportname-value)

추가된 버전: v13.0.0, v12.16.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 설정할 내보내기의 이름
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 내보내기에 설정할 값

이 메서드는 모듈이 연결된 후 내보내기 값을 설정하는 데 사용됩니다. 모듈이 연결되기 전에 호출하면 [`ERR_VM_MODULE_STATUS`](https://nodejs.org/docs/latest/api/errors.html#err_vm_module_status) 오류가 발생합니다.

```js
import vm from 'node:vm';

const m = new vm.SyntheticModule(['x'], () => {
    m.setExport('x', 1);
});

await m.link(() => {});
await m.evaluate();

assert.strictEqual(m.namespace.x, 1);
```


### `vm.compileFunction(code[, params[, options]])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 컴파일할 함수의 본문입니다.
- `params` [`<string[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 함수의 매개변수로 사용될 문자열 배열입니다.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 스크립트에서 생성된 스택 트레이스에 사용될 파일명을 지정합니다. **기본값:** `''`.
    - `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 첫 번째 줄의 컬럼 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) V8의 코드 캐시 데이터를 포함한 `Buffer`, `TypedArray`, 또는 `DataView`를 제공합니다. 이 데이터는 동일한 `code`와 `params`로 이전에 호출된 [`vm.compileFunction()`](https://nodejs.org/docs/latest/api/vm.html#vmcompilefunctioncode-params-options)에서 생성되어야 합니다.
    - `produceCachedData` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 새로운 캐시 데이터를 생성할지 여부를 지정합니다. **기본값:** `false`.
    - `parsingContext` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 함수가 컴파일될 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체입니다.
    - `contextExtensions` [`<Object[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 컴파일 중에 적용될 컨텍스트 확장(현재 스코프를 감싸는 객체)의 배열입니다. **기본값:** `[]`.
- `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader) 이 함수 평가 중에 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정하는 데 사용됩니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하지 않는 것을 권장합니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.
- 반환값: [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

주어진 코드를 제공된 컨텍스트(컨텍스트가 제공되지 않으면 현재 컨텍스트 사용)에서 컴파일하고, 주어진 `params`로 감싸진 함수로 반환합니다.


### `vm.constants`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstants)

추가된 버전: v21.7.0, v20.12.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

VM(Virtual Machine) 작업에 자주 사용되는 상수들을 담은 객체를 반환합니다.


#### `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader)

추가된 버전: v21.7.0, v20.12.0

이 상수는 `vm.Script`와 `vm.compileFunction()`의 `importModuleDynamically` 옵션으로 사용할 수 있습니다. 이를 통해 Node.js는 메인 컨텍스트의 기본 ESM 로더를 사용하여 요청된 모듈을 로드합니다.

자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참고하세요.


### `vm.createContext([contextObject[, options]])`

- `contextObject` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<vm.constants.DONT_CONTEXTIFY>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  `vm.constants.DONT_CONTEXTIFY` 또는 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)될 객체를 전달합니다. `undefined`일 경우, 이전 버전과의 호환성을 위해 빈 컨텍스트화된 객체가 생성됩니다.

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    새로 생성된 컨텍스트의 사람이 읽을 수 있는 이름입니다. **기본값:** `'VM Context i'`, 여기서 `i`는 생성된 컨텍스트의 오름차순 숫자 인덱스입니다.
  - `origin` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    새로 생성된 컨텍스트에 해당하는 [오리진](https://developer.mozilla.org/en-US/docs/Glossary/Origin)입니다. 오리진은 URL과 같이 스키마, 호스트, 포트(필요한 경우)만 포함하여 표시됩니다. [`URL`](https://nodejs.org/docs/latest/api/url.html#class-url) 객체의 [`url.origin`](https://nodejs.org/docs/latest/api/url.html#urlorigin) 속성 값과 유사합니다. 특히, 이 문자열은 경로를 나타내는 마지막 슬래시를 생략해야 합니다. **기본값:** `''`.
  - `codeGeneration` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `strings` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
      `false`로 설정하면 `eval` 또는 함수 생성자(`Function`, `GeneratorFunction` 등)를 호출할 때 `EvalError`가 발생합니다. **기본값:** `true`.
    - `wasm` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
      `false`로 설정하면 WebAssembly 모듈을 컴파일하려고 할 때 `WebAssembly.CompileError`가 발생합니다. **기본값:** `true`.
  - `microtaskMode` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)  
    `afterEvaluate`로 설정하면, 스크립트가 [`script.runInContext()`](https://nodejs.org/docs/latest/api/vm.html#scriptrunincontextcontextifiedobject-options)를 통해 실행된 직후에 마이크로태스크(`Promise` 및 `async function`을 통해 예약된 작업)가 실행됩니다. 이 경우 마이크로태스크는 `timeout` 및 `breakOnSigint` 범위에 포함됩니다.
  - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader)  
    이 컨텍스트에서 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정합니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하지 않는 것을 권장합니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.

- 반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
  컨텍스트화된 객체를 반환합니다.

`contextObject`가 객체인 경우, `vm.createContext()` 메서드는 [해당 객체를 준비](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)하고 [`vm.runInContext()`](https://nodejs.org/docs/latest/api/vm.html#vmrunincontextcode-contextifiedobject-options) 또는 [`script.runInContext()`](https://nodejs.org/docs/latest/api/vm.html#scriptrunincontextcontextifiedobject-options) 호출에서 사용할 수 있도록 참조를 반환합니다. 이러한 스크립트 내부에서 전역 객체는 `contextObject`로 감싸지며, 기존의 모든 속성을 유지하면서도 표준 [전역 객체](https://es5.github.io/#x15.1)가 가진 내장 객체와 함수를 갖게 됩니다. vm 모듈로 실행된 스크립트 외부에서는 전역 변수가 변경되지 않습니다.

```js
const vm = require('node:vm');
global.globalVar = 3;
const context = { globalVar: 1 };
vm.createContext(context);
vm.runInContext('globalVar *= 2;', context);
console.log(context); // 출력: { globalVar: 2 }
console.log(global.globalVar); // 출력: 3
```

`contextObject`가 생략되거나 명시적으로 `undefined`로 전달되면, 새로운 빈 [컨텍스트화된](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체가 반환됩니다.

새로 생성된 컨텍스트의 전역 객체가 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)되면, 일반적인 전역 객체와 비교하여 몇 가지 특이점이 있습니다. 예를 들어, 이 객체는 동결(freeze)할 수 없습니다. 이러한 특이점 없이 컨텍스트를 생성하려면 `contextObject` 인자로 [`vm.constants.DONT_CONTEXTIFY`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify)를 전달하세요. 자세한 내용은 [`vm.constants.DONT_CONTEXTIFY`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify) 문서를 참조하세요.

`vm.createContext()` 메서드는 주로 여러 스크립트를 실행할 수 있는 단일 컨텍스트를 생성하는 데 유용합니다. 예를 들어, 웹 브라우저를 에뮬레이트할 때 이 메서드를 사용하여 윈도우의 전역 객체를 나타내는 단일 컨텍스트를 생성한 후, 모든 `<script>` 태그를 해당 컨텍스트 내에서 함께 실행할 수 있습니다.

제공된 컨텍스트의 `name`과 `origin`은 Inspector API를 통해 확인할 수 있습니다.


### `vm.isContext(object)`[#](https://nodejs.org/docs/latest/api/vm.html#vmiscontextobject)

추가된 버전: v0.11.7

-   `object` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

주어진 `object`가 [`vm.createContext()`](https://nodejs.org/docs/latest/api/vm.html#vmcreatecontextcontextobject-options)를 사용해 컨텍스트화되었거나, [`vm.constants.DONT_CONTEXTIFY`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify)를 사용해 생성된 컨텍스트의 전역 객체인 경우 `true`를 반환합니다.


### `vm.measureMemory([options])`

추가된 버전: v13.10.0

현재 V8 isolate에서 알려진 모든 컨텍스트 또는 메인 컨텍스트가 사용하는 메모리를 측정합니다.

-   `options` [`<Object>`] (선택 사항)
    -   `mode` [`<string>`] `'summary'` 또는 `'detailed'` 중 하나. `'summary'` 모드에서는 메인 컨텍스트의 메모리만 반환됩니다. `'detailed'` 모드에서는 현재 V8 isolate에서 알려진 모든 컨텍스트의 메모리가 반환됩니다. **기본값:** `'summary'`
    -   `execution` [`<string>`] `'default'` 또는 `'eager'` 중 하나. `'default'` 실행 모드에서는 다음 예정된 가비지 컬렉션이 시작될 때까지 Promise가 해결되지 않으며, 이는 시간이 걸릴 수 있습니다(또는 프로그램이 다음 GC 전에 종료되면 해결되지 않을 수도 있습니다). `'eager'` 실행 모드에서는 메모리를 측정하기 위해 즉시 GC가 시작됩니다. **기본값:** `'default'`
-   반환값: [`<Promise>`] 메모리가 성공적으로 측정되면, Promise는 메모리 사용량 정보를 포함하는 객체와 함께 해결됩니다. 그렇지 않으면 `ERR_CONTEXT_NOT_INITIALIZED` 오류와 함께 거부됩니다.

반환된 Promise가 해결될 때 반환되는 객체의 형식은 V8 엔진에 따라 다르며, V8 버전마다 변경될 수 있습니다.

반환된 결과는 `v8.getHeapSpaceStatistics()`가 반환하는 통계와 다릅니다. `vm.measureMemory()`는 현재 V8 엔진 인스턴스에서 각 V8 특정 컨텍스트가 접근할 수 있는 메모리를 측정하는 반면, `v8.getHeapSpaceStatistics()`는 현재 V8 인스턴스에서 각 힙 공간이 차지하는 메모리를 측정합니다.

```js
const vm = require('node:vm');

// 메인 컨텍스트가 사용하는 메모리를 측정합니다.
vm.measureMemory({ mode: 'summary' }) // 이는 vm.measureMemory()와 동일합니다.
    .then((result) => {
        // 현재 형식은 다음과 같습니다:
        // {
        //     total: {
        //         jsMemoryEstimate: 2418479,
        //         jsMemoryRange: [ 2418479, 2745799 ]
        //     }
        // }
        console.log(result);
    });

const context = vm.createContext({ a: 1 });

vm.measureMemory({ mode: 'detailed', execution: 'eager' })
    .then((result) => {
        // 측정이 완료될 때까지 컨텍스트가 GC되지 않도록 참조합니다.
        console.log(context.a);
        // {
        //     total: {
        //         jsMemoryEstimate: 2574732,
        //         jsMemoryRange: [ 2574732, 2904372 ]
        //     },
        //     current: {
        //         jsMemoryEstimate: 2438996,
        //         jsMemoryRange: [ 2438996, 2768636 ]
        //     },
        //     other: [
        //         {
        //             jsMemoryEstimate: 135736,
        //             jsMemoryRange: [ 135736, 465376 ]
        //         }
        //     ]
        // }
        console.log(result);
    });
```


### `vm.runInContext(code, contextifiedObject[, options])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 컴파일하고 실행할 자바스크립트 코드입니다.
- `contextifiedObject` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 코드가 컴파일되고 실행될 때 `global`로 사용될 [contextified](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체입니다.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
  - `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 스크립트에서 생성된 스택 트레이스에 사용될 파일명을 지정합니다. **기본값:** `'evalmachine.<anonymous>'`.
  - `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋을 지정합니다. **기본값:** `0`.
  - `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 첫 번째 줄의 컬럼 번호 오프셋을 지정합니다. **기본값:** `0`.
  - `displayErrors` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, 코드 컴파일 중에 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생했을 때, 오류를 일으킨 코드 줄이 스택 트레이스에 포함됩니다. **기본값:** `true`.
  - `timeout` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 코드 실행을 종료하기 전에 실행할 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, `SIGINT` (Ctrl+C)를 받았을 때 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행 후에는 다시 작동합니다. **기본값:** `false`.
  - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 제공된 소스에 대한 V8의 코드 캐시 데이터를 포함하는 `Buffer`, `TypedArray`, 또는 `DataView`를 선택적으로 제공합니다.
  - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader) `import()`가 호출될 때 이 스크립트 평가 중에 모듈을 어떻게 로드할지 지정하는 데 사용됩니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하지 않는 것을 권장합니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.

`vm.runInContext()` 메서드는 `code`를 컴파일하고, `contextifiedObject`의 컨텍스트 내에서 실행한 후 결과를 반환합니다. 실행 중인 코드는 로컬 스코프에 접근할 수 없습니다. `contextifiedObject` 객체는 반드시 이전에 [`vm.createContext()`](https://nodejs.org/docs/latest/api/vm.html#vmcreatecontextcontextobject-options) 메서드를 사용하여 [contextified](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)되어 있어야 합니다.

`options`가 문자열인 경우, 파일명을 지정합니다.

다음 예제는 하나의 [contextified](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object) 객체를 사용하여 여러 스크립트를 컴파일하고 실행합니다:

```js
const vm = require('node:vm');
const contextObject = { globalVar: 1 };
vm.createContext(contextObject);

for (let i = 0; i < 10; ++i) {
    vm.runInContext('globalVar *= 2;', contextObject);
}

console.log(contextObject); // 출력: { globalVar: 1024 }
```


### `vm.runInNewContext(code[, contextObject[, options]])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 컴파일하고 실행할 자바스크립트 코드입니다.
- `contextObject` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<vm.constants.DONT_CONTEXTIFY>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) [`vm.constants.DONT_CONTEXTIFY`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify) 또는 새로운 컨텍스트로 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)될 객체입니다. `undefined`인 경우, 이전 버전과의 호환성을 위해 빈 컨텍스트화된 객체가 생성됩니다.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    - `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 스크립트에서 생성된 스택 트레이스에 사용될 파일명을 지정합니다. **기본값:** `'evalmachine.<anonymous>'`.
    - `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 첫 번째 줄의 컬럼 번호 오프셋을 지정합니다. **기본값:** `0`.
    - `displayErrors` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`인 경우, `code`를 컴파일하는 동안 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생하면, 오류를 일으킨 코드 줄이 스택 트레이스에 첨부됩니다. **기본값:** `true`.
    - `timeout` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `code`를 실행한 후 종료하기 전까지의 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
    - `breakOnSigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`인 경우, `SIGINT`(Ctrl+C)를 받으면 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행 후에는 다시 작동합니다. **기본값:** `false`.
    - `contextName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 새로 생성된 컨텍스트의 사람이 읽을 수 있는 이름입니다. **기본값:** `'VM Context i'`, 여기서 `i`는 생성된 컨텍스트의 오름차순 숫자 인덱스입니다.
    - `contextOrigin` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 새로 생성된 컨텍스트에 해당하는 [오리진](https://developer.mozilla.org/en-US/docs/Glossary/Origin)입니다. 오리진은 URL과 같이 스키마, 호스트, 포트(필요한 경우)만 포함하여 표시됩니다. [`URL`](https://nodejs.org/docs/latest/api/url.html#class-url) 객체의 [`url.origin`](https://nodejs.org/docs/latest/api/url.html#urlorigin) 속성 값과 유사합니다. 특히, 이 문자열은 경로를 나타내는 후행 슬래시를 생략해야 합니다. **기본값:** `''`.
    - `contextCodeGeneration` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
        - `strings` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`로 설정하면 `eval` 또는 함수 생성자(`Function`, `GeneratorFunction` 등)를 호출할 때 `EvalError`가 발생합니다. **기본값:** `true`.
        - `wasm` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`로 설정하면 WebAssembly 모듈을 컴파일하려고 할 때 `WebAssembly.CompileError`가 발생합니다. **기본값:** `true`.
    - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 제공된 소스에 대한 V8의 코드 캐시 데이터를 포함하는 `Buffer`, `TypedArray`, 또는 `DataView`를 제공합니다.
    - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader) 이 스크립트를 평가하는 동안 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정하는 데 사용됩니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하지 않는 것을 권장합니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.
    - `microtaskMode` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `afterEvaluate`로 설정하면, 스크립트 실행 후 즉시 마이크로태스크(`Promise` 및 `async function`을 통해 예약된 태스크)가 실행됩니다. 이 경우 마이크로태스크는 `timeout` 및 `breakOnSigint` 범위에 포함됩니다.
- 반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 스크립트에서 실행된 마지막 문장의 결과입니다.

이 메서드는 `(new vm.Script(code, options)).runInContext(vm.createContext(options), options)`의 단축 형태입니다. `options`가 문자열인 경우, 파일명을 지정합니다.

이 메서드는 다음과 같은 작업을 수행합니다:

1. 새로운 컨텍스트를 생성합니다.
2. `contextObject`가 객체인 경우, 새로운 컨텍스트로 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)합니다. `contextObject`가 `undefined`인 경우, 새로운 객체를 생성하고 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)합니다. `contextObject`가 [`vm.constants.DONT_CONTEXTIFY`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify)인 경우, 아무것도 [컨텍스트화](https://nodejs.org/docs/latest/api/vm.html#what-does-it-mean-to-contextify-an-object)하지 않습니다.
3. 코드를 `vm.Script`로 컴파일합니다.
4. 생성된 컨텍스트 내에서 컴파일된 코드를 실행합니다. 이 코드는 이 메서드가 호출된 스코프에 접근할 수 없습니다.
5. 결과를 반환합니다.

다음 예제는 전역 변수를 증가시키고 새로운 변수를 설정하는 코드를 컴파일하고 실행합니다. 이 전역 변수들은 `contextObject`에 포함됩니다.

```js
const vm = require('node:vm');
const contextObject = { animal: 'cat', count: 2 };

vm.runInNewContext('count += 1; name = "kitty"', contextObject);
console.log(contextObject); // 출력: { animal: 'cat', count: 3, name: 'kitty' }

// 컨텍스트가 컨텍스트화된 객체에서 생성된 경우, 이 코드는 오류를 발생시킵니다.
// vm.constants.DONT_CONTEXTIFY는 일반적인 전역 객체로 컨텍스트를 생성할 수 있게 해줍니다.
const frozenContext = vm.runInNewContext('Object.freeze(globalThis); globalThis;', vm.constants.DONT_CONTEXTIFY);
```


### `vm.runInThisContext(code[, options])`

- `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 컴파일하고 실행할 자바스크립트 코드입니다.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
  - `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 스크립트에서 생성된 스택 트레이스에 사용될 파일명을 지정합니다. **기본값:** `'evalmachine.<anonymous>'`.
  - `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 줄 번호 오프셋을 지정합니다. **기본값:** `0`.
  - `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 이 스크립트에서 생성된 스택 트레이스에 표시될 첫 줄의 컬럼 번호 오프셋을 지정합니다. **기본값:** `0`.
  - `displayErrors` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, `code`를 컴파일하는 동안 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생했을 때, 오류를 일으킨 코드 줄이 스택 트레이스에 포함됩니다. **기본값:** `true`.
  - `timeout` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `code`를 실행한 후 종료하기 전까지의 시간을 밀리초 단위로 지정합니다. 실행이 종료되면 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 이 값은 반드시 양의 정수여야 합니다.
  - `breakOnSigint` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면, `SIGINT` (Ctrl+C)를 받았을 때 실행이 종료되고 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)가 발생합니다. 스크립트 실행 중에는 `process.on('SIGINT')`를 통해 연결된 기존 핸들러가 비활성화되지만, 실행 후에는 다시 작동합니다. **기본값:** `false`.
  - `cachedData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 제공된 소스에 대한 V8의 코드 캐시 데이터를 포함하는 `Buffer`, `TypedArray`, 또는 `DataView`를 선택적으로 제공합니다.
  - `importModuleDynamically` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER>`](https://nodejs.org/docs/latest/api/vm.html#vmconstantsuse_main_context_default_loader) 이 스크립트를 평가하는 동안 `import()`가 호출될 때 모듈을 어떻게 로드할지 지정하는 데 사용됩니다. 이 옵션은 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하지 않는 것을 권장합니다. 자세한 내용은 [컴파일 API에서 동적 `import()` 지원](https://nodejs.org/docs/latest/api/vm.html#support-of-dynamic-import-in-compilation-apis)을 참조하세요.
- 반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 스크립트에서 실행된 마지막 문장의 결과를 반환합니다.

`vm.runInThisContext()`는 `code`를 컴파일하고 현재 `global` 컨텍스트 내에서 실행한 후 결과를 반환합니다. 실행된 코드는 로컬 스코프에 접근할 수 없지만, 현재 `global` 객체에는 접근할 수 있습니다.

`options`가 문자열인 경우, 파일명을 지정합니다.

다음 예제는 `vm.runInThisContext()`와 자바스크립트 [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval) 함수를 사용하여 동일한 코드를 실행하는 방법을 보여줍니다:

```js
const vm = require('node:vm');
let localVar = 'initial value';

const vmResult = vm.runInThisContext('localVar = "vm";');
console.log(`vmResult: '${vmResult}', localVar: '${localVar}'`);
// 출력: vmResult: 'vm', localVar: 'initial value'

const evalResult = eval('localVar = "eval";');
console.log(`evalResult: '${evalResult}', localVar: '${localVar}'`);
// 출력: evalResult: 'eval', localVar: 'eval'
```

`vm.runInThisContext()`는 로컬 스코프에 접근할 수 없기 때문에 `localVar` 값은 변경되지 않습니다. 반면에 [`eval()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval)은 로컬 스코프에 접근할 수 있으므로 `localVar` 값이 변경됩니다. 이렇게 `vm.runInThisContext()`는 간접적인 `eval()` 호출(예: `(0,eval)('code')`)과 유사하게 동작합니다.


### 예제: VM 내에서 HTTP 서버 실행하기

[`script.runInThisContext()`](https://nodejs.org/docs/latest/api/vm.html#scriptruninthiscontextoptions) 또는 [`vm.runInThisContext()`](https://nodejs.org/docs/latest/api/vm.html#vmruninthiscontextcode-options)를 사용할 때, 코드는 현재 V8 전역 컨텍스트 내에서 실행됩니다. 이 VM 컨텍스트에 전달된 코드는 독립된 스코프를 갖게 됩니다.

`node:http` 모듈을 사용하여 간단한 웹 서버를 실행하려면, 컨텍스트에 전달된 코드가 스스로 `require('node:http')`를 호출하거나, `node:http` 모듈에 대한 참조를 전달받아야 합니다. 예를 들어:

```js
'use strict';
const vm = require('node:vm');

const code = `
  ((require) => {
    const http = require('node:http');
    http.createServer((request, response) => {
      response.writeHead(200, { 'Content-Type': 'text/plain' });
      response.end('Hello World\\n');
    }).listen(8124);
    console.log('Server running at http://127.0.0.1:8124/');
  })
`;

vm.runInThisContext(code)(require);
```

위 예제에서 `require()`는 전달된 컨텍스트와 상태를 공유합니다. 이는 신뢰할 수 없는 코드가 실행될 때 원치 않는 방식으로 컨텍스트 내 객체를 변경하는 등의 위험을 초래할 수 있습니다.


### 객체를 "컨텍스트화"한다는 것은 무슨 의미일까요?

Node.js에서 실행되는 모든 자바스크립트 코드는 "컨텍스트"라는 범위 내에서 동작합니다. [V8 Embedder's Guide](https://v8.dev/docs/embed#contexts)에 따르면:

> V8에서 컨텍스트는 별개이고 서로 관련 없는 자바스크립트 애플리케이션이 단일 V8 인스턴스 내에서 실행될 수 있도록 하는 실행 환경입니다. 여러분은 자바스크립트 코드를 실행할 컨텍스트를 명시적으로 지정해야 합니다.

`vm.createContext()` 메서드가 객체와 함께 호출되면, `contextObject` 인자는 새로운 V8 컨텍스트 인스턴스의 전역 객체를 감싸는 데 사용됩니다. (`contextObject`가 `undefined`인 경우, 현재 컨텍스트에서 새로운 객체가 생성된 후 컨텍스트화됩니다.) 이 V8 컨텍스트는 `node:vm` 모듈의 메서드를 사용해 실행되는 코드에 독립된 전역 환경을 제공합니다. V8 컨텍스트를 생성하고 외부 컨텍스트의 `contextObject`와 연결하는 과정을 이 문서에서는 객체를 "컨텍스트화"한다고 표현합니다.

컨텍스트화는 해당 컨텍스트 내의 `globalThis` 값에 몇 가지 특이점을 도입합니다. 예를 들어, `globalThis`는 고정(freeze)할 수 없으며, 외부 컨텍스트의 `contextObject`와 참조 동일하지 않습니다.

```js
const vm = require('node:vm');

// `contextObject` 옵션이 undefined일 경우 전역 객체가 컨텍스트화됩니다.
const context = vm.createContext();
console.log(vm.runInContext('globalThis', context) === context); // false

// 컨텍스트화된 전역 객체는 고정할 수 없습니다.
try {
  vm.runInContext('Object.freeze(globalThis);', context);
} catch (e) {
  console.log(e); // TypeError: Cannot freeze
}

console.log(vm.runInContext('globalThis.foo = 1; foo;', context)); // 1
```

일반적인 전역 객체를 가진 컨텍스트를 생성하고, 외부 컨텍스트에서 더 적은 특이점을 가진 전역 프록시에 접근하려면, `contextObject` 인자로 `vm.constants.DONT_CONTEXTIFY`를 지정하면 됩니다.


#### `vm.constants.DONT_CONTEXTIFY`[#](https://nodejs.org/docs/latest/api/vm.html#vmconstantsdont_contextify)

이 상수는 vm API에서 `contextObject` 인자로 사용될 때, Node.js가 전역 객체를 Node.js 특유의 방식으로 감싸지 않고 컨텍스트를 생성하도록 지시합니다. 그 결과, 새로운 컨텍스트 내의 `globalThis` 값은 일반적인 전역 객체와 더 유사하게 동작합니다.

```js
const vm = require('node:vm');

// vm.constants.DONT_CONTEXTIFY를 사용하여 전역 객체를 고정합니다.
const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);
vm.runInContext('Object.freeze(globalThis);', context);

try {
  vm.runInContext('bar = 1; bar;', context);
} catch (e) {
  console.log(e); // Uncaught ReferenceError: bar is not defined
}
```

`vm.constants.DONT_CONTEXTIFY`가 [`vm.createContext()`](https://nodejs.org/docs/latest/api/vm.html#vmcreatecontextcontextobject-options)의 `contextObject` 인자로 사용되면, 반환된 객체는 새로 생성된 컨텍스트의 전역 객체에 대한 프록시와 유사한 객체입니다. 이 객체는 Node.js 특유의 동작이 적으며, 새로운 컨텍스트 내의 `globalThis` 값과 참조 동일합니다. 또한 컨텍스트 외부에서 수정할 수 있고, 새로운 컨텍스트의 내장 객체에 직접 접근할 수 있습니다.

```js
const vm = require('node:vm');
const context = vm.createContext(vm.constants.DONT_CONTEXTIFY);

// 반환된 객체는 새로운 컨텍스트의 globalThis와 참조 동일합니다.
console.log(vm.runInContext('globalThis', context) === context); // true

// 새로운 컨텍스트의 전역 객체에 직접 접근할 수 있습니다.
console.log(context.Array); // [Function: Array]

vm.runInContext('foo = 1;', context);
console.log(context.foo); // 1

context.bar = 1;
console.log(vm.runInContext('bar;', context)); // 1

// 객체를 고정하면 내부 컨텍스트에도 영향을 미칩니다.
Object.freeze(context);
try {
  vm.runInContext('baz = 1; baz;', context);
} catch (e) {
  console.log(e); // Uncaught ReferenceError: baz is not defined
}
```


### 비동기 작업과 Promise의 타임아웃 상호작용

`Promise`와 `async function`은 자바스크립트 엔진이 비동기적으로 실행할 작업을 예약할 수 있습니다. 기본적으로 이 작업들은 현재 스택에 있는 모든 자바스크립트 함수가 실행을 마친 후에 실행됩니다. 이로 인해 `timeout`과 `breakOnSigint` 옵션의 기능을 벗어날 수 있습니다.

예를 들어, 다음 코드는 `vm.runInNewContext()`를 사용해 5밀리초의 타임아웃으로 실행되며, Promise가 해결된 후 무한 루프를 예약합니다. 이 예약된 루프는 타임아웃에 의해 중단되지 않습니다:

```js
const vm = require('node:vm');

function loop() {
    console.log('entering loop');
    while (1) console.log(Date.now());
}

vm.runInNewContext(
    'Promise.resolve().then(() => loop());',
    { loop, console },
    { timeout: 5 },
);

// 이 메시지는 'entering loop' 이전에 출력됩니다 (!)
console.log('done executing');
```

이 문제는 `Context`를 생성하는 코드에 `microtaskMode: 'afterEvaluate'`를 전달하여 해결할 수 있습니다:

```js
const vm = require('node:vm');

function loop() {
    while (1) console.log(Date.now());
}

vm.runInNewContext(
    'Promise.resolve().then(() => loop());',
    { loop, console },
    { timeout: 5, microtaskMode: 'afterEvaluate' },
);
```

이 경우, `promise.then()`을 통해 예약된 마이크로태스크는 `vm.runInNewContext()`에서 반환되기 전에 실행되며, `timeout` 기능에 의해 중단됩니다. 이는 `vm.Context`에서 실행되는 코드에만 적용되므로, 예를 들어 [`vm.runInThisContext()`](https://nodejs.org/docs/latest/api/vm.html#vmruninthiscontextcode-options)는 이 옵션을 사용하지 않습니다.

Promise 콜백은 생성된 컨텍스트의 마이크로태스크 큐에 추가됩니다. 예를 들어, 위 예제에서 `() => loop()`를 `loop`로 대체하면, `loop`는 외부(메인) 컨텍스트의 함수이므로 전역 마이크로태스크 큐에 추가됩니다. 따라서 이 경우에도 타임아웃을 벗어날 수 있습니다.

`process.nextTick()`, `queueMicrotask()`, `setTimeout()`, `setImmediate()`와 같은 비동기 스케줄링 함수가 `vm.Context` 내부에서 사용 가능하다면, 이 함수들에 전달된 함수는 모든 컨텍스트가 공유하는 전역 큐에 추가됩니다. 따라서 이 함수들에 전달된 콜백도 타임아웃을 통해 제어할 수 없습니다.


### 컴파일 API에서 동적 `import()` 지원

다음 API들은 `importModuleDynamically` 옵션을 지원하여, vm 모듈로 컴파일된 코드에서 동적 `import()`를 사용할 수 있게 합니다.

-   `new vm.Script`
-   `vm.compileFunction()`
-   `new vm.SourceTextModule`
-   `vm.runInThisContext()`
-   `vm.runInContext()`
-   `vm.runInNewContext()`
-   `vm.createContext()`

이 옵션은 아직 실험적인 모듈 API의 일부입니다. 프로덕션 환경에서 사용하는 것을 권장하지 않습니다.


`importModuleDynamically` 옵션이 지정되지 않았거나 `undefined`인 경우, `import()`를 포함한 코드는 여전히 vm API를 통해 컴파일할 수 있습니다. 하지만 컴파일된 코드가 실행되고 실제로 `import()`를 호출하면, 결과는 [`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING`](https://nodejs.org/docs/latest/api/errors.html#err_vm_dynamic_import_callback_missing) 오류와 함께 거부됩니다.


#### `importModuleDynamically`가 `vm.constants.USE_MAIN_CONTEXT_DEFAULT_LOADER`일 때[#](https://nodejs.org/docs/latest/api/vm.html#when-importmoduledynamically-is-vmconstantsuse_main_context_default_loader)

이 옵션은 현재 `vm.SourceTextModule`에서 지원되지 않습니다.

이 옵션을 사용하면 컴파일된 코드에서 `import()`가 시작될 때, Node.js는 메인 컨텍스트의 기본 ESM 로더를 사용하여 요청된 모듈을 로드하고 실행 중인 코드에 반환합니다.

이를 통해 컴파일 중인 코드가 `fs`나 `http`와 같은 Node.js 내장 모듈에 접근할 수 있습니다. 코드가 다른 컨텍스트에서 실행되는 경우, 메인 컨텍스트에서 로드된 모듈로 생성된 객체는 여전히 메인 컨텍스트에 속하며, 새로운 컨텍스트의 내장 클래스의 인스턴스가 아니라는 점에 유의해야 합니다.

```js
import { Script, constants } from 'node:vm';

const script = new Script(
  'import("node:fs").then(({readFile}) => readFile instanceof Function)',
  { importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER }
);

// false: 메인 컨텍스트에서 로드된 URL은 새로운 컨텍스트에서 Function 클래스의 인스턴스가 아닙니다.
script.runInNewContext().then(console.log);
```

이 옵션은 스크립트나 함수가 사용자 모듈을 로드할 수 있도록 합니다:

```js
import { Script, constants } from 'node:vm';
import { resolve } from 'node:path';
import { writeFileSync } from 'node:fs';

// 현재 스크립트가 실행되는 디렉토리에 test.js와 test.txt를 작성합니다.
writeFileSync(resolve(import.meta.dirname, 'test.mjs'), 'export const filename = "./test.json";');
writeFileSync(resolve(import.meta.dirname, 'test.json'), '{"hello": "world"}');

// test.mjs를 로드한 후 test.json을 로드하는 스크립트를 컴파일합니다.
// 스크립트가 같은 디렉토리에 있는 것처럼 동작합니다.
const script = new Script(
  `(async function() {
    const { filename } = await import('./test.mjs');
    return import(filename, { with: { type: 'json' } })
  })();`,
  {
    filename: resolve(import.meta.dirname, 'test-with-default.js'),
    importModuleDynamically: constants.USE_MAIN_CONTEXT_DEFAULT_LOADER,
  }
);

// { default: { hello: 'world' } }
script.runInThisContext().then(console.log);
```

메인 컨텍스트의 기본 로더를 사용하여 사용자 모듈을 로드할 때 주의할 점이 몇 가지 있습니다:

1.  모듈의 경로는 `vm.Script`나 `vm.compileFunction()`에 전달된 `filename` 옵션을 기준으로 해석됩니다. 이 해석은 절대 경로나 URL 문자열인 `filename`과 함께 작동합니다. `filename`이 절대 경로나 URL 문자열이 아니거나 정의되지 않은 경우, 해석은 프로세스의 현재 작업 디렉토리를 기준으로 합니다. `vm.createContext()`의 경우, 이 옵션은 참조 스크립트나 모듈이 없을 때만 사용되므로 해석은 항상 현재 작업 디렉토리를 기준으로 합니다.
2.  특정 경로로 해석되는 `filename`의 경우, 프로세스가 해당 경로에서 특정 모듈을 로드하면 결과가 캐시될 수 있으며, 동일한 경로에서 동일한 모듈을 다시 로드하면 같은 결과가 반환됩니다. `filename`이 URL 문자열인 경우, 검색 매개변수가 다르면 캐시가 적용되지 않습니다. URL 문자열이 아닌 `filename`의 경우, 현재 캐시 동작을 우회할 방법이 없습니다.


#### `importModuleDynamically`가 함수일 때[#](https://nodejs.org/docs/latest/api/vm.html#when-importmoduledynamically-is-a-function)

`importModuleDynamically`가 함수로 설정되면, 컴파일된 코드에서 `import()`가 호출될 때 이 함수가 실행됩니다. 이를 통해 사용자는 요청된 모듈을 어떻게 컴파일하고 평가할지 커스텀할 수 있습니다. 현재 이 기능을 사용하려면 Node.js 인스턴스를 `--experimental-vm-modules` 플래그와 함께 실행해야 합니다. 이 플래그가 설정되지 않으면, 이 콜백은 무시됩니다. 만약 평가된 코드에서 실제로 `import()`를 호출하면, 결과는 [`ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING_FLAG`](https://nodejs.org/docs/latest/api/errors.html#err_vm_dynamic_import_callback_missing_flag) 오류와 함께 거부됩니다.

`importModuleDynamically(specifier, referrer, importAttributes)` 콜백은 다음과 같은 시그니처를 가집니다:

-   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): `import()`에 전달된 스펙ifier
-   `referrer` [`<vm.Script>`](https://nodejs.org/docs/latest/api/vm.html#class-vmscript) | [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<vm.SourceTextModule>`](https://nodejs.org/docs/latest/api/vm.html#class-vmsourcetextmodule) | [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): `new vm.Script`, `vm.runInThisContext`, `vm.runInContext`, `vm.runInNewContext`의 경우 컴파일된 `vm.Script`입니다. `vm.compileFunction`의 경우 컴파일된 `Function`, `new vm.SourceTextModule`의 경우 컴파일된 `vm.SourceTextModule`, 그리고 `vm.createContext()`의 경우 컨텍스트 `Object`입니다.
-   `importAttributes` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): [`optionsExpression`](https://tc39.es/proposal-import-attributes/#sec-evaluate-import-call) 옵션 파라미터에 전달된 `"with"` 값입니다. 값이 제공되지 않았다면 빈 객체가 됩니다.
-   반환값: [`<Module Namespace Object>`](https://tc39.github.io/ecma262/#sec-module-namespace-exotic-objects) | [`<vm.Module>`](https://nodejs.org/docs/latest/api/vm.html#class-vmmodule): 오류 추적을 활용하고 `then` 함수를 내보내는 네임스페이스 문제를 피하기 위해 `vm.Module`을 반환하는 것이 권장됩니다.

```js
// 이 스크립트는 --experimental-vm-modules 플래그와 함께 실행되어야 합니다.
import { Script, SyntheticModule } from 'node:vm';

const script = new Script('import("foo.json", { with: { type: "json" } })', {
    async importModuleDynamically(specifier, referrer, importAttributes) {
        console.log(specifier); // 'foo.json'
        console.log(referrer); // 컴파일된 스크립트
        console.log(importAttributes); // { type: 'json' }

        const m = new SyntheticModule(['bar'], () => {});
        await m.link(() => {});
        m.setExport('bar', { hello: 'world' });
        return m;
    },
});

const result = await script.runInThisContext();
console.log(result); // { bar: { hello: 'world' } }
```


