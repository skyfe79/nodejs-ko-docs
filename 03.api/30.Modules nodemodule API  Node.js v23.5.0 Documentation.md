# Table of Contents

- [모듈: node:module API](#모듈-nodemodule-api)
    - [`Module` 객체](#module-객체)
      - [`module.builtinModules`](#modulebuiltinmodules)
      - [`module.createRequire(filename)`](#modulecreaterequirefilename)
      - [`module.findPackageJSON(specifier[, base])`](#modulefindpackagejsonspecifier-base)
      - [`module.isBuiltin(moduleName)`](#moduleisbuiltinmodulename)
      - [`module.register(specifier, parentURL)`](#moduleregisterspecifier-parenturl)
      - [`module.registerHooks(options)`](#moduleregisterhooksoptions)
      - [`module.stripTypeScriptTypes(code[, options])`](#modulestriptypescripttypescode-options)
      - [`module.syncBuiltinESMExports()`](#modulesyncbuiltinesmexports)
    - [모듈 컴파일 캐시](#모듈-컴파일-캐시)
      - [`module.constants.compileCacheStatus`](#moduleconstantscompilecachestatus)
      - [`module.enableCompileCache([cacheDir])`](#moduleenablecompilecachecachedir)
      - [`module.flushCompileCache()`](#moduleflushcompilecache)
      - [`module.getCompileCacheDir()`](#modulegetcompilecachedir)
    - [커스텀 훅(Customization Hooks)](#커스텀-훅customization-hooks)
      - [활성화](#활성화)
      - [체이닝](#체이닝)
      - [모듈 커스텀 훅과의 통신](#모듈-커스텀-훅과의-통신)
      - [Hooks](#hooks)
        - [`module.register()`에서 허용되는 비동기 훅](#moduleregister에서-허용되는-비동기-훅)
        - [`module.registerHooks()`가 허용하는 동기 훅](#moduleregisterhooks가-허용하는-동기-훅)
        - [훅의 규칙](#훅의-규칙)
        - [`initialize()`](#initialize)
        - [`resolve(specifier, context, nextResolve)`](#resolvespecifier-context-nextresolve)
        - [`load(url, context, nextLoad)`](#loadurl-context-nextload)
      - [예제](#예제)
        - [HTTPS에서 모듈 가져오기](#https에서-모듈-가져오기)
        - [트랜스파일링](#트랜스파일링)
        - [훅 실행하기](#훅-실행하기)
- [main.coffee](#maincoffee)
- [scream.coffee](#screamcoffee)
        - [Import Maps](#import-maps)
    - [소스 맵 v3 지원](#소스-맵-v3-지원)
      - [`module.findSourceMap(path)`](#modulefindsourcemappath)
      - [클래스: `module.SourceMap`](#클래스-modulesourcemap)
        - [`sourceMap.payload`](#sourcemappayload)
        - [`sourceMap.findEntry(lineOffset, columnOffset)`](#sourcemapfindentrylineoffset-columnoffset)
        - [`sourceMap.findOrigin(lineNumber, columnNumber)`](#sourcemapfindoriginlinenumber-columnnumber)

# 모듈: node:module API

추가된 버전: v0.3.7


### `Module` 객체[#](https://nodejs.org/docs/latest/api/module.html#the-module-object)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

`Module` 객체는 `Module` 인스턴스와 상호작용할 때 유용한 일반적인 유틸리티 메서드를 제공합니다. 이 객체는 [CommonJS](https://nodejs.org/docs/latest/api/modules.html) 모듈에서 자주 보이는 [`module`](https://nodejs.org/docs/latest/api/module.html#the-module-object) 변수와 관련이 있습니다. `Module` 객체는 `import 'node:module'` 또는 `require('node:module')`을 통해 접근할 수 있습니다.


#### `module.builtinModules`

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

Node.js에서 제공하는 모든 모듈의 이름 목록입니다. 이 목록을 사용하면 특정 모듈이 서드파티에서 관리되는지 확인할 수 있습니다.

여기서 `module`은 [모듈 래퍼](https://nodejs.org/docs/latest/api/modules.html#the-module-wrapper)에서 제공하는 객체와 동일하지 않습니다. 이 객체에 접근하려면 `Module` 모듈을 불러와야 합니다:

```js
// module.mjs // ECMAScript 모듈에서
import { builtinModules as builtin } from 'node:module';
```


#### `module.createRequire(filename)`[#](https://nodejs.org/docs/latest/api/module.html#modulecreaterequirefilename)

추가된 버전: v12.2.0

- `filename` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
  require 함수를 생성하는 데 사용할 파일명. 파일 URL 객체, 파일 URL 문자열, 또는 절대 경로 문자열이어야 합니다.
- 반환값: [`<require>`](https://nodejs.org/docs/latest/api/modules.html#requireid)  
  require 함수

```js
import { createRequire } from 'node:module';
const require = createRequire(import.meta.url);

// sibling-module.js는 CommonJS 모듈입니다.
const siblingModule = require('./sibling-module');
```


#### `module.findPackageJSON(specifier[, base])`[#](https://nodejs.org/docs/latest/api/module.html#modulefindpackagejsonspecifier-base)

추가된 버전: v23.2.0

-   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
    `package.json`을 찾을 모듈의 지정자. *bare specifier*를 전달하면 패키지 루트의 `package.json`이 반환됩니다. *relative specifier*나 *absolute specifier*를 전달하면 가장 가까운 상위 `package.json`이 반환됩니다.

-   `base` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
    포함된 모듈의 절대 위치(`file:` URL 문자열 또는 파일 시스템 경로). CJS에서는 `__filename`을 사용하고, ESM에서는 `import.meta.url`을 사용합니다. `specifier`가 `absolute specifier`인 경우 이 인자를 전달할 필요가 없습니다.

-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
    `package.json`이 발견되면 경로를 반환합니다. `startLocation`이 패키지인 경우 패키지 루트의 `package.json`을 반환하고, 상대적이거나 해결되지 않은 경우 `startLocation`과 가장 가까운 `package.json`을 반환합니다.

> **주의**: 이 함수를 사용해 모듈 포맷을 결정하려고 하지 마세요. 모듈 포맷을 결정하는 데는 여러 요소가 영향을 미칩니다. `package.json`의 `type` 필드는 가장 덜 결정적인 요소 중 하나입니다 (예: 파일 확장자가 이를 우선하며, 로더 훅이 그보다 우선합니다).

```text
/path/to/project
├ packages/
│   ├ bar/
│   │   ├ bar.js
│   │   └ package.json // name = '@foo/bar'
│   └ qux/
│       ├ node_modules/
│       │   └ some-package/
│       │       └ package.json // name = 'some-package'
│       ├ qux.js
│       └ package.json // name = '@foo/qux'
├ main.js
└ package.json // name = '@foo'
```

```js
// /path/to/project/packages/bar/bar.js
import { findPackageJSON } from 'node:module';

findPackageJSON('..', import.meta.url); // '/path/to/project/package.json'
// 절대 지정자를 전달해도 동일한 결과:
findPackageJSON(new URL('../', import.meta.url));
findPackageJSON(import.meta.resolve('../'));

findPackageJSON('some-package', import.meta.url); // '/path/to/project/packages/bar/node_modules/some-package/package.json'
// 절대 지정자를 전달하면, 해결된 모듈이 중첩된 `package.json`을 가진 하위 폴더에 있을 경우 다른 결과를 얻을 수 있습니다.
findPackageJSON(import.meta.resolve('some-package')); // '/path/to/project/packages/bar/node_modules/some-package/some-subfolder/package.json'

findPackageJSON('@foo/qux', import.meta.url); // '/path/to/project/packages/qux/package.json'
```


#### `module.isBuiltin(moduleName)`[#](https://nodejs.org/docs/latest/api/module.html#moduleisbuiltinmodulename)

추가된 버전: v18.6.0, v16.17.0

-   `moduleName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 모듈의 이름
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 모듈이 내장 모듈이면 `true`를 반환하고, 그렇지 않으면 `false`를 반환

```js
import { isBuiltin } from 'node:module';

isBuiltin('node:fs'); // true
isBuiltin('fs');      // true
isBuiltin('wss');     // false
```


#### `module.register(specifier[, parentURL][, options])`[#](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options)

-   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
    등록할 커스텀 훅을 지정합니다. 이 문자열은 `import()`에 전달할 때와 동일해야 합니다. 단, 상대 경로인 경우 `parentURL`을 기준으로 해석됩니다.

-   `parentURL` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
    `specifier`를 해석할 기준 URL을 지정합니다. 예를 들어 `import.meta.url`과 같은 값을 전달할 수 있습니다. **기본값:** `'data:'`

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `parentURL` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)  
        `specifier`를 해석할 기준 URL을 지정합니다. 두 번째 인수로 `parentURL`이 제공된 경우 이 속성은 무시됩니다. **기본값:** `'data:'`
    -   `data` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)  
        [`initialize`](https://nodejs.org/docs/latest/api/module.html#initialize) 훅에 전달할 임의의 복제 가능한 JavaScript 값입니다.
    -   `transferList` [`<Object\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)  
        `initialize` 훅에 전달할 [전송 가능 객체](https://nodejs.org/docs/latest/api/worker_threads.html#portpostmessagevalue-transferlist) 목록입니다.

이 메서드는 Node.js 모듈 해석 및 로딩 동작을 커스터마이징하는 훅을 내보내는 모듈을 등록합니다. 자세한 내용은 [커스텀 훅](https://nodejs.org/docs/latest/api/module.html#customization-hooks)을 참고하세요.


#### `module.registerHooks(options)`[#](https://nodejs.org/docs/latest/api/module.html#moduleregisterhooksoptions)

추가된 버전: v23.5.0

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `load` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) [load hook](https://nodejs.org/docs/latest/api/module.html#loadurl-context-nextload)을 참조하세요. **기본값:** `undefined`.
    -   `resolve` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) [resolve hook](https://nodejs.org/docs/latest/api/module.html#resolvespecifier-context-nextresolve)을 참조하세요. **기본값:** `undefined`.

Node.js 모듈의 해석 및 로딩 동작을 커스터마이징하는 [hooks](https://nodejs.org/docs/latest/api/module.html#customization-hooks)를 등록합니다. 자세한 내용은 [Customization hooks](https://nodejs.org/docs/latest/api/module.html#customization-hooks)를 참조하세요.


#### `module.stripTypeScriptTypes(code[, options])`[#](https://nodejs.org/docs/latest/api/module.html#modulestriptypescripttypescode-options)

추가된 버전: v23.2.0

-   `code` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 타입 주석을 제거할 코드
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `mode` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'strip'`. 가능한 값은 다음과 같음:
        -   `'strip'` 타입 주석만 제거하고 TypeScript 기능을 변환하지 않음
        -   `'transform'` 타입 주석을 제거하고 TypeScript 기능을 JavaScript로 변환
    -   `sourceMap` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`. `mode`가 `'transform'`일 때만, `true`로 설정하면 변환된 코드에 대한 소스 맵이 생성됨
    -   `sourceUrl` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 소스 맵에 사용될 소스 URL을 지정
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 타입 주석이 제거된 코드

`module.stripTypeScriptTypes()`는 TypeScript 코드에서 타입 주석을 제거한다. 이 함수는 `vm.runInContext()`나 `vm.compileFunction()`으로 실행하기 전에 TypeScript 코드에서 타입 주석을 제거하는 데 사용할 수 있다. 기본적으로, `Enums`와 같이 변환이 필요한 TypeScript 기능이 코드에 포함되어 있으면 오류를 발생시킨다. 자세한 내용은 [type-stripping](https://nodejs.org/docs/latest/api/typescript.html#type-stripping)을 참고하자. `mode`가 `'transform'`일 때는 TypeScript 기능을 JavaScript로 변환한다. 자세한 내용은 [transform TypeScript features](https://nodejs.org/docs/latest/api/typescript.html#typescript-features)를 확인하자. `mode`가 `'strip'`일 때는 위치가 보존되므로 소스 맵이 생성되지 않는다. `sourceMap`이 제공되고 `mode`가 `'strip'`일 때는 오류가 발생한다.

*경고*: 이 함수의 출력은 Node.js 버전에 따라 안정적이지 않을 수 있다. 이는 TypeScript 파서의 변경 사항 때문이다.

```js
import { stripTypeScriptTypes } from 'node:module';
const code = 'const a: number = 1;';
const strippedCode = stripTypeScriptTypes(code);
console.log(strippedCode); // 출력: const a = 1;
```

`sourceUrl`이 제공되면 출력의 끝에 주석으로 추가된다:

```js
import { stripTypeScriptTypes } from 'node:module';
const code = 'const a: number = 1;';
const strippedCode = stripTypeScriptTypes(code, { mode: 'strip', sourceUrl: 'source.ts' });
console.log(strippedCode); // 출력: const a = 1\n\n//# sourceURL=source.ts;
```

`mode`가 `'transform'`일 때는 코드가 JavaScript로 변환된다:

```js
import { stripTypeScriptTypes } from 'node:module';
const code = ` namespace MathUtil { export const add = (a: number, b: number) => a + b; }`;
const strippedCode = stripTypeScriptTypes(code, { mode: 'transform', sourceMap: true });
console.log(strippedCode); // 출력: // var MathUtil; // (function(MathUtil) { // MathUtil.add = (a, b)=>a + b; // })(MathUtil || (MathUtil = {})); // # sourceMappingURL=data:application/json;base64, ...
```


#### `module.syncBuiltinESMExports()`[#](https://nodejs.org/docs/latest/api/module.html#modulesyncbuiltinesmexports)

추가된 버전: v12.12.0

`module.syncBuiltinESMExports()` 메서드는 내장 [ES Modules](https://nodejs.org/docs/latest/api/esm.html)의 라이브 바인딩을 [CommonJS](https://nodejs.org/docs/latest/api/modules.html)의 exports 속성과 일치하도록 업데이트합니다. 이 메서드는 [ES Modules](https://nodejs.org/docs/latest/api/esm.html)에서 내보내는 이름을 추가하거나 제거하지 않습니다.

```js
const fs = require('node:fs');
const assert = require('node:assert');
const { syncBuiltinESMExports } = require('node:module');

fs.readFile = newAPI;
delete fs.readFileSync;

function newAPI() {
    // ...
}

fs.newAPI = newAPI;
syncBuiltinESMExports();

import('node:fs').then((esmFS) => {
    // 기존 readFile 속성을 새로운 값과 동기화
    assert.strictEqual(esmFS.readFile, newAPI);

    // readFileSync는 require된 fs에서 삭제됨
    assert.strictEqual('readFileSync' in fs, false);

    // syncBuiltinESMExports()는 esmFS에서 readFileSync를 제거하지 않음
    assert.strictEqual('readFileSync' in esmFS, true);

    // syncBuiltinESMExports()는 이름을 추가하지 않음
    assert.strictEqual(esmFS.newAPI, undefined);
});
```


### 모듈 컴파일 캐시

모듈 컴파일 캐시는 [`module.enableCompileCache()`](https://nodejs.org/docs/latest/api/module.html#moduleenablecompilecachecachedir) 메서드나 [`NODE_COMPILE_CACHE=dir`](https://nodejs.org/docs/latest/api/cli.html#node_compile_cachedir) 환경 변수를 사용해 활성화할 수 있습니다. 활성화되면, Node.js가 CommonJS나 ECMAScript 모듈을 컴파일할 때 지정된 디렉토리에 저장된 [V8 코드 캐시](https://v8.dev/blog/code-caching-for-devs)를 사용해 컴파일 속도를 높입니다. 이 기능은 모듈 그래프를 처음 로드할 때는 속도가 느려질 수 있지만, 모듈 내용이 변경되지 않았다면 동일한 모듈 그래프를 다시 로드할 때 상당한 속도 향상을 기대할 수 있습니다.

생성된 컴파일 캐시를 디스크에서 정리하려면 캐시 디렉토리를 삭제하면 됩니다. 캐시 디렉토리는 다음에 동일한 디렉토리가 컴파일 캐시 저장소로 사용될 때 다시 생성됩니다. 오래된 캐시로 인해 디스크가 가득 차는 것을 방지하려면 [`os.tmpdir()`](https://nodejs.org/docs/latest/api/os.html#ostmpdir) 아래의 디렉토리를 사용하는 것이 좋습니다. [`module.enableCompileCache()`](https://nodejs.org/docs/latest/api/module.html#moduleenablecompilecachecachedir)를 호출할 때 디렉토리를 지정하지 않으면, Node.js는 [`NODE_COMPILE_CACHE=dir`](https://nodejs.org/docs/latest/api/cli.html#node_compile_cachedir) 환경 변수가 설정되어 있다면 그 값을 사용하고, 그렇지 않으면 기본값으로 `path.join(os.tmpdir(), 'node-compile-cache')`를 사용합니다. 실행 중인 Node.js 인스턴스가 사용 중인 컴파일 캐시 디렉토리를 확인하려면 [`module.getCompileCacheDir()`](https://nodejs.org/docs/latest/api/module.html#modulegetcompilecachedir)를 사용하세요.

현재 [V8 JavaScript 코드 커버리지](https://v8project.blogspot.com/2017/12/javascript-code-coverage.html)와 함께 컴파일 캐시를 사용할 때, 코드 캐시에서 역직렬화된 함수의 커버리지가 덜 정확할 수 있습니다. 정확한 커버리지를 생성하기 위해 테스트를 실행할 때는 이 기능을 끄는 것이 좋습니다.

활성화된 모듈 컴파일 캐시는 [`NODE_DISABLE_COMPILE_CACHE=1`](https://nodejs.org/docs/latest/api/cli.html#node_disable_compile_cache1) 환경 변수를 사용해 비활성화할 수 있습니다. 이는 컴파일 캐시가 예상치 못한 동작이나 원하지 않는 결과(예: 덜 정확한 테스트 커버리지)를 초래할 때 유용합니다.

한 버전의 Node.js에서 생성된 컴파일 캐시는 다른 버전의 Node.js에서 재사용할 수 없습니다. 동일한 기본 디렉토리를 사용해 캐시를 저장하더라도, 다른 버전의 Node.js에서 생성된 캐시는 별도로 저장되므로 서로 공존할 수 있습니다.

현재 컴파일 캐시가 활성화된 상태에서 모듈이 새로 로드되면, 코드 캐시는 컴파일된 코드에서 즉시 생성되지만, Node.js 인스턴스가 종료되기 직전에야 디스크에 기록됩니다. 이 동작은 변경될 수 있습니다. 애플리케이션이 다른 Node.js 인스턴스를 생성하고 부모 프로세스가 종료되기 전에 캐시를 공유하도록 하려면 [`module.flushCompileCache()`](https://nodejs.org/docs/latest/api/module.html#moduleflushcompilecache) 메서드를 사용해 누적된 코드 캐시를 디스크에 강제로 기록할 수 있습니다.


#### `module.constants.compileCacheStatus`[#](https://nodejs.org/docs/latest/api/module.html#moduleconstantscompilecachestatus)

추가된 버전: v22.8.0

다음 상수들은 [`module.enableCompileCache()`](https://nodejs.org/docs/latest/api/module.html#moduleenablecompilecachecachedir)가 반환한 객체의 `status` 필드로 제공되며, [모듈 컴파일 캐시](https://nodejs.org/docs/latest/api/module.html#module-compile-cache)를 활성화하려는 시도의 결과를 나타냅니다.

| 상수 | 설명 |
| --- | --- |
| `ENABLED` | Node.js가 컴파일 캐시를 성공적으로 활성화했습니다. 컴파일 캐시를 저장하는 디렉토리는 반환된 객체의 `directory` 필드에 제공됩니다. |
| `ALREADY_ENABLED` | 컴파일 캐시가 이미 활성화된 상태입니다. 이전에 `module.enableCompileCache()`를 호출했거나 `NODE_COMPILE_CACHE=dir` 환경 변수를 통해 활성화된 경우입니다. 컴파일 캐시를 저장하는 디렉토리는 반환된 객체의 `directory` 필드에 제공됩니다. |
| `FAILED` | Node.js가 컴파일 캐시를 활성화하지 못했습니다. 지정된 디렉토리를 사용할 권한이 없거나 다양한 파일 시스템 오류로 인해 발생할 수 있습니다. 실패에 대한 상세 정보는 반환된 객체의 `message` 필드에 제공됩니다. |
| `DISABLED` | `NODE_DISABLE_COMPILE_CACHE=1` 환경 변수가 설정되어 있어 Node.js가 컴파일 캐시를 활성화할 수 없습니다. |


#### `module.enableCompileCache([cacheDir])`[#](https://nodejs.org/docs/latest/api/module.html#moduleenablecompilecachecachedir)

추가된 버전: v22.8.0

-   `cacheDir` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 컴파일 캐시를 저장하거나 불러올 디렉터리를 지정하는 선택적 경로입니다.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `status` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) [`module.constants.compileCacheStatus`](https://nodejs.org/docs/latest/api/module.html#moduleconstantscompilecachestatus) 중 하나입니다.
    -   `message` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) Node.js가 컴파일 캐시를 활성화할 수 없는 경우, 이 필드에 오류 메시지가 포함됩니다. `status`가 `module.constants.compileCacheStatus.FAILED`일 때만 설정됩니다.
    -   `directory` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 컴파일 캐시가 활성화된 경우, 이 필드에 컴파일 캐시가 저장된 디렉터리 경로가 포함됩니다. `status`가 `module.constants.compileCacheStatus.ENABLED` 또는 `module.constants.compileCacheStatus.ALREADY_ENABLED`일 때만 설정됩니다.

현재 Node.js 인스턴스에서 [모듈 컴파일 캐시](https://nodejs.org/docs/latest/api/module.html#module-compile-cache)를 활성화합니다.

`cacheDir`을 지정하지 않으면, Node.js는 [`NODE_COMPILE_CACHE=dir`](https://nodejs.org/docs/latest/api/cli.html#node_compile_cachedir) 환경 변수가 설정된 경우 해당 디렉터리를 사용하고, 그렇지 않으면 `path.join(os.tmpdir(), 'node-compile-cache')`를 사용합니다. 일반적인 사용 사례에서는 `cacheDir`을 지정하지 않고 `module.enableCompileCache()`를 호출하는 것이 좋습니다. 이렇게 하면 필요할 때 `NODE_COMPILE_CACHE` 환경 변수를 통해 디렉터리를 재정의할 수 있습니다.

컴파일 캐시는 애플리케이션이 동작하는 데 필수적이지 않은 조용한 최적화를 목적으로 하기 때문에, 이 메서드는 컴파일 캐시를 활성화할 수 없는 경우에도 예외를 던지지 않도록 설계되었습니다. 대신, 디버깅을 돕기 위해 `message` 필드에 오류 메시지를 포함한 객체를 반환합니다. 컴파일 캐시가 성공적으로 활성화되면, 반환된 객체의 `directory` 필드에 컴파일 캐시가 저장된 디렉터리 경로가 포함됩니다. 반환된 객체의 `status` 필드는 [모듈 컴파일 캐시](https://nodejs.org/docs/latest/api/module.html#module-compile-cache)를 활성화하려는 시도의 결과를 나타내는 `module.constants.compileCacheStatus` 값 중 하나입니다.

이 메서드는 현재 Node.js 인스턴스에만 영향을 미칩니다. 자식 워커 스레드에서도 활성화하려면, 자식 워커 스레드에서 이 메서드를 호출하거나 `process.env.NODE_COMPILE_CACHE` 값을 컴파일 캐시 디렉터리로 설정하여 자식 워커에게 동작을 상속시킬 수 있습니다. 디렉터리는 이 메서드가 반환한 `directory` 필드에서 얻거나 [`module.getCompileCacheDir()`](https://nodejs.org/docs/latest/api/module.html#modulegetcompilecachedir)을 통해 얻을 수 있습니다.


#### `module.flushCompileCache()`[#](https://nodejs.org/docs/latest/api/module.html#moduleflushcompilecache)

추가된 버전: v23.0.0

현재 Node.js 인스턴스에서 이미 로드된 모듈들의 [모듈 컴파일 캐시](https://nodejs.org/docs/latest/api/module.html#module-compile-cache)를 디스크로 비웁니다. 이 메서드는 모든 파일 시스템 작업이 완료된 후에 반환되며, 작업의 성공 여부와 상관없이 동작합니다. 오류가 발생하더라도 조용히 실패합니다. 컴파일 캐시 누락은 애플리케이션의 실제 동작에 영향을 미치지 않아야 하기 때문입니다.


#### `module.getCompileCacheDir()`[#](https://nodejs.org/docs/latest/api/module.html#modulegetcompilecachedir)

추가된 버전: v22.8.0

-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  모듈 컴파일 캐시가 활성화된 경우 해당 디렉토리의 경로를 반환합니다. 비활성화된 경우 `undefined`를 반환합니다.


### 커스텀 훅(Customization Hooks)

[안정성: 1](https://nodejs.org/docs/latest/api/documentation.html#stability-index).2 - 릴리스 후보 (비동기 버전)  
안정성: 1.1 - 활성 개발 중 (동기 버전)

현재 지원되는 모듈 커스텀 훅은 두 가지 타입이 있습니다:

1. **`module.register(specifier[, parentURL][, options])`**  
   이 함수는 비동기 훅 함수를 내보내는 모듈을 받습니다. 이 훅 함수들은 별도의 로더 스레드에서 실행됩니다.

2. **`module.registerHooks(options)`**  
   이 함수는 동기 훅 함수를 받으며, 이 함수들은 모듈이 로드된 스레드에서 직접 실행됩니다.


#### 활성화[#](https://nodejs.org/docs/latest/api/module.html#enabling)

모듈 해석과 로딩은 다음과 같은 방법으로 커스터마이즈할 수 있습니다:

1. `node:module`의 [`register`](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options) 메서드를 사용하여 비동기 훅 함수를 내보내는 파일을 등록합니다.
2. `node:module`의 [`registerHooks`](https://nodejs.org/docs/latest/api/module.html#moduleregisterhooksoptions) 메서드를 사용하여 동기 훅 함수를 등록합니다.

이 훅들은 애플리케이션 코드가 실행되기 전에 [`--import`](https://nodejs.org/docs/latest/api/cli.html#--importmodule) 또는 [`--require`](https://nodejs.org/docs/latest/api/cli.html#-r---require-module) 플래그를 사용하여 등록할 수 있습니다:

```bash
node --import ./register-hooks.js ./my-app.js
node --require ./register-hooks.js ./my-app.js
```

```js
// register-hooks.js
// 이 파일은 최상위 await를 포함하지 않을 경우에만 require()로 불러올 수 있습니다.
// module.register()를 사용하여 비동기 훅을 전용 스레드에 등록합니다.
import { register } from 'node:module';
register('./hooks.mjs', import.meta.url);
```

```js
// module.registerHooks()를 사용하여 동기 훅을 메인 스레드에 등록합니다.
import { registerHooks } from 'node:module';
registerHooks({
  resolve(specifier, context, nextResolve) {
    /* 구현 */
  },
  load(url, context, nextLoad) {
    /* 구현 */
  },
});
```

`--import` 또는 `--require`에 전달된 파일은 의존성에서 내보낸 것일 수도 있습니다:

```bash
node --import some-package/register ./my-app.js
node --require some-package/register ./my-app.js
```

여기서 `some-package`는 `/register` 내보내기를 `register()`를 호출하는 파일로 매핑하는 [`"exports"`](https://nodejs.org/docs/latest/api/packages.html#exports) 필드를 가지고 있습니다. 이는 앞서 보여준 `register-hooks.js` 예제와 유사합니다.

`--import` 또는 `--require`를 사용하면 애플리케이션 파일이 임포트되기 전에 훅이 등록됩니다. 이는 애플리케이션의 진입점과 기본적으로 모든 워커 스레드에도 적용됩니다.

또는, `register()`와 `registerHooks()`를 진입점에서 호출할 수도 있습니다. 단, 훅이 등록된 후에 실행되어야 하는 ESM 코드는 동적 `import()`를 사용해야 합니다.

```js
import { register } from 'node:module';
register('http-to-https', import.meta.url);

// 이 코드는 동적 `import()`이므로, `http-to-https` 훅이 실행되어
// `./my-app.js`와 그 파일이 임포트하거나 require()하는 다른 파일들을 처리합니다.
await import('./my-app.js');
```

커스터마이즈 훅은 등록 이후에 로드되는 모든 모듈과 그 모듈이 `import` 및 내장 `require`를 통해 참조하는 모듈에 대해 실행됩니다. 사용자가 `module.createRequire()`를 사용하여 생성한 `require` 함수는 동기 훅에 의해서만 커스터마이즈될 수 있습니다.

이 예제에서는 `http-to-https` 훅을 등록하지만, 이 훅은 이후에 임포트되는 모듈에 대해서만 사용 가능합니다. 이 경우, `my-app.js`와 그 파일이 `import` 또는 CommonJS 의존성에서 내장 `require`를 통해 참조하는 모든 파일이 해당됩니다.

만약 `import('./my-app.js')`가 정적 `import './my-app.js'`였다면, 앱은 `http-to-https` 훅이 등록되기 **전에** 이미 로드되었을 것입니다. 이는 ES 모듈 사양 때문인데, 정적 임포트는 트리의 리프부터 먼저 평가된 후 트렁크로 돌아오기 때문입니다. `my-app.js` 내부에 정적 임포트가 있을 수 있으며, 이는 `my-app.js`가 동적으로 임포트될 때까지 평가되지 않습니다.

동기 훅을 사용하는 경우, `import`, `require`, 그리고 `createRequire()`를 사용하여 생성된 사용자 `require` 모두 지원됩니다.

```js
import { registerHooks, createRequire } from 'node:module';
registerHooks({
  /* 동기 훅 구현 */
});
const require = createRequire(import.meta.url);

// 동기 훅은 import, require(), 그리고 createRequire()를 통해 생성된 사용자 require() 함수에 영향을 미칩니다.
await import('./my-app.js');
require('./my-app-2.js');
```

마지막으로, 앱이 실행되기 전에 훅을 등록하고 싶지만 이를 위해 별도의 파일을 만들고 싶지 않다면, `--import`에 `data:` URL을 전달할 수 있습니다:

```bash
node --import 'data:text/javascript,import { register } from "node:module"; import { pathToFileURL } from "node:url"; register("http-to-https", pathToFileURL("./"));' ./my-app.js
```


#### 체이닝[#](https://nodejs.org/docs/latest/api/module.html#chaining)

`register`를 여러 번 호출할 수 있습니다:

```js
// entrypoint.mjs
import { register } from 'node:module';
register('./foo.mjs', import.meta.url);
register('./bar.mjs', import.meta.url);
await import('./my-app.mjs');
```

이 예제에서 등록된 훅들은 체인을 형성합니다. 이 체인은 **LIFO(Last In, First Out)** 방식으로 실행됩니다. 만약 `foo.mjs`와 `bar.mjs` 모두 `resolve` 훅을 정의했다면, 이들은 다음과 같이 호출됩니다 (오른쪽에서 왼쪽 순서를 주목하세요): Node.js 기본 ← `./foo.mjs` ← `./bar.mjs` (`./bar.mjs`부터 시작하여 `./foo.mjs`, 그리고 Node.js 기본 순서로 실행). 이 원칙은 다른 모든 훅에도 동일하게 적용됩니다.

등록된 훅들은 `register` 자체에도 영향을 미칩니다. 이 예제에서 `bar.mjs`는 `foo.mjs`에 의해 등록된 훅을 통해 해석되고 로드됩니다 (`foo`의 훅이 이미 체인에 추가되었기 때문). 이는 JavaScript가 아닌 언어로 훅을 작성할 수 있게 해줍니다. 단, 이전에 등록된 훅이 JavaScript로 트랜스파일되기만 하면 됩니다.

`register` 메서드는 훅을 정의하는 모듈 내부에서 호출할 수 없습니다.

`registerHooks`의 체이닝도 비슷하게 동작합니다. 동기와 비동기 훅이 혼합된 경우, 동기 훅은 항상 비동기 훅이 실행되기 전에 먼저 실행됩니다. 즉, 마지막 동기 훅이 실행될 때, 그 다음 훅은 비동기 훅의 호출을 포함합니다.

```js
// entrypoint.mjs
import { registerHooks } from 'node:module';
const hook1 = { /* 훅 구현 */ };
const hook2 = { /* 훅 구현 */ };
// hook2가 hook1보다 먼저 실행됩니다.
registerHooks(hook1);
registerHooks(hook2);
```


#### 모듈 커스텀 훅과의 통신

비동기 훅은 애플리케이션 코드를 실행하는 메인 스레드와 별도의 전용 스레드에서 실행됩니다. 이는 전역 변수를 변경해도 다른 스레드에 영향을 미치지 않음을 의미하며, 스레드 간 통신을 위해 메시지 채널을 사용해야 합니다.

`register` 메서드를 사용하면 [`initialize`](https://nodejs.org/docs/latest/api/module.html#initialize) 훅에 데이터를 전달할 수 있습니다. 훅에 전달되는 데이터에는 포트와 같은 전송 가능한 객체가 포함될 수 있습니다.

```js
import { register } from 'node:module';
import { MessageChannel } from 'node:worker_threads';

// 이 예제는 메시지 채널을 사용하여 훅과 통신하는 방법을 보여줍니다.
// `port2`를 훅에 전송하여 통신합니다.
const { port1, port2 } = new MessageChannel();

port1.on('message', (msg) => {
    console.log(msg);
});

port1.unref();

register('./my-hooks.mjs', {
    parentURL: import.meta.url,
    data: {
        number: 1,
        port: port2
    },
    transferList: [port2],
});
```

동기 모듈 훅은 애플리케이션 코드가 실행되는 동일한 스레드에서 실행됩니다. 이들은 메인 스레드가 접근하는 컨텍스트의 전역 변수를 직접 변경할 수 있습니다.


#### Hooks[#](https://nodejs.org/docs/latest/api/module.html#hooks)





##### `module.register()`에서 허용되는 비동기 훅

[`register`](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options) 메서드는 훅(hook) 집합을 내보내는 모듈을 등록하는 데 사용할 수 있습니다. 훅은 Node.js가 모듈 해석 및 로딩 프로세스를 커스터마이징하기 위해 호출하는 함수입니다. 내보낸 함수는 특정 이름과 시그니처를 가져야 하며, 명명된 내보내기(named export)로 제공되어야 합니다.

```js
export async function initialize({ number, port }) { 
    // `register`에서 데이터를 받습니다. 
} 

export async function resolve(specifier, context, nextResolve) { 
    // `import` 또는 `require` 스펙ifier를 받아 URL로 해석합니다. 
} 

export async function load(url, context, nextLoad) { 
    // 해석된 URL을 받아 평가될 소스 코드를 반환합니다. 
}
```

비동기 훅은 애플리케이션 코드가 실행되는 메인 스레드와 분리된 별도의 스레드에서 실행됩니다. 이는 서로 다른 [realm](https://tc39.es/ecma262/#realm)임을 의미합니다. 훅 스레드는 메인 스레드에 의해 언제든지 종료될 수 있으므로, `console.log`와 같은 비동기 작업이 완료될 것이라고 의존하지 마세요. 기본적으로 이 훅은 자식 워커에게 상속됩니다.


##### `module.registerHooks()`가 허용하는 동기 훅[#](https://nodejs.org/docs/latest/api/module.html#synchronous-hooks-accepted-by-moduleregisterhooks)

추가된 버전: v23.5.0

`module.registerHooks()` 메서드는 동기 훅 함수를 허용합니다. `initialize()`는 지원되지 않으며 필요하지도 않습니다. 훅 구현자는 `module.registerHooks()`를 호출하기 전에 직접 초기화 코드를 실행할 수 있습니다.

```js
function resolve(specifier, context, nextResolve) { 
    // `import` 또는 `require` 스펙시파이어를 받아 URL로 해석합니다. 
} 

function load(url, context, nextLoad) { 
    // 해석된 URL을 받아 평가할 소스 코드를 반환합니다. 
}
```

동기 훅은 모듈이 로드된 동일한 스레드와 동일한 [realm](https://tc39.es/ecma262/#realm)에서 실행됩니다. 비동기 훅과 달리, 기본적으로 자식 워커 스레드로 상속되지 않습니다. 하지만 [`--import`](https://nodejs.org/docs/latest/api/cli.html#--importmodule) 또는 [`--require`](https://nodejs.org/docs/latest/api/cli.html#-r---require-module)로 미리 로드된 파일을 사용해 훅을 등록하면, 자식 워커 스레드가 `process.execArgv` 상속을 통해 미리 로드된 스크립트를 상속받을 수 있습니다. 자세한 내용은 [`Worker` 문서](https://nodejs.org/docs/latest/api/worker_threads.html#new-workerfilename-options)를 참고하세요.

동기 훅에서는 `console.log()`가 모듈 코드에서와 동일한 방식으로 완료될 것으로 예상할 수 있습니다.


##### 훅의 규칙

훅은 [체인](https://nodejs.org/docs/latest/api/module.html#chaining)의 일부입니다. 이 체인은 단 하나의 커스텀 훅(사용자가 제공한 훅)과 항상 존재하는 기본 훅으로만 구성될 수도 있습니다. 훅 함수는 중첩됩니다. 각 훅은 항상 일반 객체를 반환해야 하며, 체이닝은 각 함수가 `next<hookName>()`을 호출함으로써 발생합니다. 이는 후속 로더의 훅을 참조합니다(LIFO 순서).

필수 속성이 없는 값을 반환하는 훅은 예외를 발생시킵니다. `next<hookName>()`을 호출하지 않고 `shortCircuit: true`도 반환하지 않는 훅 역시 예외를 발생시킵니다. 이러한 오류는 체인이 의도치 않게 끊어지는 것을 방지하기 위한 것입니다. 체인이 의도적으로 해당 훅에서 끝나야 한다면 `shortCircuit: true`를 반환하세요.


##### `initialize()`[#](https://nodejs.org/docs/latest/api/module.html#initialize)

추가된 버전: v20.6.0, v18.19.0

-   `data` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) `register(loader, import.meta.url, { data })`에서 전달된 데이터.

`initialize` 훅은 [`register`](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options)에서만 사용할 수 있습니다. `registerHooks()`는 동기식 훅의 초기화가 `registerHooks()` 호출 전에 직접 실행될 수 있기 때문에 이 훅을 지원하거나 필요로 하지 않습니다.

`initialize` 훅은 훅 모듈이 초기화될 때 훅 스레드에서 실행되는 커스텀 함수를 정의할 수 있는 방법을 제공합니다. 초기화는 [`register`](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options)를 통해 훅 모듈이 등록될 때 발생합니다.

이 훅은 [`register`](https://nodejs.org/docs/latest/api/module.html#moduleregisterspecifier-parenturl-options) 호출에서 포트 및 전송 가능한 객체를 포함한 데이터를 받을 수 있습니다. `initialize`의 반환 값은 [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)가 될 수 있으며, 이 경우 메인 애플리케이션 스레드의 실행이 재개되기 전에 대기됩니다.

모듈 커스터마이징 코드:

```js
// path-to-my-hooks.js
export async function initialize({ number, port }) {
    port.postMessage(`increment: ${number + 1}`);
}
```

호출자 코드:

```js
import assert from 'node:assert';
import { register } from 'node:module';
import { MessageChannel } from 'node:worker_threads';

// 이 예제는 메인(애플리케이션) 스레드와 훅 스레드에서 실행되는 훅 간에
// `port2`를 `initialize` 훅으로 전송하여 통신할 수 있는 방법을 보여줍니다.
const { port1, port2 } = new MessageChannel();

port1.on('message', (msg) => {
    assert.strictEqual(msg, 'increment: 2');
});

port1.unref();

register('./path-to-my-hooks.js', {
    parentURL: import.meta.url,
    data: { number: 1, port: port2 },
    transferList: [port2],
});
```


##### `resolve(specifier, context, nextResolve)`[#](https://nodejs.org/docs/latest/api/module.html#resolvespecifier-context-nextresolve)

[안정성: 1](https://nodejs.org/docs/latest/api/documentation.html#stability-index).2 - 릴리스 후보 (비동기 버전)  
안정성: 1.1 - 활성 개발 중 (동기 버전)

-   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `conditions` [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 관련 `package.json`의 내보내기 조건
    -   `importAttributes` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 모듈을 가져올 때 사용할 속성을 나타내는 키-값 쌍 객체
    -   `parentURL` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 이 모듈을 가져오는 모듈의 URL. Node.js 진입점인 경우 `undefined`
-   `nextResolve` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 체인에서 다음 `resolve` 훅 또는 마지막 사용자 제공 `resolve` 훅 이후의 Node.js 기본 `resolve` 훅
    -   `specifier` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 비동기 버전은 다음 속성을 포함하는 객체 또는 해당 객체로 resolve되는 `Promise`를 반환. 동기 버전은 동기적으로 반환된 객체만 허용.
    -   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) `load` 훅에 대한 힌트 (무시될 수 있음) `'builtin' | 'commonjs' | 'json' | 'module' | 'wasm'`
    -   `importAttributes` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 모듈 캐싱 시 사용할 가져오기 속성 (선택 사항; 생략 시 입력값 사용)
    -   `shortCircuit` [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) | [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 이 훅이 `resolve` 훅 체인을 종료하려는 신호. **기본값:** `false`
    -   `url` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 입력값이 resolve되는 절대 URL

> **경고** 비동기 버전의 경우, Promise와 비동기 함수 반환을 지원하더라도 `resolve` 호출이 메인 스레드를 차단할 수 있어 성능에 영향을 미칠 수 있음.

`resolve` 훅 체인은 Node.js가 `import` 문 또는 표현식, `require` 호출을 어디에서 찾고 어떻게 캐시할지 결정하는 역할을 한다. `load` 훅에 힌트로 사용할 형식(예: `'module'`)을 선택적으로 반환할 수 있다. 형식이 지정된 경우, `load` 훅이 최종 `format` 값을 제공하는 책임을 지며, `resolve`가 제공한 힌트를 무시할 수 있다. `resolve`가 `format`을 제공하는 경우, Node.js 기본 `load` 훅에 값을 전달하기 위해서라도 커스텀 `load` 훅이 필요하다.

가져오기 타입 속성은 내부 모듈 캐시에 로드된 모듈을 저장할 때 캐시 키의 일부이다. `resolve` 훅은 소스 코드에 있는 속성과 다른 속성으로 모듈을 캐시해야 하는 경우 `importAttributes` 객체를 반환해야 한다.

`context`의 `conditions` 속성은 이 해결 요청에 대해 [패키지 내보내기 조건](https://nodejs.org/docs/latest/api/packages.html#conditional-exports)을 매칭하는 데 사용될 조건 배열이다. 이 조건은 다른 곳에서 조건부 매핑을 조회하거나 기본 해결 로직을 호출할 때 목록을 수정하는 데 사용할 수 있다.

현재 [패키지 내보내기 조건](https://nodejs.org/docs/latest/api/packages.html#conditional-exports)은 항상 훅에 전달된 `context.conditions` 배열에 포함된다. `defaultResolve`를 호출할 때 *기본 Node.js 모듈 지정자 해결 동작*을 보장하려면, 전달된 `context.conditions` 배열이 원래 `resolve` 훅에 전달된 `context.conditions` 배열의 *모든* 요소를 포함해야 한다.

```javascript
// module.register()에서 허용하는 비동기 버전
export async function resolve(specifier, context, nextResolve) {
    const { parentURL = null } = context;
    if (Math.random() > 0.5) {
        // 특정 조건
        // 일부 또는 모든 지정자에 대해 커스텀 해결 로직 수행
        // 항상 {url: } 형태의 객체 반환
        return {
            shortCircuit: true,
            url: parentURL ? new URL(specifier, parentURL).href : new URL(specifier).href,
        };
    }
    if (Math.random() < 0.5) {
        // 다른 조건
        // `defaultResolve` 호출 시 인자를 수정할 수 있음. 이 경우 조건부 내보내기를 위한 추가 값 추가
        return nextResolve(specifier, {
            ...context,
            conditions: [...context.conditions, 'another-condition'],
        });
    }
    // 체인에서 다음 훅으로 넘김. 이 훅이 마지막 사용자 지정 로더라면 Node.js 기본 resolve가 됨
    return nextResolve(specifier);
}
```

```javascript
// module.registerHooks()에서 허용하는 동기 버전
function resolve(specifier, context, nextResolve) {
    // 비동기 resolve()와 유사. 비동기 로직이 없으므로 동일하게 작성
}
```


##### `load(url, context, nextLoad)`[#](https://nodejs.org/docs/latest/api/module.html#loadurl-context-nextload)

[안정성: 1](https://nodejs.org/docs/latest/api/documentation.html#stability-index).2 - 릴리스 후보 (비동기 버전) 안정성: 1.1 - 활성 개발 중 (동기 버전)

-   `url` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `resolve` 체인에서 반환된 URL
-   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `conditions` [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 관련 `package.json`의 내보내기 조건
    -   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) `resolve` 훅 체인에서 선택적으로 제공된 형식
    -   `importAttributes` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   `nextLoad` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 체인의 다음 `load` 훅 또는 마지막 사용자 제공 `load` 훅 이후의 Node.js 기본 `load` 훅
    -   `url` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<Promise>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) 비동기 버전은 다음 속성을 포함하는 객체 또는 해당 객체로 해결되는 `Promise`를 반환한다. 동기 버전은 동기적으로 반환된 객체만 허용한다.
    -   `format` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `shortCircuit` [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) | [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 이 훅이 `load` 훅 체인을 종료하려는 신호. **기본값:** `false`
    -   `source` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<ArrayBuffer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) Node.js가 평가할 소스

`load` 훅은 URL을 해석, 검색, 파싱하는 방법을 정의하는 커스텀 메서드를 제공한다. 또한 가져오기 속성을 검증하는 역할도 한다.

`format`의 최종 값은 다음 중 하나여야 한다:

| `format` | 설명 | `load`에서 반환된 `source`의 허용 가능한 타입 |
| --- | --- | --- |
| `'builtin'` | Node.js 내장 모듈 로드 | 적용 불가 |
| `'commonjs'` | Node.js CommonJS 모듈 로드 | { [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String), [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray), `null`, `undefined` } |
| `'json'` | JSON 파일 로드 | { [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String), [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) } |
| `'module'` | ES 모듈 로드 | { [`string`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String), [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) } |
| `'wasm'` | WebAssembly 모듈 로드 | { [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) } |

`'builtin'` 타입의 경우 `source` 값은 무시된다. 현재 Node.js 내장(코어) 모듈의 값을 대체할 수 없기 때문이다.

###### 비동기 `load` 훅의 주의사항[#](https://nodejs.org/docs/latest/api/module.html#caveat-in-the-asynchronous-load-hook)

비동기 `load` 훅을 사용할 때, `'commonjs'`에 대해 `source`를 생략하거나 제공하는 것은 매우 다른 효과를 가진다:

-   `source`를 제공하면, 이 모듈의 모든 `require` 호출은 등록된 `resolve` 및 `load` 훅을 통해 ESM 로더에 의해 처리된다. 이 모듈의 모든 `require.resolve` 호출은 등록된 `resolve` 훅을 통해 ESM 로더에 의해 처리된다. CommonJS API의 일부만 사용 가능하며(예: `require.extensions`, `require.cache`, `require.resolve.paths` 없음), CommonJS 모듈 로더에 대한 몽키 패칭은 적용되지 않는다.
-   `source`가 `undefined` 또는 `null`이면, CommonJS 모듈 로더에 의해 처리되며 `require`/`require.resolve` 호출은 등록된 훅을 통과하지 않는다. 이 동작은 임시적이며, 향후 `null` 또는 `undefined`인 `source`는 지원되지 않을 예정이다.

이 주의사항은 동기 `load` 훅에는 적용되지 않는다. 동기 버전에서는 커스텀 CommonJS 모듈에 사용 가능한 전체 CommonJS API가 제공되며, `require`/`require.resolve`는 항상 등록된 훅을 통과한다.

Node.js 내부 비동기 `load` 구현은 `load` 체인의 마지막 훅에 대한 `next` 값으로, `format`이 `'commonjs'`일 때 `source`에 `null`을 반환한다. 이는 하위 호환성을 위한 것이다. 다음은 기본 동작을 사용하지 않는 훅 예제이다:

```js
import { readFile } from 'node:fs/promises'; // module.register()에서 허용되는 비동기 버전. 이 수정은 // module.registerSync()에서 허용되는 동기 버전에는 필요하지 않다. export async function load(url, context, nextLoad) { const result = await nextLoad(url, context); if (result.format === 'commonjs') { result.source ??= await readFile(new URL(result.responseURL ?? url)); } return result; }
```

이것은 동기 `load` 훅에도 적용되지 않는다. 동기 버전에서는 `source`가 모듈 형식에 관계없이 다음 훅에 의해 로드된 소스 코드를 포함한다.

> **경고**: 비동기 `load` 훅과 CommonJS 모듈의 네임스페이스 내보내기는 호환되지 않는다. 둘을 함께 사용하면 가져오기 시 빈 객체가 반환된다. 이 문제는 향후 해결될 수 있다. 이는 동기 `load` 훅에는 적용되지 않으며, 동기 버전에서는 내보내기를 평소처럼 사용할 수 있다.

> 이 타입들은 모두 ECMAScript에 정의된 클래스에 해당한다.

-   특정 [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer) 객체는 [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer)이다.
-   특정 [`TypedArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) 객체는 [`Uint8Array`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)이다.

텍스트 기반 형식(예: `'json'`, `'module'`)의 소스 값이 문자열이 아닌 경우, [`util.TextDecoder`](https://nodejs.org/docs/latest/api/util.html#class-utiltextdecoder)를 사용하여 문자열로 변환된다.

`load` 훅은 해결된 URL의 소스 코드를 검색하는 커스텀 메서드를 정의하는 방법을 제공한다. 이를 통해 로더가 디스크에서 파일을 읽지 않도록 할 수 있다. 또한 인식되지 않는 형식을 지원되는 형식으로 매핑하는 데 사용할 수 있다. 예를 들어 `yaml`을 `module`로 매핑할 수 있다.

```js
// module.register()에서 허용되는 비동기 버전. export async function load(url, context, nextLoad) { const { format } = context; if (Math.random() > 0.5) { // 어떤 조건 /* 일부 또는 모든 URL에 대해 소스를 검색하는 커스텀 로직을 수행. 항상 { format: , source: , } 형태의 객체를 반환. */ return { format, shortCircuit: true, source: '...', }; } // 체인의 다음 훅으로 넘김. return nextLoad(url); }
```

```js
// module.registerHooks()에서 허용되는 동기 버전. function load(url, context, nextLoad) { // 위의 비동기 load()와 유사하며, 비동기 로직이 없다. }
```

더 고급 시나리오에서는 지원되지 않는 소스를 지원되는 소스로 변환하는 데에도 사용할 수 있다(아래 [예제](https://nodejs.org/docs/latest/api/module.html#examples) 참조).


#### 예제[#](https://nodejs.org/docs/latest/api/module.html#examples)

다양한 모듈 커스터마이징 훅을 함께 사용하면 Node.js의 코드 로딩 및 평가 동작을 광범위하게 커스터마이징할 수 있습니다.


##### HTTPS에서 모듈 가져오기

아래 훅은 HTTPS 스펙을 지원하기 위한 기본적인 훅을 등록합니다. 이 기능이 Node.js 코어 기능의 큰 개선처럼 보일 수 있지만, 실제로 사용할 때는 몇 가지 중요한 단점이 있습니다: 디스크에서 파일을 로드하는 것보다 성능이 훨씬 느리고, 캐싱이 없으며, 보안도 제공되지 않습니다.

```js
// https-hooks.mjs
import { get } from 'node:https';

export function load(url, context, nextLoad) {
    // 네트워크를 통해 JavaScript를 로드하려면 데이터를 가져와 반환해야 합니다.
    if (url.startsWith('https://')) {
        return new Promise((resolve, reject) => {
            get(url, (res) => {
                let data = '';
                res.setEncoding('utf8');
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => resolve({
                    // 이 예제는 네트워크로 제공되는 모든 JavaScript가 ES 모듈 코드라고 가정합니다.
                    format: 'module',
                    shortCircuit: true,
                    source: data,
                }));
            }).on('error', (err) => reject(err));
        });
    }
    // 다른 URL은 Node.js가 처리하도록 합니다.
    return nextLoad(url);
}
```

```js
// main.mjs
import { VERSION } from 'https://coffeescript.org/browser-compiler-modern/coffeescript.js';
console.log(VERSION);
```

위의 훅 모듈을 사용하여 `node --import 'data:text/javascript,import { register } from "node:module"; import { pathToFileURL } from "node:url"; register(pathToFileURL("./https-hooks.mjs"));' ./main.mjs`를 실행하면, `main.mjs`에 있는 URL의 모듈을 통해 현재 CoffeeScript 버전이 출력됩니다.


##### 트랜스파일링[#](https://nodejs.org/docs/latest/api/module.html#transpilation)

Node.js가 이해하지 못하는 형식의 소스는 [`load` 훅](https://nodejs.org/docs/latest/api/module.html#loadurl-context-nextload)을 사용해 자바스크립트로 변환할 수 있습니다.

이 방법은 Node.js를 실행하기 전에 소스 파일을 트랜스파일링하는 것보다 성능이 떨어집니다. 따라서 트랜스파일러 훅은 개발 및 테스트 목적으로만 사용해야 합니다.

###### 비동기 버전[#](https://nodejs.org/docs/latest/api/module.html#asynchronous-version)

```javascript
// coffeescript-hooks.mjs
import { readFile } from 'node:fs/promises';
import { dirname, extname, resolve as resolvePath } from 'node:path';
import { cwd } from 'node:process';
import { fileURLToPath, pathToFileURL } from 'node:url';
import coffeescript from 'coffeescript';

const extensionsRegex = /\.(coffee|litcoffee|coffee\.md)$/;

export async function load(url, context, nextLoad) {
    if (extensionsRegex.test(url)) {
        // CoffeeScript 파일은 CommonJS 또는 ES 모듈일 수 있으므로,
        // CoffeeScript 파일을 같은 위치의 .js 파일과 동일하게 처리합니다.
        // 임의의 .js 파일을 Node.js가 어떻게 해석할지 결정하기 위해,
        // 파일 시스템에서 가장 가까운 상위 package.json 파일을 찾아 "type" 필드를 읽습니다.
        const format = await getPackageType(url);
        const { source: rawSource } = await nextLoad(url, { ...context, format });

        // 이 훅은 모든 CoffeeScript 파일을 자바스크립트 소스 코드로 변환합니다.
        const transformedSource = coffeescript.compile(rawSource.toString(), url);

        return {
            format,
            shortCircuit: true,
            source: transformedSource,
        };
    }

    // 다른 URL은 Node.js가 처리하도록 합니다.
    return nextLoad(url);
}

async function getPackageType(url) {
    // `url`은 load() 훅에서 전달된 해결된 URL일 때만 파일 경로입니다.
    // load()에서 전달된 실제 파일 경로는 파일 확장자를 포함합니다.
    // 이 간단한 파일 확장자 존재 여부 검사는 대부분의 프로젝트에서 작동하지만,
    // 확장자가 없는 파일이나 끝에 공백이 있는 URL과 같은 특수한 경우는 처리하지 못합니다.
    const isFilePath = !!extname(url);

    // 파일 경로라면 해당 디렉토리를 가져옵니다.
    const dir = isFilePath ? dirname(fileURLToPath(url)) : url;

    // 같은 디렉토리에 있는 package.json 파일 경로를 구성합니다.
    // 이 파일은 존재할 수도 있고, 존재하지 않을 수도 있습니다.
    const packagePath = resolvePath(dir, 'package.json');

    // 존재하지 않을 수도 있는 package.json 파일을 읽어봅니다.
    const type = await readFile(packagePath, { encoding: 'utf8' })
        .then((filestring) => JSON.parse(filestring).type)
        .catch((err) => {
            if (err?.code !== 'ENOENT') console.error(err);
        });

    // package.json이 존재하고 `type` 필드가 있다면, 그 값을 반환합니다.
    if (type) return type;

    // 그렇지 않고 루트 디렉토리가 아니라면, 상위 디렉토리를 계속 확인합니다.
    // 루트 디렉토리라면, 검사를 중단하고 false를 반환합니다.
    return dir.length > 1 && getPackageType(resolvePath(dir, '..'));
}
```

###### 동기 버전[#](https://nodejs.org/docs/latest/api/module.html#synchronous-version)

```javascript
// coffeescript-sync-hooks.mjs
import { readFileSync } from 'node:fs/promises';
import { registerHooks } from 'node:module';
import { dirname, extname, resolve as resolvePath } from 'node:path';
import { cwd } from 'node:process';
import { fileURLToPath, pathToFileURL } from 'node:url';
import coffeescript from 'coffeescript';

const extensionsRegex = /\.(coffee|litcoffee|coffee\.md)$/;

function load(url, context, nextLoad) {
    if (extensionsRegex.test(url)) {
        const format = getPackageType(url);
        const { source: rawSource } = nextLoad(url, { ...context, format });
        const transformedSource = coffeescript.compile(rawSource.toString(), url);

        return {
            format,
            shortCircuit: true,
            source: transformedSource,
        };
    }

    return nextLoad(url);
}

function getPackageType(url) {
    const isFilePath = !!extname(url);
    const dir = isFilePath ? dirname(fileURLToPath(url)) : url;
    const packagePath = resolvePath(dir, 'package.json');
    let type;

    try {
        const filestring = readFileSync(packagePath, { encoding: 'utf8' });
        type = JSON.parse(filestring).type;
    } catch (err) {
        if (err?.code !== 'ENOENT') console.error(err);
    }

    if (type) return type;
    return dir.length > 1 && getPackageType(resolvePath(dir, '..'));
}

registerHooks({ load });
```


##### 훅 실행하기

```coffee
# main.coffee
import { scream } from './scream.coffee'
console.log scream 'hello, world'
import { version } from 'node:process'
console.log "Brought to you by Node.js version #{version}"
```

```coffee
# scream.coffee
export scream = (str) -> str.toUpperCase()
```

위와 같은 훅 모듈을 사용할 때, `node --import 'data:text/javascript,import { register } from "node:module"; import { pathToFileURL } from "node:url"; register(pathToFileURL("./coffeescript-hooks.mjs"));' ./main.coffee` 또는 `node --import ./coffeescript-sync-hooks.mjs ./main.coffee` 명령어를 실행하면, `main.coffee` 파일이 디스크에서 소스 코드를 로드한 후 Node.js가 실행하기 전에 JavaScript로 변환됩니다. 이는 `import` 문을 통해 참조된 모든 `.coffee`, `.litcoffee`, `.coffee.md` 파일에도 동일하게 적용됩니다.


##### Import Maps

이전 두 예제에서는 `load` 훅을 정의했습니다. 이번에는 `resolve` 훅의 예제를 살펴보겠습니다. 이 훅 모듈은 `import-map.json` 파일을 읽어서 특정 스펙ifier를 다른 URL로 재정의합니다. (이는 "import maps" 스펙의 작은 부분 집합을 매우 단순하게 구현한 것입니다.)

###### 비동기 버전

```js
// import-map-hooks.js
import fs from 'node:fs/promises';

const { imports } = JSON.parse(await fs.readFile('import-map.json'));

export async function resolve(specifier, context, nextResolve) {
    if (Object.hasOwn(imports, specifier)) {
        return nextResolve(imports[specifier], context);
    }
    return nextResolve(specifier, context);
}
```

###### 동기 버전

```js
// import-map-sync-hooks.js
import fs from 'node:fs';
import module from 'node:module';

const { imports } = JSON.parse(fs.readFileSync('import-map.json', 'utf-8'));

function resolve(specifier, context, nextResolve) {
    if (Object.hasOwn(imports, specifier)) {
        return nextResolve(imports[specifier], context);
    }
    return nextResolve(specifier, context);
}

module.registerHooks({ resolve });
```

###### 훅 사용하기

다음 파일들이 있다고 가정해 봅시다:

```js
// main.js
import 'a-module';
```

```json
// import-map.json
{
    "imports": {
        "a-module": "./some-module.js"
    }
}
```

```js
// some-module.js
console.log('some module!');
```

이제 `node --import 'data:text/javascript,import { register } from "node:module"; import { pathToFileURL } from "node:url"; register(pathToFileURL("./import-map-hooks.js"));' main.js` 또는 `node --import ./import-map-sync-hooks.js main.js`를 실행하면 `some module!`이 출력됩니다.


### 소스 맵 v3 지원[#](https://nodejs.org/docs/latest/api/module.html#source-map-v3-support)

추가된 버전: v13.7.0, v12.17.0

소스 맵 캐시와 상호작용하기 위한 헬퍼 함수가 추가되었습니다. 이 캐시는 소스 맵 파싱이 활성화되고 모듈의 푸터에 [소스 맵 포함 지시문](https://sourcemaps.info/spec.html#h.lmz475t4mvbx)이 발견될 때 채워집니다.

소스 맵 파싱을 활성화하려면, Node.js를 [`--enable-source-maps`](https://nodejs.org/docs/latest/api/cli.html#--enable-source-maps) 플래그와 함께 실행하거나, [`NODE_V8_COVERAGE=dir`](https://nodejs.org/docs/latest/api/cli.html#node_v8_coveragedir)을 설정하여 코드 커버리지를 활성화해야 합니다.

```js
// module.mjs // ECMAScript 모듈에서
import { findSourceMap, SourceMap } from 'node:module';
```


#### `module.findSourceMap(path)`[#](https://nodejs.org/docs/latest/api/module.html#modulefindsourcemappath)

추가된 버전: v13.7.0, v12.17.0

-   `path` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<module.SourceMap>`](https://nodejs.org/docs/latest/api/module.html#class-modulesourcemap) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  소스 맵이 발견되면 `module.SourceMap`을 반환하고, 그렇지 않으면 `undefined`를 반환합니다.

`path`는 소스 맵을 가져올 파일의 절대 경로입니다.


#### 클래스: `module.SourceMap`[#](https://nodejs.org/docs/latest/api/module.html#class-modulesourcemap)

추가된 버전: v13.7.0, v12.17.0


```javascript
new SourceMap(payload[, { lineLengths }])
```

- `payload` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
- `lineLengths` [`<number[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

새로운 `sourceMap` 인스턴스를 생성합니다.

`payload`는 [Source map v3 형식](https://sourcemaps.info/spec.html#h.mofvlxcwqzej)과 일치하는 키를 가진 객체입니다:

- `file`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `version`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `sources`: [`<string[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `sourcesContent`: [`<string[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `names`: [`<string[]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `mappings`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `sourceRoot`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`lineLengths`는 생성된 코드에서 각 줄의 길이를 나타내는 선택적 배열입니다.


##### `sourceMap.payload`[#](https://nodejs.org/docs/latest/api/module.html#sourcemappayload)

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

[`SourceMap`](https://nodejs.org/docs/latest/api/module.html#class-modulesourcemap) 인스턴스를 생성하는 데 사용된 페이로드를 반환하는 Getter입니다.


##### `sourceMap.findEntry(lineOffset, columnOffset)`[#](https://nodejs.org/docs/latest/api/module.html#sourcemapfindentrylineoffset-columnoffset)

- `lineOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스 파일에서 0부터 시작하는 행 번호 오프셋
- `columnOffset` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스 파일에서 0부터 시작하는 컬럼 번호 오프셋
- 반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

생성된 소스 파일의 행 오프셋과 컬럼 오프셋을 입력하면, 원본 파일의 SourceMap 범위를 나타내는 객체를 반환합니다. 해당 범위를 찾지 못하면 빈 객체를 반환합니다.

반환된 객체는 다음과 같은 키를 포함합니다:

- `generatedLine`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스에서 범위 시작의 행 오프셋
- `generatedColumn`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스에서 범위 시작의 컬럼 오프셋
- `originalSource`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 원본 소스 파일 이름 (SourceMap에 보고된 대로)
- `originalLine`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원본 소스에서 범위 시작의 행 오프셋
- `originalColumn`: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원본 소스에서 범위 시작의 컬럼 오프셋
- `name`: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

반환된 값은 SourceMap에 나타난 원시 범위를 나타내며, 0부터 시작하는 오프셋을 기반으로 합니다. 에러 메시지나 CallSite 객체에서 사용되는 1부터 시작하는 행과 컬럼 번호와는 다릅니다.

에러 스택이나 CallSite 객체에서 보고된 `lineNumber`와 `columnNumber`에 해당하는 1부터 시작하는 행과 컬럼 번호를 얻으려면 `sourceMap.findOrigin(lineNumber, columnNumber)`를 사용하세요.


##### `sourceMap.findOrigin(lineNumber, columnNumber)`[#](https://nodejs.org/docs/latest/api/module.html#sourcemapfindoriginlinenumber-columnnumber)

-   `lineNumber` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스에서 호출 지점의 1부터 시작하는 줄 번호
-   `columnNumber` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 소스에서 호출 지점의 1부터 시작하는 컬럼 번호
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

생성된 소스에서 1부터 시작하는 `lineNumber`와 `columnNumber`를 기반으로, 원본 소스에서 해당 호출 지점의 위치를 찾습니다.

제공된 `lineNumber`와 `columnNumber`가 소스 맵에서 발견되지 않으면 빈 객체가 반환됩니다. 그렇지 않으면, 반환된 객체는 다음 키를 포함합니다:

-   name: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) 소스 맵에서 제공된 범위의 이름 (제공된 경우)
-   fileName: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 소스 맵에 보고된 원본 소스의 파일 이름
-   lineNumber: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원본 소스에서 해당 호출 지점의 1부터 시작하는 줄 번호
-   columnNumber: [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원본 소스에서 해당 호출 지점의 1부터 시작하는 컬럼 번호


