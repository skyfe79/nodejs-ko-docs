# Table of Contents

- [자식 프로세스](#자식-프로세스)
    - [비동기 프로세스 생성](#비동기-프로세스-생성)
      - [Windows에서 `.bat` 및 `.cmd` 파일 실행하기](#windows에서-bat-및-cmd-파일-실행하기)
      - [`child_process.exec(command, options)`](#child_processexeccommand-options)
      - [`child_process.execFile(file, args[, callback])`](#child_processexecfilefile-args-callback)
      - [`child_process.fork(modulePath, args)`](#child_processforkmodulepath-args)
      - [`child_process.spawn(command, args)`](#child_processspawncommand-args)
        - [`options.detached`](#optionsdetached)
    - [동기적 프로세스 생성](#동기적-프로세스-생성)
      - [`child_process.execFileSync(file, args)`](#child_processexecfilesyncfile-args)
      - [`child_process.execSync(command[, options])`](#child_processexecsynccommand-options)
      - [`child_process.spawnSync(command, args)`](#child_processspawnsynccommand-args)
    - [클래스: `ChildProcess`](#클래스-childprocess)
      - [이벤트: `'close'`](#이벤트-close)
      - [이벤트: `'disconnect'`](#이벤트-disconnect)
      - [이벤트: `'error'`](#이벤트-error)
      - [이벤트: `'exit'`](#이벤트-exit)
      - [이벤트: `'message'`](#이벤트-message)
      - [이벤트: `'spawn'`](#이벤트-spawn)
      - [`subprocess.channel`](#subprocesschannel)
        - [`subprocess.channel.ref()`](#subprocesschannelref)
        - [`subprocess.channel.unref()`](#subprocesschannelunref)
      - [`subprocess.connected`](#subprocessconnected)
      - [`subprocess.disconnect()`](#subprocessdisconnect)
      - [`subprocess.exitCode`](#subprocessexitcode)
      - [`subprocess.kill([signal])`](#subprocesskillsignal)
      - [`subprocess[Symbol.dispose]()`](#subprocesssymboldispose)
      - [`subprocess.killed`](#subprocesskilled)
      - [`subprocess.pid`](#subprocesspid)
      - [`subprocess.ref()`](#subprocessref)
      - [`subprocess.send(message[, sendHandle[, options]][, callback])`](#subprocesssendmessage-sendhandle-options-callback)
        - [예제: 서버 객체 전송하기](#예제-서버-객체-전송하기)
        - [예제: 소켓 객체 전송하기](#예제-소켓-객체-전송하기)
      - [`subprocess.signalCode`](#subprocesssignalcode)
      - [`subprocess.spawnargs`](#subprocessspawnargs)
      - [`subprocess.spawnfile`](#subprocessspawnfile)
      - [`subprocess.stderr`](#subprocessstderr)
      - [`subprocess.stdin`](#subprocessstdin)
      - [`subprocess.stdio`](#subprocessstdio)
      - [`subprocess.stdout`](#subprocessstdout)
      - [`subprocess.unref()`](#subprocessunref)
    - [`maxBuffer`와 유니코드](#maxbuffer와-유니코드)
    - [쉘 요구사항](#쉘-요구사항)
    - [기본 윈도우 셸](#기본-윈도우-셸)
    - [고급 직렬화](#고급-직렬화)

# 자식 프로세스

**소스 코드:** [lib/child_process.js](https://github.com/nodejs/node/blob/v23.5.0/lib/child_process.js)

`node:child_process` 모듈은 [`popen(3)`](http://man7.org/linux/man-pages/man3/popen.3.html)과 유사하지만 동일하지 않은 방식으로 하위 프로세스를 생성하는 기능을 제공합니다. 이 기능은 주로 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options) 함수를 통해 제공됩니다:

```js
import { spawn } from 'node:child_process';
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
    console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
    console.log(`child process exited with code ${code}`);
});
```

기본적으로, 부모 Node.js 프로세스와 생성된 하위 프로세스 사이에 `stdin`, `stdout`, `stderr` 파이프가 설정됩니다. 이 파이프는 제한된(플랫폼별로 다름) 용량을 가지고 있습니다. 하위 프로세스가 출력을 캡처하지 않고 이 제한을 초과하여 `stdout`에 데이터를 쓰면, 파이프 버퍼가 더 많은 데이터를 받을 때까지 하위 프로세스가 블록됩니다. 이는 셸에서의 파이프 동작과 동일합니다. 출력을 사용하지 않을 경우 `{ stdio: 'ignore' }` 옵션을 사용하세요.

명령어 탐색은 `options` 객체에 `env`가 포함된 경우 `options.env.PATH` 환경 변수를 사용하여 수행됩니다. 그렇지 않으면 `process.env.PATH`가 사용됩니다. `options.env`가 설정되었지만 `PATH`가 없는 경우, Unix에서는 기본 탐색 경로인 `/usr/bin:/bin`에서 탐색이 수행됩니다(execvpe/execvp에 대한 운영체제 매뉴얼 참조). Windows에서는 현재 프로세스의 환경 변수 `PATH`가 사용됩니다.

Windows에서는 환경 변수가 대소문자를 구분하지 않습니다. Node.js는 `env` 키를 사전순으로 정렬하고 대소문자를 구분하지 않고 일치하는 첫 번째 키를 사용합니다. 사전순으로 첫 번째 항목만 하위 프로세스에 전달됩니다. 이는 Windows에서 `PATH`와 `Path`와 같은 동일한 키의 여러 변형을 `env` 옵션에 전달할 때 문제를 일으킬 수 있습니다.

[`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options) 메서드는 Node.js 이벤트 루프를 블록하지 않고 비동기적으로 자식 프로세스를 생성합니다. [`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options) 함수는 동기적으로 동일한 기능을 제공하며, 생성된 프로세스가 종료되거나 중단될 때까지 이벤트 루프를 블록합니다.

편의를 위해 `node:child_process` 모듈은 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)과 [`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options)에 대한 몇 가지 동기 및 비동기 대안을 제공합니다. 이 대안들은 모두 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options) 또는 [`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options) 위에 구현되어 있습니다.

-   [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback): 셸을 생성하고 그 셸 내에서 명령어를 실행하며, 완료 시 `stdout`과 `stderr`를 콜백 함수에 전달합니다.
-   [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback): [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)과 유사하지만 기본적으로 셸을 먼저 생성하지 않고 명령어를 직접 실행합니다.
-   [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options): 새로운 Node.js 프로세스를 생성하고, 부모와 자식 간에 메시지를 보낼 수 있는 IPC 통신 채널을 설정하여 지정된 모듈을 호출합니다.
-   [`child_process.execSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecsynccommand-options): [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)의 동기 버전으로, Node.js 이벤트 루프를 블록합니다.
-   [`child_process.execFileSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilesyncfile-args-options): [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback)의 동기 버전으로, Node.js 이벤트 루프를 블록합니다.

특정 사용 사례, 예를 들어 셸 스크립트 자동화의 경우 [동기 대응 함수](https://nodejs.org/docs/latest/api/child_process.html#synchronous-process-creation)가 더 편리할 수 있습니다. 그러나 많은 경우, 동기 메서드는 생성된 프로세스가 완료될 때까지 이벤트 루프를 멈추게 하여 성능에 큰 영향을 미칠 수 있습니다.


### 비동기 프로세스 생성

[`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options), [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options), [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback), 그리고 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback) 메서드들은 모두 Node.js의 다른 API에서 일반적으로 사용되는 비동기 프로그래밍 패턴을 따릅니다.

이 메서드들은 각각 [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess) 인스턴스를 반환합니다. 이 객체들은 Node.js의 [`EventEmitter`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter) API를 구현하고 있어, 부모 프로세스가 자식 프로세스의 생명 주기 동안 발생하는 특정 이벤트에 대해 리스너 함수를 등록할 수 있습니다.

[`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)와 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback) 메서드는 추가적으로 자식 프로세스가 종료될 때 호출되는 선택적 `callback` 함수를 지정할 수 있습니다.


#### Windows에서 `.bat` 및 `.cmd` 파일 실행하기

[`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)와 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback)의 차이는 플랫폼에 따라 중요성이 달라질 수 있습니다. Unix 계열 운영체제(Unix, Linux, macOS)에서는 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback)이 기본적으로 셸을 실행하지 않기 때문에 더 효율적일 수 있습니다. 그러나 Windows에서는 `.bat` 및 `.cmd` 파일이 터미널 없이 단독으로 실행될 수 없으므로 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback)을 사용하여 실행할 수 없습니다. Windows에서 `.bat` 및 `.cmd` 파일을 실행하려면 `shell` 옵션을 설정한 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)을 사용하거나, [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)를 사용하거나, `cmd.exe`를 실행하고 `.bat` 또는 `.cmd` 파일을 인자로 전달하면 됩니다(`shell` 옵션과 [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)가 이 방식을 사용합니다). 어느 경우든, 스크립트 파일 이름에 공백이 포함되어 있다면 따옴표로 묶어야 합니다.

```js
// 또는... 
import { exec, spawn } from 'node:child_process';

exec('my.bat', (err, stdout, stderr) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(stdout);
});

// 파일 이름에 공백이 있는 스크립트:
const bat = spawn('"my script.cmd"', ['a', 'b'], { shell: true });

// 또는:
exec('"my script.cmd" a b', (err, stdout, stderr) => {
    // ...
});
```


#### `child_process.exec(command[, options][, callback])`

- `command` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 실행할 명령어와 공백으로 구분된 인자들.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `cwd` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api) 자식 프로세스의 현재 작업 디렉토리. **기본값:** `process.cwd()`.
    - `env` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 환경 변수 키-값 쌍. **기본값:** `process.env`.
    - `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'utf8'`
    - `shell` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 명령어를 실행할 셸. [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements)와 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell) 참고. **기본값:** Unix에서는 `'/bin/sh'`, Windows에서는 `process.env.ComSpec`.
    - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal) AbortSignal을 사용해 자식 프로세스를 중단할 수 있음.
    - `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `0`
    - `maxBuffer` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) stdout 또는 stderr에 허용되는 최대 데이터 크기(바이트 단위). 초과 시 자식 프로세스가 종료되고 출력이 잘림. [`maxBuffer` and Unicode](https://nodejs.org/docs/latest/api/child_process.html#maxbuffer-and-unicode) 참고. **기본값:** `1024 * 1024`.
    - `killSignal` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `'SIGTERM'`
    - `uid` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로세스의 사용자 ID 설정 (see [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html)).
    - `gid` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로세스의 그룹 ID 설정 (see [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html)).
    - `windowsHide` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Windows 시스템에서 생성되는 서브프로세스 콘솔 창을 숨김. **기본값:** `false`.
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 프로세스 종료 시 출력과 함께 호출됨.
    - `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    - `stdout` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)
    - `stderr` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)
- 반환값: [`<ChildProcess>`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess)

셸을 생성한 후 해당 셸 내에서 `command`를 실행하고, 생성된 출력을 버퍼링한다. `exec` 함수에 전달된 `command` 문자열은 셸에서 직접 처리되며, 특수 문자(셸에 따라 다름)는 적절히 처리해야 한다:

```js
import { exec } from 'node:child_process';
exec('"/path/to/test file/test.sh" arg1 arg2');
// 경로에 공백이 포함되어 있으므로 여러 인자의 구분자로 해석되지 않도록 큰따옴표 사용.
exec('echo "The \\$HOME variable is $HOME"');
// 첫 번째 $HOME 변수는 이스케이프 처리되었지만, 두 번째는 그렇지 않음.
```

**이 함수에 사용자 입력을 그대로 전달하지 마세요. 셸 메타문자가 포함된 입력은 임의의 명령어 실행을 유발할 수 있습니다.**

`callback` 함수가 제공되면, `(error, stdout, stderr)` 인자와 함께 호출된다. 성공 시 `error`는 `null`이다. 오류 발생 시 `error`는 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)의 인스턴스가 된다. `error.code` 속성은 프로세스의 종료 코드이다. 관례적으로, `0`이 아닌 종료 코드는 오류를 나타낸다. `error.signal`은 프로세스를 종료시킨 시그널이다.

`callback`에 전달된 `stdout`과 `stderr` 인자는 자식 프로세스의 stdout과 stderr 출력을 포함한다. 기본적으로 Node.js는 출력을 UTF-8로 디코딩하고 문자열을 `callback`에 전달한다. `encoding` 옵션을 사용해 stdout과 stderr 출력을 디코딩할 문자 인코딩을 지정할 수 있다. `encoding`이 `'buffer'`이거나 인식할 수 없는 문자 인코딩인 경우, `Buffer` 객체가 `callback`에 전달된다.

```js
import { exec } from 'node:child_process';
exec('cat *.js missing_file | wc -l', (error, stdout, stderr) => {
    if (error) {
        console.error(`exec error: ${error}`);
        return;
    }
    console.log(`stdout: ${stdout}`);
    console.error(`stderr: ${stderr}`);
});
```

`timeout`이 `0`보다 크면, 자식 프로세스가 `timeout` 밀리초 이상 실행될 경우 부모 프로세스가 `killSignal` 속성(기본값은 `'SIGTERM'`)으로 지정된 시그널을 보낸다.

POSIX 시스템 호출인 [`exec(3)`](http://man7.org/linux/man-pages/man3/exec.3.html)과 달리, `child_process.exec()`는 기존 프로세스를 대체하지 않고 셸을 사용해 명령어를 실행한다.

이 메서드를 [`util.promisify()`](https://nodejs.org/docs/latest/api/util.html#utilpromisifyoriginal)된 버전으로 호출하면, `stdout`과 `stderr` 속성을 가진 `Object`에 대한 `Promise`를 반환한다. 반환된 `ChildProcess` 인스턴스는 `Promise`의 `child` 속성으로 연결된다. 오류 발생 시(종료 코드가 0이 아닌 경우 포함), 거부된 `Promise`가 반환되며, `callback`에 전달된 `error` 객체와 동일한 객체에 `stdout`과 `stderr` 두 속성이 추가된다.

```js
import { promisify } from 'node:util';
import child_process from 'node:child_process';
const exec = promisify(child_process.exec);

async function lsExample() {
    const { stdout, stderr } = await exec('ls');
    console.log('stdout:', stdout);
    console.error('stderr:', stderr);
}

lsExample();
```

`signal` 옵션이 활성화된 경우, 해당 `AbortController`에서 `.abort()`를 호출하는 것은 자식 프로세스에서 `.kill()`을 호출하는 것과 유사하지만, `callback`에 전달된 오류는 `AbortError`가 된다:

```js
import { exec } from 'node:child_process';
const controller = new AbortController();
const { signal } = controller;
const child = exec('grep ssh', { signal }, (error) => {
    console.error(error); // AbortError
});
controller.abort();
```


#### `child_process.execFile(file[, args][, options][, callback])`

- `file` [`<string>`] 실행할 실행 파일의 이름 또는 경로
- `args` [`<string[]>`] 문자열 인자 목록
- `options` [`<Object>`]
  - `cwd` [`<string> | <URL>`] 자식 프로세스의 현재 작업 디렉토리
  - `env` [`<Object>`] 환경 변수 키-값 쌍. **기본값:** `process.env`
  - `encoding` [`<string>`] **기본값:** `'utf8'`
  - `timeout` [`<number>`] **기본값:** `0`
  - `maxBuffer` [`<number>`] stdout 또는 stderr에 허용되는 최대 데이터 크기(바이트 단위). 초과 시 자식 프로세스가 종료되고 출력이 잘림. 자세한 내용은 [`maxBuffer` and Unicode](https://nodejs.org/docs/latest/api/child_process.html#maxbuffer-and-unicode) 참조. **기본값:** `1024 * 1024`
  - `killSignal` [`<string> | <integer>`] **기본값:** `'SIGTERM'`
  - `uid` [`<number>`] 프로세스의 사용자 ID 설정 (참조: [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html))
  - `gid` [`<number>`] 프로세스의 그룹 ID 설정 (참조: [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html))
  - `windowsHide` [`<boolean>`] Windows 시스템에서 생성되는 서브프로세스 콘솔 창을 숨김. **기본값:** `false`
  - `windowsVerbatimArguments` [`<boolean>`] Windows에서 인자에 대한 따옴표나 이스케이프 처리를 하지 않음. Unix에서는 무시됨. **기본값:** `false`
  - `shell` [`<boolean> | <string>`] `true`일 경우, 쉘 내에서 명령어를 실행. Unix에서는 `'/bin/sh'`, Windows에서는 `process.env.ComSpec`을 사용. 다른 쉘을 문자열로 지정할 수 있음. 자세한 내용은 [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements) 및 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell) 참조. **기본값:** `false` (쉘 사용 안 함)
  - `signal` [`<AbortSignal>`] `AbortSignal`을 사용하여 자식 프로세스를 중단할 수 있음
- `callback` [`<Function>`] 프로세스가 종료될 때 출력과 함께 호출됨
  - `error` [`<Error>`]
  - `stdout` [`<string> | <Buffer>`]
  - `stderr` [`<string> | <Buffer>`]
- 반환값: [`<ChildProcess>`]

`child_process.execFile()` 함수는 기본적으로 쉘을 생성하지 않는다는 점에서 [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)와 유사합니다. 대신, 지정된 실행 파일 `file`이 새로운 프로세스로 직접 생성되어 [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)보다 약간 더 효율적입니다.

[`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)와 동일한 옵션을 지원합니다. 쉘이 생성되지 않기 때문에 I/O 리다이렉션 및 파일 글로빙과 같은 동작은 지원되지 않습니다.

```js
import { execFile } from 'node:child_process';
const child = execFile('node', ['--version'], (error, stdout, stderr) => {
    if (error) {
        throw error;
    }
    console.log(stdout);
});
```

콜백에 전달된 `stdout`과 `stderr` 인자는 자식 프로세스의 stdout 및 stderr 출력을 포함합니다. 기본적으로 Node.js는 출력을 UTF-8로 디코딩하여 문자열을 콜백에 전달합니다. `encoding` 옵션을 사용하여 stdout 및 stderr 출력을 디코딩하는 데 사용할 문자 인코딩을 지정할 수 있습니다. `encoding`이 `'buffer'`이거나 인식되지 않는 문자 인코딩일 경우, `Buffer` 객체가 콜백에 전달됩니다.

이 메서드를 [`util.promisify()`](https://nodejs.org/docs/latest/api/util.html#utilpromisifyoriginal)된 버전으로 호출하면, `stdout` 및 `stderr` 속성을 가진 `Object`에 대한 `Promise`를 반환합니다. 반환된 `ChildProcess` 인스턴스는 `Promise`의 `child` 속성으로 연결됩니다. 오류가 발생할 경우(0이 아닌 종료 코드를 포함한 모든 오류), 거부된 Promise가 반환되며, 콜백에 전달된 동일한 `error` 객체에 `stdout` 및 `stderr` 속성이 추가됩니다.

```js
import { promisify } from 'node:util';
import child_process from 'node:child_process';
const execFile = promisify(child_process.execFile);

async function getVersion() {
    const { stdout } = await execFile('node', ['--version']);
    console.log(stdout);
}

getVersion();
```

**`shell` 옵션이 활성화된 경우, 이 함수에 사용자 입력을 그대로 전달하지 마세요. 쉘 메타문자를 포함한 입력은 임의의 명령 실행을 유발할 수 있습니다.**

`signal` 옵션이 활성화된 경우, 해당 `AbortController`에서 `.abort()`를 호출하는 것은 자식 프로세스에서 `.kill()`을 호출하는 것과 유사하지만, 콜백에 전달된 오류는 `AbortError`가 됩니다:

```js
import { execFile } from 'node:child_process';
const controller = new AbortController();
const { signal } = controller;
const child = execFile('node', ['--version'], { signal }, (error) => {
    console.error(error); // AbortError
});
controller.abort();
```


#### `child_process.fork(modulePath[, args][, options])`

- `modulePath` [`<string>`] | [`<URL>`] 자식 프로세스에서 실행할 모듈의 경로
- `args` [`<string[]>`] 문자열 인자 목록
- `options` [`<Object>`]
    - `cwd` [`<string>`] | [`<URL>`] 자식 프로세스의 현재 작업 디렉토리
    - `detached` [`<boolean>`] 자식 프로세스가 부모 프로세스와 독립적으로 실행되도록 설정. 플랫폼에 따라 동작이 다름. 자세한 내용은 [`options.detached`](https://nodejs.org/docs/latest/api/child_process.html#optionsdetached) 참조.
    - `env` [`<Object>`] 환경 변수 키-값 쌍. **기본값:** `process.env`.
    - `execPath` [`<string>`] 자식 프로세스를 생성할 때 사용할 실행 파일 경로
    - `execArgv` [`<string[]>`] 실행 파일에 전달할 문자열 인자 목록. **기본값:** `process.execArgv`.
    - `gid` [`<number>`] 프로세스의 그룹 ID 설정 (참조: [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html))
    - `serialization` [`<string>`] 프로세스 간 메시지 전송에 사용할 직렬화 방식. 가능한 값은 `'json'`과 `'advanced'`. 자세한 내용은 [Advanced serialization](https://nodejs.org/docs/latest/api/child_process.html#advanced-serialization) 참조. **기본값:** `'json'`.
    - `signal` [`<AbortSignal>`] AbortSignal을 사용하여 자식 프로세스를 종료할 수 있음
    - `killSignal` [`<string>`] | [`<integer>`] 타임아웃 또는 중단 신호로 프로세스를 종료할 때 사용할 신호 값. **기본값:** `'SIGTERM'`.
    - `silent` [`<boolean>`] `true`로 설정하면 자식 프로세스의 stdin, stdout, stderr가 부모 프로세스로 파이프됨. 그렇지 않으면 부모 프로세스로부터 상속됨. 자세한 내용은 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio) 옵션 참조. **기본값:** `false`.
    - `stdio` [`<Array>`] | [`<string>`] [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio) 참조. 이 옵션을 제공하면 `silent`를 덮어씀. 배열 형태를 사용할 경우, 반드시 하나의 항목이 `'ipc'`여야 함. 예: `[0, 1, 2, 'ipc']`.
    - `uid` [`<number>`] 프로세스의 사용자 ID 설정 (참조: [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html))
    - `windowsVerbatimArguments` [`<boolean>`] Windows에서 인자에 대한 따옴표나 이스케이프 처리를 하지 않음. Unix에서는 무시됨. **기본값:** `false`.
    - `timeout` [`<number>`] 프로세스가 실행될 수 있는 최대 시간(밀리초 단위). **기본값:** `undefined`.
- 반환값: [`<ChildProcess>`]

`child_process.fork()` 메서드는 새로운 Node.js 프로세스를 생성하기 위해 특별히 설계된 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 특수한 경우입니다. [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)과 마찬가지로 [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess) 객체를 반환합니다. 반환된 [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess)는 부모와 자식 간에 메시지를 주고받을 수 있는 추가 통신 채널을 내장하고 있습니다. 자세한 내용은 [`subprocess.send()`](https://nodejs.org/docs/latest/api/child_process.html#subprocesssendmessage-sendhandle-options-callback)를 참조하세요.

생성된 Node.js 자식 프로세스는 부모와 독립적이며, 두 프로세스 간에 설정된 IPC 통신 채널만 예외입니다. 각 프로세스는 자체 메모리와 V8 인스턴스를 가집니다. 추가 리소스 할당이 필요하기 때문에, 많은 수의 Node.js 자식 프로세스를 생성하는 것은 권장되지 않습니다.

기본적으로 `child_process.fork()`는 부모 프로세스의 [`process.execPath`](https://nodejs.org/docs/latest/api/process.html#processexecpath)를 사용하여 새로운 Node.js 인스턴스를 생성합니다. `options` 객체의 `execPath` 속성을 통해 대체 실행 경로를 지정할 수 있습니다.

커스텀 `execPath`로 실행된 Node.js 프로세스는 자식 프로세스의 환경 변수 `NODE_CHANNEL_FD`로 식별된 파일 디스크립터(fd)를 사용하여 부모 프로세스와 통신합니다.

POSIX 시스템 호출인 [`fork(2)`](http://man7.org/linux/man-pages/man2/fork.2.html)과 달리, `child_process.fork()`는 현재 프로세스를 복제하지 않습니다.

[`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)에서 사용 가능한 `shell` 옵션은 `child_process.fork()`에서 지원되지 않으며, 설정해도 무시됩니다.

`signal` 옵션이 활성화된 경우, 해당 `AbortController`에서 `.abort()`를 호출하는 것은 자식 프로세스에서 `.kill()`을 호출하는 것과 유사하지만, 콜백에 전달되는 오류는 `AbortError`가 됩니다:

```js
import { fork } from 'node:child_process';
import process from 'node:process';

if (process.argv[2] === 'child') {
    setTimeout(() => {
        console.log(`Hello from ${process.argv[2]}!`);
    }, 1_000);
} else {
    const controller = new AbortController();
    const { signal } = controller;
    const child = fork(import.meta.url, ['child'], { signal });
    child.on('error', (err) => {
        // 컨트롤러가 중단되면 err는 AbortError가 됨
    });
    controller.abort(); // 자식 프로세스 중단
}
```


#### `child_process.spawn(command[, args][, options])`

- `command` [`<string>`] 실행할 명령어
- `args` [`<string[]>`] 문자열 인자 목록
- `options` [`<Object>`]
    - `cwd` [`<string>`] | [`<URL>`] 자식 프로세스의 현재 작업 디렉토리
    - `env` [`<Object>`] 환경 변수 키-값 쌍. **기본값:** `process.env`
    - `argv0` [`<string>`] 자식 프로세스에 전달될 `argv[0]` 값을 명시적으로 설정. 지정하지 않으면 `command`로 설정됨
    - `stdio` [`<Array>`] | [`<string>`] 자식 프로세스의 stdio 설정 (참조: [`options.stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio))
    - `detached` [`<boolean>`] 자식 프로세스가 부모 프로세스와 독립적으로 실행되도록 준비. 플랫폼에 따라 동작이 다름 (참조: [`options.detached`](https://nodejs.org/docs/latest/api/child_process.html#optionsdetached))
    - `uid` [`<number>`] 프로세스의 사용자 ID 설정 (참조: [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html))
    - `gid` [`<number>`] 프로세스의 그룹 ID 설정 (참조: [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html))
    - `serialization` [`<string>`] 프로세스 간 메시지 전송에 사용될 직렬화 방식 지정. 가능한 값은 `'json'`과 `'advanced'`. 자세한 내용은 [Advanced serialization](https://nodejs.org/docs/latest/api/child_process.html#advanced-serialization) 참조. **기본값:** `'json'`
    - `shell` [`<boolean>`] | [`<string>`] `true`로 설정하면 `command`를 셸 안에서 실행. Unix에서는 `'/bin/sh'`, Windows에서는 `process.env.ComSpec` 사용. 다른 셸을 문자열로 지정 가능. 자세한 내용은 [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements)와 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell) 참조. **기본값:** `false` (셸 사용 안 함)
    - `windowsVerbatimArguments` [`<boolean>`] Windows에서 인자에 대한 따옴표나 이스케이프를 하지 않음. Unix에서는 무시됨. `shell`이 지정되고 CMD인 경우 자동으로 `true`로 설정됨. **기본값:** `false`
    - `windowsHide` [`<boolean>`] Windows 시스템에서 생성되는 서브프로세스 콘솔 창을 숨김. **기본값:** `false`
    - `signal` [`<AbortSignal>`] `AbortSignal`을 사용하여 자식 프로세스를 중단할 수 있음
    - `timeout` [`<number>`] 프로세스가 실행될 수 있는 최대 시간(밀리초). **기본값:** `undefined`
    - `killSignal` [`<string>`] | [`<integer>`] 타임아웃이나 중단 신호로 인해 생성된 프로세스가 종료될 때 사용될 신호 값. **기본값:** `'SIGTERM'`
- 반환값: [`<ChildProcess>`]

`child_process.spawn()` 메서드는 주어진 `command`와 `args`에 있는 커맨드라인 인자를 사용하여 새로운 프로세스를 생성한다. `args`가 생략되면 기본값으로 빈 배열이 사용된다.

**`shell` 옵션이 활성화된 경우, 이 함수에 사용자 입력을 그대로 전달하지 마세요. 셸 메타문자가 포함된 입력은 임의의 명령 실행을 유발할 수 있습니다.**

세 번째 인자로 추가 옵션을 지정할 수 있으며, 기본값은 다음과 같다:

```js
const defaults = { cwd: undefined, env: process.env };
```

`cwd`를 사용하여 프로세스가 생성될 작업 디렉토리를 지정할 수 있다. 지정하지 않으면 현재 작업 디렉토리를 상속받는다. 지정한 경로가 존재하지 않으면 자식 프로세스는 `ENOENT` 오류를 발생시키고 즉시 종료된다. 명령어가 존재하지 않을 때도 `ENOENT` 오류가 발생한다.

`env`를 사용하여 새로운 프로세스에서 볼 수 있는 환경 변수를 지정할 수 있으며, 기본값은 [`process.env`](https://nodejs.org/docs/latest/api/process.html#processenv)이다.

`env`에서 `undefined` 값은 무시된다.

`ls -lh /usr`를 실행하고 `stdout`, `stderr`, 그리고 종료 코드를 캡처하는 예제:

```js
import { spawn } from 'node:child_process';
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) => {
    console.error(`stderr: ${data}`);
});

ls.on('close', (code) => {
    console.log(`child process exited with code ${code}`);
});
```

`ps ax | grep ssh`를 실행하는 복잡한 예제:

```js
import { spawn } from 'node:child_process';
const ps = spawn('ps', ['ax']);
const grep = spawn('grep', ['ssh']);

ps.stdout.on('data', (data) => {
    grep.stdin.write(data);
});

ps.stderr.on('data', (data) => {
    console.error(`ps stderr: ${data}`);
});

ps.on('close', (code) => {
    if (code !== 0) {
        console.log(`ps process exited with code ${code}`);
    }
    grep.stdin.end();
});

grep.stdout.on('data', (data) => {
    console.log(data.toString());
});

grep.stderr.on('data', (data) => {
    console.error(`grep stderr: ${data}`);
});

grep.on('close', (code) => {
    if (code !== 0) {
        console.log(`grep process exited with code ${code}`);
    }
});
```

`spawn` 실패를 확인하는 예제:

```js
import { spawn } from 'node:child_process';
const subprocess = spawn('bad_command');

subprocess.on('error', (err) => {
    console.error('Failed to start subprocess.');
});
```

일부 플랫폼(macOS, Linux)에서는 `argv[0]` 값을 프로세스 제목으로 사용하지만, 다른 플랫폼(Windows, SunOS)에서는 `command`를 사용한다.

Node.js는 시작 시 `argv[0]`을 `process.execPath`로 덮어쓰므로, Node.js 자식 프로세스에서 `process.argv[0]`은 부모에서 `spawn`에 전달된 `argv0` 매개변수와 일치하지 않는다. 대신 `process.argv0` 속성을 사용하여 값을 가져올 수 있다.

`signal` 옵션이 활성화된 경우, 해당 `AbortController`에서 `.abort()`를 호출하는 것은 자식 프로세스에서 `.kill()`을 호출하는 것과 유사하지만, 콜백에 전달되는 오류는 `AbortError`가 된다:

```js
import { spawn } from 'node:child_process';
const controller = new AbortController();
const { signal } = controller;
const grep = spawn('grep', ['ssh'], { signal });

grep.on('error', (err) => {
    // 컨트롤러가 중단되면 err이 AbortError로 호출됨
});

controller.abort(); // 자식 프로세스 중단
```


##### `options.detached`[#](https://nodejs.org/docs/latest/api/child_process.html#optionsdetached)

추가된 버전: v0.7.10

**Windows**에서는 `options.detached`를 `true`로 설정하면 부모 프로세스가 종료된 후에도 자식 프로세스가 계속 실행될 수 있습니다. 이 경우 자식 프로세스는 자신만의 콘솔 윈도우를 가지게 됩니다. 한번 자식 프로세스에 대해 이 옵션이 활성화되면 비활성화할 수 없습니다.

**Windows가 아닌 플랫폼**에서는 `options.detached`를 `true`로 설정하면 자식 프로세스가 새로운 프로세스 그룹과 세션의 리더가 됩니다. 이 경우 부모 프로세스가 종료된 후에도 자식 프로세스는 계속 실행될 수 있습니다. 자세한 내용은 [`setsid(2)`](http://man7.org/linux/man-pages/man2/setsid.2.html)를 참조하세요.

기본적으로 부모 프로세스는 분리된 자식 프로세스가 종료될 때까지 기다립니다. 부모 프로세스가 특정 `subprocess`가 종료될 때까지 기다리지 않도록 하려면 `subprocess.unref()` 메서드를 사용하세요. 이렇게 하면 부모 프로세스의 이벤트 루프가 자식 프로세스를 참조 카운트에 포함하지 않게 되어, 부모 프로세스가 자식 프로세스와 독립적으로 종료될 수 있습니다. 단, 자식과 부모 프로세스 간에 IPC 채널이 설정된 경우는 예외입니다.

`detached` 옵션을 사용하여 장기 실행 프로세스를 시작할 때, 부모 프로세스가 종료된 후에도 백그라운드에서 프로세스가 계속 실행되려면 부모 프로세스와 연결되지 않은 `stdio` 구성을 제공해야 합니다. 부모 프로세스의 `stdio`가 상속된 경우, 자식 프로세스는 제어 터미널에 계속 연결된 상태로 유지됩니다.

다음은 부모 프로세스의 종료를 무시하기 위해 자식 프로세스를 분리하고 부모 프로세스의 `stdio` 파일 디스크립터를 무시하는 장기 실행 프로세스의 예제입니다:

```js
import { spawn } from 'node:child_process';
import process from 'node:process';

const subprocess = spawn(process.argv[0], ['child_program.js'], {
    detached: true,
    stdio: 'ignore',
});

subprocess.unref();
```

또는 자식 프로세스의 출력을 파일로 리디렉션할 수도 있습니다:

```js
import { openSync } from 'node:fs';
import { spawn } from 'node:child_process';

const out = openSync('./out.log', 'a');
const err = openSync('./out.log', 'a');

const subprocess = spawn('prg', [], {
    detached: true,
    stdio: ['ignore', out, err],
});

subprocess.unref();
```


`options.stdio` 옵션은 부모 프로세스와 자식 프로세스 간에 생성되는 파이프를 설정하는 데 사용됩니다. 기본적으로 자식 프로세스의 `stdin`, `stdout`, `stderr`는 [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess) 객체의 [`subprocess.stdin`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdin), [`subprocess.stdout`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdout), [`subprocess.stderr`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstderr) 스트림으로 리디렉션됩니다. 이는 `options.stdio`를 `['pipe', 'pipe', 'pipe']`로 설정한 것과 동일합니다.

편의를 위해 `options.stdio`는 다음 문자열 중 하나일 수 있습니다:

- `'pipe'`: `['pipe', 'pipe', 'pipe']`와 동일 (기본값)
- `'overlapped'`: `['overlapped', 'overlapped', 'overlapped']`와 동일
- `'ignore'`: `['ignore', 'ignore', 'ignore']`와 동일
- `'inherit'`: `['inherit', 'inherit', 'inherit']` 또는 `[0, 1, 2]`와 동일

그렇지 않으면 `options.stdio`는 각 인덱스가 자식 프로세스의 파일 디스크립터(fd)에 해당하는 배열입니다. fd 0, 1, 2는 각각 `stdin`, `stdout`, `stderr`에 해당합니다. 추가 fd를 지정하여 부모와 자식 간에 추가 파이프를 생성할 수 있습니다. 값은 다음 중 하나입니다:

1. `'pipe'`: 자식 프로세스와 부모 프로세스 간에 파이프를 생성합니다. 파이프의 부모 측은 `child_process` 객체의 속성으로 [`subprocess.stdio[fd]`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdio)로 노출됩니다. fd 0, 1, 2에 생성된 파이프는 각각 [`subprocess.stdin`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdin), [`subprocess.stdout`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdout), [`subprocess.stderr`](https://nodejs.org/docs/latest/api/child_process.html#subprocessstderr)로도 사용할 수 있습니다. 이는 실제 Unix 파이프가 아니므로 자식 프로세스는 `/dev/fd/2`나 `/dev/stdout` 같은 파일 디스크립터로 사용할 수 없습니다.

2. `'overlapped'`: `'pipe'`와 동일하지만, 핸들에 `FILE_FLAG_OVERLAPPED` 플래그가 설정됩니다. 이는 자식 프로세스의 stdio 핸들에서 겹쳐진 I/O를 위해 필요합니다. 자세한 내용은 [문서](https://docs.microsoft.com/en-us/windows/win32/fileio/synchronous-and-asynchronous-i-o)를 참고하세요. 비윈도우 시스템에서는 `'pipe'`와 동일합니다.

3. `'ipc'`: 부모와 자식 간에 메시지나 파일 디스크립터를 전달하기 위한 IPC 채널을 생성합니다. [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess)는 최대 하나의 IPC stdio 파일 디스크립터를 가질 수 있습니다. 이 옵션을 설정하면 [`subprocess.send()`](https://nodejs.org/docs/latest/api/child_process.html#subprocesssendmessage-sendhandle-options-callback) 메서드가 활성화됩니다. 자식 프로세스가 Node.js 인스턴스인 경우, IPC 채널이 있으면 [`process.send()`](https://nodejs.org/docs/latest/api/process.html#processsendmessage-sendhandle-options-callback), [`process.disconnect()`](https://nodejs.org/docs/latest/api/process.html#processdisconnect) 메서드와 [`'disconnect'`](https://nodejs.org/docs/latest/api/process.html#event-disconnect), [`'message'`](https://nodejs.org/docs/latest/api/process.html#event-message) 이벤트가 활성화됩니다.

    [`process.send()`](https://nodejs.org/docs/latest/api/process.html#processsendmessage-sendhandle-options-callback) 이외의 방법으로 IPC 채널 fd에 접근하거나, Node.js 인스턴스가 아닌 자식 프로세스와 IPC 채널을 사용하는 것은 지원되지 않습니다.

4. `'ignore'`: Node.js가 자식 프로세스의 fd를 무시하도록 지시합니다. Node.js는 항상 생성하는 프로세스에 대해 fd 0, 1, 2를 열지만, fd를 `'ignore'`로 설정하면 Node.js가 `/dev/null`을 열어 자식 프로세스의 fd에 연결합니다.

5. `'inherit'`: 부모 프로세스의 해당 stdio 스트림을 자식 프로세스에 전달합니다. 처음 세 위치에서는 각각 `process.stdin`, `process.stdout`, `process.stderr`와 동일합니다. 다른 위치에서는 `'ignore'`와 동일합니다.

6. [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) 객체: tty, 파일, 소켓 또는 파이프를 참조하는 읽기/쓰기 가능한 스트림을 자식 프로세스와 공유합니다. 스트림의 기본 파일 디스크립터는 `stdio` 배열의 인덱스에 해당하는 fd로 자식 프로세스에 복제됩니다. 스트림은 기본 디스크립터를 가져야 합니다 (파일 스트림은 `'open'` 이벤트가 발생할 때까지 시작되지 않음). **참고:** `stdin`을 쓰기 가능한 스트림으로 전달하거나 `stdout`/`stderr`를 읽기 가능한 스트림으로 전달하는 것은 기술적으로 가능하지만 권장하지 않습니다. 읽기와 쓰기 스트림은 서로 다른 동작을 위해 설계되었으며, 잘못 사용하면 예상치 못한 결과나 오류가 발생할 수 있습니다. 이는 정의되지 않은 동작이나 콜백 누락을 초래할 수 있으므로 피해야 합니다. 항상 `stdin`은 쓰기 가능한 스트림으로, `stdout`/`stderr`는 읽기 가능한 스트림으로 사용하여 데이터 흐름을 유지하세요.

7. 양의 정수: 정수 값은 부모 프로세스에서 열려 있는 파일 디스크립터로 해석됩니다. 이는 [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream) 객체를 공유하는 방식과 유사하게 자식 프로세스와 공유됩니다. 윈도우에서는 소켓 전달이 지원되지 않습니다.

8. `null`, `undefined`: 기본값을 사용합니다. stdio fd 0, 1, 2(즉, `stdin`, `stdout`, `stderr`)에 대해 파이프가 생성됩니다. fd 3 이상에 대해서는 기본값이 `'ignore'`입니다.

```js
import { spawn } from 'node:child_process';
import process from 'node:process';

// 자식 프로세스가 부모의 stdios를 사용합니다.
spawn('prg', [], { stdio: 'inherit' });

// stderr만 공유하여 자식 프로세스를 생성합니다.
spawn('prg', [], { stdio: ['pipe', 'pipe', process.stderr] });

// 추가 fd=4를 열어 startd 스타일 인터페이스를 제공하는 프로그램과 상호작용합니다.
spawn('prg', [], { stdio: ['pipe', null, null, null, 'pipe'] });
```

*부모와 자식 프로세스 간에 IPC 채널이 설정되고, 자식 프로세스가 Node.js 인스턴스인 경우, 자식 프로세스는 [`'disconnect'`](https://nodejs.org/docs/latest/api/process.html#event-disconnect) 이벤트나 [`'message'`](https://nodejs.org/docs/latest/api/process.html#event-message) 이벤트에 대한 핸들러를 등록할 때까지 IPC 채널이 참조되지 않은 상태로(`unref()`) 실행됩니다. 이는 자식 프로세스가 열려 있는 IPC 채널로 인해 프로세스가 종료되지 않고 정상적으로 종료될 수 있도록 합니다.* 참고: [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback) 및 [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options).


### 동기적 프로세스 생성

[`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options), [`child_process.execSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecsynccommand-options), 그리고 [`child_process.execFileSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilesyncfile-args-options) 메서드는 동기적으로 동작하며, Node.js 이벤트 루프를 차단합니다. 이는 생성된 프로세스가 종료될 때까지 추가 코드 실행을 일시 중지합니다.

이러한 차단 호출은 일반적인 스크립팅 작업을 단순화하거나 애플리케이션 시작 시 설정을 로드하고 처리하는 데 주로 유용합니다.


#### `child_process.execFileSync(file[, args][, options])`

- `file` [`<string>`] 실행할 파일의 이름 또는 경로.
- `args` [`<string[]>`] 문자열 인자 목록.
- `options` [`<Object>`]
  - `cwd` [`<string>`] | [`<URL>`] 자식 프로세스의 현재 작업 디렉토리.
  - `input` [`<string>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`] 생성된 프로세스의 stdin으로 전달될 값. `stdio[0]`이 `'pipe'`로 설정된 경우, 이 값을 제공하면 `stdio[0]`을 덮어씁니다.
  - `stdio` [`<string>`] | [`<Array>`] 자식 프로세스의 stdio 설정. [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio)를 참조하세요. `stdio`가 지정되지 않은 경우, `stderr`는 기본적으로 부모 프로세스의 stderr로 출력됩니다. **기본값:** `'pipe'`.
  - `env` [`<Object>`] 환경 변수 키-값 쌍. **기본값:** `process.env`.
  - `uid` [`<number>`] 프로세스의 사용자 ID를 설정합니다. ([`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html) 참조).
  - `gid` [`<number>`] 프로세스의 그룹 ID를 설정합니다. ([`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html) 참조).
  - `timeout` [`<number>`] 프로세스가 실행될 수 있는 최대 시간(밀리초 단위). **기본값:** `undefined`.
  - `killSignal` [`<string>`] | [`<integer>`] 생성된 프로세스를 종료할 때 사용할 신호 값. **기본값:** `'SIGTERM'`.
  - `maxBuffer` [`<number>`] stdout 또는 stderr에 허용되는 최대 데이터 크기(바이트 단위). 이 값을 초과하면 자식 프로세스가 종료됩니다. [`maxBuffer` and Unicode](https://nodejs.org/docs/latest/api/child_process.html#maxbuffer-and-unicode)의 주의사항을 참조하세요. **기본값:** `1024 * 1024`.
  - `encoding` [`<string>`] 모든 stdio 입력 및 출력에 사용될 인코딩. **기본값:** `'buffer'`.
  - `windowsHide` [`<boolean>`] Windows 시스템에서 생성되는 서브프로세스 콘솔 창을 숨깁니다. **기본값:** `false`.
  - `shell` [`<boolean>`] | [`<string>`] `true`로 설정하면 명령어를 셸 내부에서 실행합니다. Unix에서는 `'/bin/sh'`를 사용하고, Windows에서는 `process.env.ComSpec`을 사용합니다. 다른 셸을 문자열로 지정할 수 있습니다. [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements)와 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell)을 참조하세요. **기본값:** `false` (셸 사용 안 함).
- 반환값: [`<Buffer>`] | [`<string>`] 명령어의 stdout.

`child_process.execFileSync()` 메서드는 일반적으로 [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback)과 동일하지만, 자식 프로세스가 완전히 종료될 때까지 메서드가 반환되지 않는다는 점이 다릅니다. 타임아웃이 발생하고 `killSignal`이 전송되면, 프로세스가 완전히 종료될 때까지 메서드가 반환되지 않습니다.

자식 프로세스가 `SIGTERM` 신호를 가로채고 처리하여 종료되지 않더라도, 부모 프로세스는 자식 프로세스가 종료될 때까지 계속 기다립니다.

프로세스가 타임아웃되거나 0이 아닌 종료 코드를 반환하면, 이 메서드는 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error)를 발생시키며, 이 에러는 내부적으로 사용된 [`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options)의 전체 결과를 포함합니다.

**`shell` 옵션이 활성화된 경우, 이 함수에 검증되지 않은 사용자 입력을 전달하지 마세요. 셸 메타문자가 포함된 입력은 임의의 명령 실행을 유발할 수 있습니다.**

```js
import { execFileSync } from 'node:child_process';

try {
  const stdout = execFileSync('my-script.sh', ['my-arg'], {
    // 자식 프로세스의 stdout과 stderr를 캡처합니다.
    // 자식 stderr를 부모 stderr로 스트리밍하는 기본 동작을 덮어씁니다.
    stdio: 'pipe',
    // stdio 파이프에 utf8 인코딩 사용
    encoding: 'utf8',
  });
  console.log(stdout);
} catch (err) {
  if (err.code) {
    // 자식 프로세스 생성 실패
    console.error(err.code);
  } else {
    // 자식 프로세스가 생성되었지만 0이 아닌 종료 코드로 종료됨
    // 에러는 자식 프로세스의 stdout과 stderr를 포함
    const { stdout, stderr } = err;
    console.error({ stdout, stderr });
  }
}
```


#### `child_process.execSync(command[, options])`

- `command` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 실행할 명령어.
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    - `cwd` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api) 자식 프로세스의 현재 작업 디렉토리.
    - `input` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) 생성된 프로세스의 stdin으로 전달될 값. `stdio[0]`이 `'pipe'`로 설정된 경우, 이 값을 제공하면 `stdio[0]`을 덮어씁니다.
    - `stdio` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) 자식 프로세스의 stdio 설정. [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio)를 참조하세요. `stdio`가 지정되지 않은 경우, `stderr`는 기본적으로 부모 프로세스의 stderr로 출력됩니다. **기본값:** `'pipe'`.
    - `env` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 환경 변수 키-값 쌍. **기본값:** `process.env`.
    - `shell` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 명령어를 실행할 셸. [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements)와 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell)을 참조하세요. **기본값:** Unix에서는 `'/bin/sh'`, Windows에서는 `process.env.ComSpec`.
    - `uid` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로세스의 사용자 ID를 설정합니다. ([`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html) 참조).
    - `gid` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로세스의 그룹 ID를 설정합니다. ([`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html) 참조).
    - `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로세스가 실행될 수 있는 최대 시간(밀리초 단위). **기본값:** `undefined`.
    - `killSignal` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 생성된 프로세스를 종료할 때 사용할 신호 값. **기본값:** `'SIGTERM'`.
    - `maxBuffer` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) stdout 또는 stderr에 허용되는 최대 데이터 크기(바이트 단위). 이 값을 초과하면 자식 프로세스가 종료되고 출력이 잘립니다. [`maxBuffer` and Unicode](https://nodejs.org/docs/latest/api/child_process.html#maxbuffer-and-unicode)의 주의사항을 참조하세요. **기본값:** `1024 * 1024`.
    - `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 모든 stdio 입력 및 출력에 사용할 인코딩. **기본값:** `'buffer'`.
    - `windowsHide` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) Windows 시스템에서 일반적으로 생성되는 서브프로세스 콘솔 창을 숨깁니다. **기본값:** `false`.
- 반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 명령어의 stdout.

`child_process.execSync()` 메서드는 일반적으로 [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)와 동일하지만, 자식 프로세스가 완전히 종료될 때까지 메서드가 반환되지 않는다는 점이 다릅니다. 타임아웃이 발생하고 `killSignal`이 전송되면, 프로세스가 완전히 종료될 때까지 메서드가 반환되지 않습니다. 자식 프로세스가 `SIGTERM` 신호를 가로채고 처리하여 종료하지 않으면, 부모 프로세스는 자식 프로세스가 종료될 때까지 기다립니다.

프로세스가 타임아웃되거나 0이 아닌 종료 코드를 반환하면, 이 메서드는 예외를 발생시킵니다. [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error) 객체는 [`child_process.spawnSync()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawnsynccommand-args-options)의 전체 결과를 포함합니다.

**이 함수에 검증되지 않은 사용자 입력을 전달하지 마세요. 셸 메타문자를 포함한 입력은 임의의 명령어 실행을 유발할 수 있습니다.**


#### `child_process.spawnSync(command[, args][, options])`

- `command` [`<string>`] 실행할 커맨드.
- `args` [`<string[]>`] 문자열 인자 목록.
- `options` [`<Object>`]
  - `cwd` [`<string> | <URL>`] 자식 프로세스의 현재 작업 디렉토리.
  - `input` [`<string> | <Buffer> | <TypedArray> | <DataView>`] 자식 프로세스의 stdin으로 전달될 값. `stdio[0]`이 `'pipe'`로 설정된 경우, 이 값을 제공하면 `stdio[0]`을 덮어씁니다.
  - `argv0` [`<string>`] 자식 프로세스에 전달될 `argv[0]` 값을 명시적으로 설정. 지정하지 않으면 `command`로 설정됩니다.
  - `stdio` [`<string> | <Array>`] 자식 프로세스의 stdio 설정. [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)의 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio) 참조. **기본값:** `'pipe'`.
  - `env` [`<Object>`] 환경 변수 키-값 쌍. **기본값:** `process.env`.
  - `uid` [`<number>`] 프로세스의 사용자 ID 설정 (참조: [`setuid(2)`](http://man7.org/linux/man-pages/man2/setuid.2.html)).
  - `gid` [`<number>`] 프로세스의 그룹 ID 설정 (참조: [`setgid(2)`](http://man7.org/linux/man-pages/man2/setgid.2.html)).
  - `timeout` [`<number>`] 프로세스가 실행될 수 있는 최대 시간(밀리초). **기본값:** `undefined`.
  - `killSignal` [`<string> | <integer>`] 자식 프로세스를 종료할 때 사용할 시그널 값. **기본값:** `'SIGTERM'`.
  - `maxBuffer` [`<number>`] stdout 또는 stderr에 허용되는 최대 데이터 크기(바이트). 초과할 경우 자식 프로세스가 종료되고 출력이 잘립니다. [`maxBuffer` and Unicode](https://nodejs.org/docs/latest/api/child_process.html#maxbuffer-and-unicode) 참조. **기본값:** `1024 * 1024`.
  - `encoding` [`<string>`] 모든 stdio 입력 및 출력에 사용될 인코딩. **기본값:** `'buffer'`.
  - `shell` [`<boolean> | <string>`] `true`로 설정하면 쉘 내에서 `command`를 실행. Unix에서는 `'/bin/sh'`, Windows에서는 `process.env.ComSpec`을 사용. 다른 쉘을 문자열로 지정할 수 있습니다. [Shell requirements](https://nodejs.org/docs/latest/api/child_process.html#shell-requirements) 및 [Default Windows shell](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell) 참조. **기본값:** `false` (쉘 사용 안 함).
  - `windowsVerbatimArguments` [`<boolean>`] Windows에서 인자에 대한 따옴표나 이스케이프 처리를 하지 않음. Unix에서는 무시. `shell`이 지정되고 CMD인 경우 자동으로 `true`로 설정. **기본값:** `false`.
  - `windowsHide` [`<boolean>`] Windows 시스템에서 일반적으로 생성되는 서브프로세스 콘솔 창을 숨김. **기본값:** `false`.
- 반환값: [`<Object>`]
  - `pid` [`<number>`] 자식 프로세스의 PID.
  - `output` [`<Array>`] stdio 출력 결과 배열.
  - `stdout` [`<Buffer> | <string>`] `output[1]`의 내용.
  - `stderr` [`<Buffer> | <string>`] `output[2]`의 내용.
  - `status` [`<number> | <null>`] 서브프로세스의 종료 코드. 시그널로 종료된 경우 `null`.
  - `signal` [`<string> | <null>`] 서브프로세스를 종료한 시그널. 시그널로 종료되지 않은 경우 `null`.
  - `error` [`<Error>`] 자식 프로세스가 실패하거나 타임아웃된 경우의 에러 객체.

`child_process.spawnSync()` 메서드는 일반적으로 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)과 동일하지만, 자식 프로세스가 완전히 종료될 때까지 함수가 반환되지 않는다는 점이 다릅니다. 타임아웃이 발생하고 `killSignal`이 전송되면, 프로세스가 완전히 종료될 때까지 메서드가 반환되지 않습니다. 프로세스가 `SIGTERM` 시그널을 가로채고 처리하여 종료되지 않으면, 부모 프로세스는 자식 프로세스가 종료될 때까지 기다립니다.

**`shell` 옵션이 활성화된 경우, 이 함수에 검증되지 않은 사용자 입력을 전달하지 마세요. 쉘 메타문자가 포함된 입력은 임의의 커맨드 실행을 유발할 수 있습니다.**


### 클래스: `ChildProcess`[#](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess)

추가된 버전: v2.2.0

-   상속: [`<EventEmitter>`](https://nodejs.org/docs/latest/api/events.html#class-eventemitter)

`ChildProcess`의 인스턴스는 생성된 자식 프로세스를 나타냅니다.

`ChildProcess`의 인스턴스는 직접 생성하지 않습니다. 대신 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options), [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback), [`child_process.execFile()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexecfilefile-args-options-callback), 또는 [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options) 메서드를 사용하여 `ChildProcess` 인스턴스를 생성합니다.


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/child_process.html#event-close)

추가된 버전: v0.7.7

-   `code` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 자식 프로세스가 스스로 종료된 경우의 종료 코드.
-   `signal` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 자식 프로세스가 종료된 신호.

`'close'` 이벤트는 프로세스가 종료되고 자식 프로세스의 stdio 스트림이 닫힌 후에 발생합니다. 이 이벤트는 [`'exit'`](https://nodejs.org/docs/latest/api/child_process.html#event-exit) 이벤트와 구별됩니다. 여러 프로세스가 동일한 stdio 스트림을 공유할 수 있기 때문입니다. `'close'` 이벤트는 항상 [`'exit'`](https://nodejs.org/docs/latest/api/child_process.html#event-exit) 이벤트가 발생한 후에 발생하거나, 자식 프로세스가 생성되지 못한 경우 [`'error'`](https://nodejs.org/docs/latest/api/child_process.html#event-error) 이벤트가 발생한 후에 발생합니다.

```js
import { spawn } from 'node:child_process';

const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
});

ls.on('close', (code) => {
    console.log(`자식 프로세스가 모든 stdio를 닫았습니다. 종료 코드: ${code}`);
});

ls.on('exit', (code) => {
    console.log(`자식 프로세스가 종료되었습니다. 종료 코드: ${code}`);
});
```


#### 이벤트: `'disconnect'`[#](https://nodejs.org/docs/latest/api/child_process.html#event-disconnect)

추가된 버전: v0.7.2

`'disconnect'` 이벤트는 부모 프로세스에서 [`subprocess.disconnect()`](https://nodejs.org/docs/latest/api/child_process.html#subprocessdisconnect) 메서드를 호출하거나, 자식 프로세스에서 [`process.disconnect()`](https://nodejs.org/docs/latest/api/process.html#processdisconnect) 메서드를 호출한 후에 발생합니다. 연결이 끊긴 후에는 메시지를 보내거나 받을 수 없으며, [`subprocess.connected`](https://nodejs.org/docs/latest/api/child_process.html#subprocessconnected) 속성은 `false`가 됩니다.


#### 이벤트: `'error'`

- `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 에러 객체

`'error'` 이벤트는 다음과 같은 상황에서 발생합니다:

- 프로세스를 생성하지 못했을 때
- 프로세스를 종료하지 못했을 때
- 자식 프로세스로 메시지를 보내는 데 실패했을 때
- `signal` 옵션을 통해 자식 프로세스가 중단되었을 때

에러가 발생한 후 `'exit'` 이벤트가 발생할 수도 있고, 발생하지 않을 수도 있습니다. `'exit'`와 `'error'` 이벤트를 동시에 감지할 때, 핸들러 함수가 여러 번 호출되지 않도록 주의해야 합니다.

참고: [`subprocess.kill()`](https://nodejs.org/docs/latest/api/child_process.html#subprocesskillsignal) 및 [`subprocess.send()`](https://nodejs.org/docs/latest/api/child_process.html#subprocesssendmessage-sendhandle-options-callback)


#### 이벤트: `'exit'`[#](https://nodejs.org/docs/latest/api/child_process.html#event-exit)

추가된 버전: v0.1.90

-   `code` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 자식 프로세스가 스스로 종료된 경우의 종료 코드.
-   `signal` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 자식 프로세스가 종료된 신호.

`'exit'` 이벤트는 자식 프로세스가 종료된 후에 발생합니다. 프로세스가 종료된 경우, `code`는 프로세스의 최종 종료 코드입니다. 그렇지 않으면 `null`입니다. 프로세스가 신호를 받아 종료된 경우, `signal`은 신호의 문자열 이름입니다. 그렇지 않으면 `null`입니다. 둘 중 하나는 항상 `null`이 아닌 값이 됩니다.

`'exit'` 이벤트가 발생할 때, 자식 프로세스의 stdio 스트림은 여전히 열려 있을 수 있습니다.

Node.js는 `SIGINT`와 `SIGTERM`에 대한 신호 핸들러를 설정하며, Node.js 프로세스는 이러한 신호를 받아도 즉시 종료되지 않습니다. 대신, Node.js는 일련의 정리 작업을 수행한 후 처리된 신호를 다시 발생시킵니다.

[`waitpid(2)`](http://man7.org/linux/man-pages/man2/waitpid.2.html)를 참고하세요.


#### 이벤트: `'message'`[#](https://nodejs.org/docs/latest/api/child_process.html#event-message)

추가된 버전: v0.5.9

-   `message` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 파싱된 JSON 객체 또는 기본 값.
-   `sendHandle` [`<Handle>`](https://nodejs.org/docs/latest/api/net.html#serverlistenhandle-backlog-callback) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) `undefined` 또는 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket), [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver), [`dgram.Socket`](https://nodejs.org/docs/latest/api/dgram.html#class-dgramsocket) 객체.

`'message'` 이벤트는 자식 프로세스가 [`process.send()`](https://nodejs.org/docs/latest/api/process.html#processsendmessage-sendhandle-options-callback)를 사용하여 메시지를 보낼 때 발생합니다.

메시지는 직렬화와 파싱 과정을 거칩니다. 결과적으로 받은 메시지는 원래 보낸 메시지와 다를 수 있습니다.

자식 프로세스를 생성할 때 `serialization` 옵션을 `'advanced'`로 설정했다면, `message` 인자는 JSON으로 표현할 수 없는 데이터를 포함할 수 있습니다. 자세한 내용은 [고급 직렬화](https://nodejs.org/docs/latest/api/child_process.html#advanced-serialization)를 참고하세요.


#### 이벤트: `'spawn'`[#](https://nodejs.org/docs/latest/api/child_process.html#event-spawn)

추가된 버전: v15.1.0, v14.17.0

`'spawn'` 이벤트는 자식 프로세스가 성공적으로 생성되었을 때 발생합니다. 만약 자식 프로세스가 성공적으로 생성되지 않으면 `'spawn'` 이벤트는 발생하지 않고 대신 `'error'` 이벤트가 발생합니다.

`'spawn'` 이벤트가 발생하면, 이 이벤트는 다른 모든 이벤트보다 먼저 발생하며, `stdout`이나 `stderr`를 통해 데이터를 받기 전에 발생합니다.

`'spawn'` 이벤트는 생성된 프로세스 **내부**에서 오류가 발생하더라도 여전히 발생합니다. 예를 들어, `bash some-command`가 성공적으로 생성되면 `'spawn'` 이벤트가 발생하지만, `bash`가 `some-command`를 생성하는 데 실패할 수 있습니다. 이 주의사항은 `{ shell: true }`를 사용할 때도 동일하게 적용됩니다.


#### `subprocess.channel`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesschannel)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 자식 프로세스와의 IPC 채널을 나타내는 파이프입니다.

`subprocess.channel` 속성은 자식 프로세스의 IPC 채널을 참조합니다. IPC 채널이 존재하지 않으면 이 속성은 `undefined`입니다.


##### `subprocess.channel.ref()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesschannelref)

추가된 버전: v7.1.0

이 메서드는 이전에 `.unref()`가 호출된 경우에도 IPC 채널이 부모 프로세스의 이벤트 루프를 계속 실행하도록 만듭니다.


##### `subprocess.channel.unref()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesschannelunref)

추가된 버전: v7.1.0

이 메서드는 IPC 채널이 부모 프로세스의 이벤트 루프를 계속 실행하지 않도록 합니다. 채널이 열려 있는 상태에서도 이벤트 루프가 종료될 수 있게 합니다.


#### `subprocess.connected`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessconnected)

추가된 버전: v0.7.2

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `subprocess.disconnect()`가 호출된 후 `false`로 설정됩니다.

`subprocess.connected` 속성은 자식 프로세스와 메시지를 주고받을 수 있는지 여부를 나타냅니다. `subprocess.connected`가 `false`일 경우, 더 이상 메시지를 보내거나 받을 수 없습니다.


#### `subprocess.disconnect()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessdisconnect)

추가된 버전: v0.7.2

부모 프로세스와 자식 프로세스 간의 IPC 채널을 닫아, 자식 프로세스가 더 이상 연결을 유지하지 않고도 정상적으로 종료할 수 있게 합니다. 이 메서드를 호출한 후에는 부모와 자식 프로세스에서 각각 `subprocess.connected`와 `process.connected` 속성이 `false`로 설정되며, 프로세스 간에 메시지를 전달할 수 없게 됩니다.

`'disconnect'` 이벤트는 받고 있는 메시지가 더 이상 없을 때 발생합니다. 이 이벤트는 대부분 `subprocess.disconnect()`를 호출한 직후에 트리거됩니다.

자식 프로세스가 Node.js 인스턴스인 경우(예: [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options)를 사용하여 생성된 경우), 자식 프로세스 내에서 `process.disconnect()` 메서드를 호출하여 IPC 채널을 닫을 수도 있습니다.


#### `subprocess.exitCode`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessexitcode)

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`subprocess.exitCode` 속성은 자식 프로세스의 종료 코드를 나타냅니다. 만약 자식 프로세스가 아직 실행 중이라면, 이 필드는 `null`이 됩니다.


#### `subprocess.kill([signal])`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesskillsignal)

추가된 버전: v0.1.90

-   `signal` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) | [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`subprocess.kill()` 메서드는 자식 프로세스에 시그널을 보냅니다. 인자가 주어지지 않으면 프로세스에 `'SIGTERM'` 시그널이 전송됩니다. 사용 가능한 시그널 목록은 [`signal(7)`](http://man7.org/linux/man-pages/man7/signal.7.html)을 참조하세요. 이 함수는 [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html)이 성공하면 `true`를 반환하고, 그렇지 않으면 `false`를 반환합니다.

```js
import { spawn } from 'node:child_process';

const grep = spawn('grep', ['ssh']);

grep.on('close', (code, signal) => {
    console.log(`자식 프로세스가 시그널 ${signal}을 받아 종료되었습니다.`);
});

// 프로세스에 SIGHUP 시그널을 보냅니다.
grep.kill('SIGHUP');
```

[`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess) 객체는 시그널을 전달할 수 없는 경우 [`'error'`](https://nodejs.org/docs/latest/api/child_process.html#event-error) 이벤트를 발생시킬 수 있습니다. 이미 종료된 자식 프로세스에 시그널을 보내는 것은 에러는 아니지만 예상치 못한 결과를 초래할 수 있습니다. 특히, 프로세스 식별자(PID)가 다른 프로세스에 재할당된 경우, 시그널은 해당 프로세스에 전달되어 예상치 못한 결과를 초래할 수 있습니다.

이 함수는 `kill`이라고 불리지만, 자식 프로세스에 전달된 시그널이 실제로 프로세스를 종료시키지 않을 수도 있습니다.

참고: [`kill(2)`](http://man7.org/linux/man-pages/man2/kill.2.html)

Windows에서는 POSIX 시그널이 존재하지 않기 때문에, `signal` 인자는 `'SIGKILL'`, `'SIGTERM'`, `'SIGINT'`, `'SIGQUIT'`를 제외하고는 무시됩니다. 그리고 프로세스는 항상 강제적으로 즉시 종료됩니다(`'SIGKILL'`과 유사). 자세한 내용은 [Signal Events](https://nodejs.org/docs/latest/api/process.html#signal-events)를 참조하세요.

Linux에서는 자식 프로세스의 자식 프로세스가 부모 프로세스를 종료하려고 할 때 종료되지 않습니다. 이는 쉘에서 새로운 프로세스를 실행하거나 `ChildProcess`의 `shell` 옵션을 사용할 때 발생할 가능성이 높습니다.

```js
import { spawn } from 'node:child_process';

const subprocess = spawn(
    'sh',
    [
        '-c',
        `node -e "setInterval(() => { console.log(process.pid, 'is alive') }, 500);"`,
    ],
    {
        stdio: ['inherit', 'inherit', 'inherit'],
    }
);

setTimeout(() => {
    subprocess.kill(); // 쉘 내의 Node.js 프로세스를 종료하지 않습니다.
}, 2000);
```


#### `subprocess[Symbol.dispose]()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesssymboldispose)

추가된 버전: v20.5.0, v18.18.0

이 메서드는 `'SIGTERM'` 신호와 함께 [`subprocess.kill()`](https://nodejs.org/docs/latest/api/child_process.html#subprocesskillsignal)을 호출합니다.


#### `subprocess.killed`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesskilled)

추가된 버전: v0.5.10

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `subprocess.kill()`을 사용하여 자식 프로세스에 신호를 성공적으로 보낸 후 `true`로 설정됩니다.

`subprocess.killed` 프로퍼티는 자식 프로세스가 `subprocess.kill()`로부터 신호를 성공적으로 받았는지 여부를 나타냅니다. `killed` 프로퍼티는 자식 프로세스가 종료되었음을 의미하지 않습니다.


#### `subprocess.pid`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesspid)

추가된 버전: v0.1.90

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

자식 프로세스의 프로세스 식별자(PID)를 반환합니다. 만약 자식 프로세스가 오류로 인해 생성되지 못했다면, 값은 `undefined`가 되고 `error` 이벤트가 발생합니다.

```js
import { spawn } from 'node:child_process';

const grep = spawn('grep', ['ssh']);
console.log(`Spawned child pid: ${grep.pid}`);
grep.stdin.end();
```


#### `subprocess.ref()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessref)

추가된 버전: v0.7.10

`subprocess.unref()`를 호출한 후 `subprocess.ref()`를 호출하면, 제거되었던 자식 프로세스의 참조 카운트가 복원됩니다. 이로 인해 부모 프로세스는 자식 프로세스가 종료될 때까지 기다린 후에야 종료됩니다.

```js
import { spawn } from 'node:child_process';
import process from 'node:process';

const subprocess = spawn(process.argv[0], ['child_program.js'], {
    detached: true,
    stdio: 'ignore',
});

subprocess.unref();
subprocess.ref();
```


#### `subprocess.send(message[, sendHandle[, options]][, callback])`

-   `message` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   `sendHandle` [`<Handle>`](https://nodejs.org/docs/latest/api/net.html#serverlistenhandle-backlog-callback) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type) `undefined`, 또는 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket), [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver), 또는 [`dgram.Socket`](https://nodejs.org/docs/latest/api/dgram.html#class-dgramsocket) 객체.
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `options` 인자는 특정 타입의 핸들을 전송할 때 사용되는 객체입니다. `options`는 다음 속성을 지원합니다:
    -   `keepOpen` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `net.Socket` 인스턴스를 전달할 때 사용할 수 있는 값입니다. `true`로 설정하면 소켓이 전송 프로세스에서 열린 상태로 유지됩니다. **기본값:** `false`.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

부모 프로세스와 자식 프로세스 간에 IPC 채널이 설정된 경우(예: [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options) 사용 시), `subprocess.send()` 메서드를 사용해 자식 프로세스로 메시지를 보낼 수 있습니다. 자식 프로세스가 Node.js 인스턴스인 경우, 이러한 메시지는 [`'message'`](https://nodejs.org/docs/latest/api/process.html#event-message) 이벤트를 통해 받을 수 있습니다.

메시지는 직렬화와 파싱을 거칩니다. 결과적으로 받은 메시지는 원래 보낸 메시지와 다를 수 있습니다.

예를 들어, 부모 스크립트에서 다음과 같이 작성할 수 있습니다:

```js
import { fork } from 'node:child_process';
const forkedProcess = fork(`${import.meta.dirname}/sub.js`);

forkedProcess.on('message', (message) => {
    console.log('PARENT got message:', message);
});

// 자식 프로세스에서 출력: CHILD got message: { hello: 'world' }
forkedProcess.send({ hello: 'world' });
```

그리고 자식 스크립트 `'sub.js'`는 다음과 같이 작성할 수 있습니다:

```js
process.on('message', (message) => {
    console.log('CHILD got message:', message);
});

// 부모 프로세스에서 출력: PARENT got message: { foo: 'bar', baz: null }
process.send({ foo: 'bar', baz: NaN });
```

자식 Node.js 프로세스는 부모 프로세스로 메시지를 보낼 수 있는 [`process.send()`](https://nodejs.org/docs/latest/api/process.html#processsendmessage-sendhandle-options-callback) 메서드를 가지고 있습니다.

`{cmd: 'NODE_foo'}`와 같은 메시지를 보내는 특별한 경우가 있습니다. `cmd` 속성에 `NODE_` 접두사가 포함된 메시지는 Node.js 코어 내부에서 사용되며, 자식 프로세스의 [`'message'`](https://nodejs.org/docs/latest/api/process.html#event-message) 이벤트로 발행되지 않습니다. 대신, 이러한 메시지는 `'internalMessage'` 이벤트로 발행되며 Node.js 내부에서 소비됩니다. 애플리케이션은 이러한 메시지를 사용하거나 `'internalMessage'` 이벤트를 수신하지 않아야 합니다. 이는 예고 없이 변경될 수 있습니다.

`subprocess.send()`에 전달할 수 있는 선택적 `sendHandle` 인자는 TCP 서버나 소켓 객체를 자식 프로세스로 전달하기 위해 사용됩니다. 자식 프로세스는 [`'message'`](https://nodejs.org/docs/latest/api/process.html#event-message) 이벤트에 등록된 콜백 함수의 두 번째 인자로 이 객체를 받습니다. 소켓에서 받고 버퍼링된 데이터는 자식 프로세스로 전송되지 않습니다. Windows에서는 IPC 소켓 전송이 지원되지 않습니다.

선택적 `callback`은 메시지가 전송된 후 자식 프로세스가 메시지를 받기 전에 호출되는 함수입니다. 이 함수는 성공 시 `null`, 실패 시 [`Error`](https://nodejs.org/docs/latest/api/errors.html#class-error) 객체를 인자로 받습니다.

`callback` 함수가 제공되지 않고 메시지를 보낼 수 없는 경우, [`ChildProcess`](https://nodejs.org/docs/latest/api/child_process.html#class-childprocess) 객체에서 `'error'` 이벤트가 발생합니다. 이는 예를 들어 자식 프로세스가 이미 종료된 경우에 발생할 수 있습니다.

`subprocess.send()`는 채널이 닫혔거나 전송되지 않은 메시지의 백로그가 임계값을 초과해 더 이상 메시지를 보내는 것이 바람직하지 않은 경우 `false`를 반환합니다. 그렇지 않으면 `true`를 반환합니다. `callback` 함수를 사용해 흐름 제어를 구현할 수 있습니다.


##### 예제: 서버 객체 전송하기

`sendHandle` 인자를 사용하면 TCP 서버 객체의 핸들을 자식 프로세스로 전달할 수 있습니다. 아래 예제를 참고하세요:

```js
import { fork } from 'node:child_process';
import { createServer } from 'node:net';

// 자식 프로세스 생성
const subprocess = fork('subprocess.js');

// 서버 객체 생성 및 핸들 전송
const server = createServer();
server.on('connection', (socket) => {
  socket.end('부모 프로세스에서 처리됨');
});
server.listen(1337, () => {
  subprocess.send('server', server);
});
```

자식 프로세스는 다음과 같이 서버 객체를 받습니다:

```js
process.on('message', (m, server) => {
  if (m === 'server') {
    server.on('connection', (socket) => {
      socket.end('자식 프로세스에서 처리됨');
    });
  }
});
```

이제 서버는 부모와 자식 프로세스 간에 공유됩니다. 일부 연결은 부모 프로세스에서 처리되고, 나머지는 자식 프로세스에서 처리됩니다.

위 예제는 `node:net` 모듈로 생성한 서버를 사용하지만, `node:dgram` 모듈의 서버도 동일한 방식으로 동작합니다. 단, `'connection'` 이벤트 대신 `'message'` 이벤트를 사용하고, `server.listen()` 대신 `server.bind()`를 사용합니다. 이 기능은 Unix 플랫폼에서만 지원됩니다.


##### 예제: 소켓 객체 전송하기

마찬가지로, `sendHandler` 인자를 사용해 소켓의 핸들을 자식 프로세스로 전달할 수 있습니다. 아래 예제는 각각 "일반" 또는 "특별" 우선순위로 연결을 처리하는 두 개의 자식 프로세스를 생성합니다:

```js
import { fork } from 'node:child_process';
import { createServer } from 'node:net';

const normal = fork('subprocess.js', ['normal']);
const special = fork('subprocess.js', ['special']);

// 서버를 열고 소켓을 자식 프로세스로 전송합니다.
// 소켓이 자식 프로세스로 전송되기 전에 읽히는 것을 방지하기 위해 pauseOnConnect를 사용합니다.
const server = createServer({ pauseOnConnect: true });

server.on('connection', (socket) => {
    // 특별 우선순위인 경우...
    if (socket.remoteAddress === '74.125.127.100') {
        special.send('socket', socket);
        return;
    }
    // 일반 우선순위인 경우.
    normal.send('socket', socket);
});

server.listen(1337);
```

`subprocess.js`는 이벤트 콜백 함수에 전달된 두 번째 인자로 소켓 핸들을 받습니다:

```js
process.on('message', (m, socket) => {
    if (m === 'socket') {
        if (socket) {
            // 클라이언트 소켓이 존재하는지 확인합니다.
            // 소켓이 전송된 후 자식 프로세스에서 받기 전에 닫힐 가능성이 있습니다.
            socket.end(`Request handled with ${process.argv[2]} priority`);
        }
    }
});
```

자식 프로세스로 전달된 소켓에는 `.maxConnections`를 사용하지 마세요. 부모 프로세스는 소켓이 언제 파괴되는지 추적할 수 없습니다.

자식 프로세스의 모든 `'message'` 핸들러는 `socket`이 존재하는지 확인해야 합니다. 연결이 자식 프로세스로 전송되는 동안 닫힐 수 있기 때문입니다.


#### `subprocess.signalCode`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocesssignalcode)

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type)

`subprocess.signalCode` 속성은 자식 프로세스가 받은 시그널을 나타냅니다. 시그널이 없다면 `null`이 됩니다.


#### `subprocess.spawnargs`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessspawnargs)

-   [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

`subprocess.spawnargs` 속성은 자식 프로세스가 실행될 때 사용된 전체 커맨드라인 인자 목록을 나타냅니다.


#### `subprocess.spawnfile`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessspawnfile)

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`subprocess.spawnfile` 속성은 실행된 자식 프로세스의 실행 파일 이름을 나타냅니다.

[`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options)를 사용할 경우, 이 값은 [`process.execPath`](https://nodejs.org/docs/latest/api/process.html#processexecpath)와 동일합니다. [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)를 사용할 경우, 이 값은 실행 파일의 이름이 됩니다. [`child_process.exec()`](https://nodejs.org/docs/latest/api/child_process.html#child_processexeccommand-options-callback)를 사용할 경우, 이 값은 자식 프로세스가 실행된 셸의 이름이 됩니다.


#### `subprocess.stderr`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessstderr)

추가된 버전: v0.1.90

-   [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

`subprocess.stderr`는 자식 프로세스의 `stderr`를 나타내는 `Readable Stream`입니다.

자식 프로세스가 `stdio[2]`를 `'pipe'` 이외의 값으로 설정하여 생성된 경우, 이 값은 `null`이 됩니다.

`subprocess.stderr`는 `subprocess.stdio[2]`의 별칭입니다. 두 속성은 동일한 값을 참조합니다.

자식 프로세스가 성공적으로 생성되지 못한 경우, `subprocess.stderr` 속성은 `null` 또는 `undefined`가 될 수 있습니다.


#### `subprocess.stdin`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdin)

추가된 버전: v0.1.90

-   [`<stream.Writable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamwritable) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

`subprocess.stdin`은 자식 프로세스의 `stdin`을 나타내는 `Writable Stream`입니다.

자식 프로세스가 모든 입력을 읽기 위해 대기 중이라면, 이 스트림이 `end()`를 통해 닫힐 때까지 자식 프로세스는 계속 진행되지 않습니다.

자식 프로세스가 `stdio[0]`을 `'pipe'` 이외의 값으로 설정하여 생성되었다면, 이 값은 `null`이 됩니다.

`subprocess.stdin`은 `subprocess.stdio[0]`의 별칭입니다. 두 속성은 동일한 값을 참조합니다.

자식 프로세스가 성공적으로 생성되지 못한 경우, `subprocess.stdin` 속성은 `null` 또는 `undefined`가 될 수 있습니다.


#### `subprocess.stdio`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdio)

추가된 버전: v0.7.10

-   [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

`subprocess.stdio`는 자식 프로세스와 연결된 파이프의 희소 배열입니다. 이 배열은 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options)에 전달된 [`stdio`](https://nodejs.org/docs/latest/api/child_process.html#optionsstdio) 옵션에서 `'pipe'`로 설정된 위치와 대응됩니다. `subprocess.stdio[0]`, `subprocess.stdio[1]`, `subprocess.stdio[2]`는 각각 `subprocess.stdin`, `subprocess.stdout`, `subprocess.stderr`로도 사용할 수 있습니다.

다음 예제에서는 자식 프로세스의 파일 디스크립터 `1`(stdout)만 파이프로 설정되었기 때문에, 부모 프로세스의 `subprocess.stdio[1]`만 스트림입니다. 배열의 다른 값들은 모두 `null`입니다.

```js
import assert from 'node:assert';
import fs from 'node:fs';
import child_process from 'node:child_process';

const subprocess = child_process.spawn('ls', {
  stdio: [
    0, // 자식 프로세스의 stdin을 부모 프로세스의 stdin으로 사용
    'pipe', // 자식 프로세스의 stdout을 부모 프로세스로 파이프
    fs.openSync('err.out', 'w'), // 자식 프로세스의 stderr을 파일로 리다이렉트
  ],
});

assert.strictEqual(subprocess.stdio[0], null);
assert.strictEqual(subprocess.stdio[0], subprocess.stdin);
assert(subprocess.stdout);
assert.strictEqual(subprocess.stdio[1], subprocess.stdout);
assert.strictEqual(subprocess.stdio[2], null);
assert.strictEqual(subprocess.stdio[2], subprocess.stderr);
```

자식 프로세스를 성공적으로 생성하지 못한 경우, `subprocess.stdio` 속성은 `undefined`가 될 수 있습니다.


#### `subprocess.stdout`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessstdout)

추가된 버전: v0.1.90

-   [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

`subprocess.stdout`은 자식 프로세스의 `stdout`을 나타내는 `Readable Stream`입니다.

자식 프로세스가 `stdio[1]`을 `'pipe'` 이외의 값으로 설정하여 생성된 경우, 이 값은 `null`이 됩니다.

`subprocess.stdout`은 `subprocess.stdio[1]`의 별칭입니다. 두 속성은 동일한 값을 참조합니다.

```js
import { spawn } from 'node:child_process';
const subprocess = spawn('ls');
subprocess.stdout.on('data', (data) => {
    console.log(`Received chunk ${data}`);
});
```

자식 프로세스가 성공적으로 생성되지 못한 경우, `subprocess.stdout` 속성은 `null` 또는 `undefined`가 될 수 있습니다.


#### `subprocess.unref()`[#](https://nodejs.org/docs/latest/api/child_process.html#subprocessunref)

추가된 버전: v0.7.10

기본적으로, 부모 프로세스는 분리된 자식 프로세스가 종료될 때까지 기다립니다. 부모 프로세스가 특정 `subprocess`가 종료될 때까지 기다리지 않도록 하려면 `subprocess.unref()` 메서드를 사용하세요. 이렇게 하면 부모의 이벤트 루프가 자식 프로세스를 참조 카운트에 포함하지 않게 되어, 자식과 부모 프로세스 간에 IPC 채널이 설정되지 않은 경우 부모가 자식과 독립적으로 종료될 수 있습니다.

```js
import { spawn } from 'node:child_process';
import process from 'node:process';

const subprocess = spawn(process.argv[0], ['child_program.js'], {
    detached: true,
    stdio: 'ignore',
});

subprocess.unref();
```


### `maxBuffer`와 유니코드

`maxBuffer` 옵션은 `stdout`이나 `stderr`에 허용되는 최대 바이트 수를 지정합니다. 이 값을 초과하면 자식 프로세스가 종료됩니다. 이는 UTF-8이나 UTF-16과 같은 멀티바이트 문자 인코딩을 포함하는 출력에 영향을 미칩니다. 예를 들어, `console.log('中文测试')`는 4개의 문자만 있지만, `stdout`에 13바이트의 UTF-8 인코딩된 데이터를 전송합니다.

```javascript
console.log('中文测试'); // 4개의 문자, 13바이트의 UTF-8 데이터
```


### 쉘 요구사항

쉘은 `-c` 스위치를 이해해야 합니다. 만약 쉘이 `'cmd.exe'`라면, `/d /s /c` 스위치를 이해해야 하며 커맨드라인 파싱이 호환되어야 합니다.


### 기본 윈도우 셸[#](https://nodejs.org/docs/latest/api/child_process.html#default-windows-shell)

마이크로소프트는 루트 환경에서 `%COMSPEC%`이 `'cmd.exe'`의 경로를 포함해야 한다고 명시하지만, 자식 프로세스는 항상 이 요구사항을 따르지 않습니다. 따라서 셸을 생성할 수 있는 `child_process` 함수에서 `process.env.ComSpec`이 사용 불가능한 경우, `'cmd.exe'`가 대체 옵션으로 사용됩니다.


### 고급 직렬화[#](https://nodejs.org/docs/latest/api/child_process.html#advanced-serialization)

추가된 버전: v13.2.0, v12.16.0

자식 프로세스는 IPC를 위한 직렬화 메커니즘을 지원합니다. 이 메커니즘은 [`node:v8` 모듈의 직렬화 API](https://nodejs.org/docs/latest/api/v8.html#serialization-api)를 기반으로 하며, [HTML 구조화 복제 알고리즘](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm)에 기반합니다. 이 방식은 일반적으로 더 강력하며, `BigInt`, `Map`, `Set`, `ArrayBuffer`, `TypedArray`, `Buffer`, `Error`, `RegExp` 등과 같은 내장 자바스크립트 객체 타입을 지원합니다.

하지만 이 형식은 JSON의 완전한 상위 집합이 아니며, 예를 들어 이러한 내장 타입 객체에 설정된 속성은 직렬화 단계를 통해 전달되지 않습니다. 또한 전달된 데이터의 구조에 따라 JSON과 동등한 성능을 보장하지 않을 수 있습니다. 따라서 이 기능을 사용하려면 [`child_process.spawn()`](https://nodejs.org/docs/latest/api/child_process.html#child_processspawncommand-args-options) 또는 [`child_process.fork()`](https://nodejs.org/docs/latest/api/child_process.html#child_processforkmodulepath-args-options)를 호출할 때 `serialization` 옵션을 `'advanced'`로 설정해야 합니다.


