# Table of Contents

- [TLS (SSL)](#tls-ssl)
    - [암호화 지원이 불가능한지 확인하기](#암호화-지원이-불가능한지-확인하기)
    - [TLS/SSL 개념](#tlsssl-개념)
      - [완전 순방향 비밀성(Perfect Forward Secrecy)](#완전-순방향-비밀성perfect-forward-secrecy)
      - [ALPN과 SNI](#alpn과-sni)
      - [사전 공유 키(Pre-shared keys, PSK)](#사전-공유-키pre-shared-keys-psk)
      - [클라이언트가 시작하는 재협상 공격 방지](#클라이언트가-시작하는-재협상-공격-방지)
      - [세션 재개(Session Resumption)](#세션-재개session-resumption)
        - [세션 식별자](#세션-식별자)
        - [세션 티켓](#세션-티켓)
    - [기본 TLS 암호화 스위트 수정하기](#기본-tls-암호화-스위트-수정하기)
    - [OpenSSL 보안 레벨](#openssl-보안-레벨)
      - [보안 수준 설정하기](#보안-수준-설정하기)
      - [`--tls-cipher-list` 사용하기](#--tls-cipher-list-사용하기)
    - [X509 인증서 오류 코드](#x509-인증서-오류-코드)
    - [클래스: `tls.CryptoStream`](#클래스-tlscryptostream)
      - [`cryptoStream.bytesWritten`](#cryptostreambyteswritten)
    - [클래스: `tls.SecurePair`](#클래스-tlssecurepair)
      - [이벤트: `'secure'`](#이벤트-secure)
    - [클래스: `tls.Server`](#클래스-tlsserver)
      - [이벤트: `'connection'`](#이벤트-connection)
      - [이벤트: `'keylog'`](#이벤트-keylog)
      - [이벤트: `'newSession'`](#이벤트-newsession)
      - [이벤트: `'OCSPRequest'`](#이벤트-ocsprequest)
      - [이벤트: `'resumeSession'`](#이벤트-resumesession)
      - [이벤트: `'secureConnection'`](#이벤트-secureconnection)
      - [이벤트: `'tlsClientError'`](#이벤트-tlsclienterror)
      - [`server.addContext(hostname, context)`](#serveraddcontexthostname-context)
      - [`server.address()`](#serveraddress)
      - [`server.close([callback])`](#serverclosecallback)
      - [`server.getTicketKeys()`](#servergetticketkeys)
      - [`server.listen()`](#serverlisten)
      - [`server.setSecureContext(options)`](#serversetsecurecontextoptions)
      - [`server.setTicketKeys(keys)`](#serversetticketkeyskeys)
    - [클래스: `tls.TLSSocket`](#클래스-tlstlssocket)
      - [`new tls.TLSSocket(socket[, options])`](#new-tlstlssocketsocket-options)
      - [이벤트: `'keylog'`](#이벤트-keylog)
      - [이벤트: `'OCSPResponse'`](#이벤트-ocspresponse)
      - [이벤트: `'secureConnect'`](#이벤트-secureconnect)
      - [이벤트: `'session'`](#이벤트-session)
      - [`tlsSocket.address()`](#tlssocketaddress)
      - [`tlsSocket.authorizationError`](#tlssocketauthorizationerror)
      - [`tlsSocket.authorized`](#tlssocketauthorized)
      - [`tlsSocket.disableRenegotiation()`](#tlssocketdisablerenegotiation)
      - [`tlsSocket.enableTrace()`](#tlssocketenabletrace)
      - [`tlsSocket.encrypted`](#tlssocketencrypted)
      - [`tlsSocket.exportKeyingMaterial(length, label[, context])`](#tlssocketexportkeyingmateriallength-label-context)
      - [`tlsSocket.getCertificate()`](#tlssocketgetcertificate)
      - [`tlsSocket.getCipher()`](#tlssocketgetcipher)
      - [`tlsSocket.getEphemeralKeyInfo()`](#tlssocketgetephemeralkeyinfo)
      - [`tlsSocket.getFinished()`](#tlssocketgetfinished)
      - [`tlsSocket.getPeerCertificate([detailed])`](#tlssocketgetpeercertificatedetailed)
        - [Certificate 객체](#certificate-객체)
      - [`tlsSocket.getPeerFinished()`](#tlssocketgetpeerfinished)
      - [`tlsSocket.getPeerX509Certificate()`](#tlssocketgetpeerx509certificate)
      - [`tlsSocket.getProtocol()`](#tlssocketgetprotocol)
      - [`tlsSocket.getSession()`](#tlssocketgetsession)
      - [`tlsSocket.getSharedSigalgs()`](#tlssocketgetsharedsigalgs)
      - [`tlsSocket.getTLSTicket()`](#tlssocketgettlsticket)
      - [`tlsSocket.getX509Certificate()`](#tlssocketgetx509certificate)
      - [`tlsSocket.isSessionReused()`](#tlssocketissessionreused)
      - [`tlsSocket.localAddress`](#tlssocketlocaladdress)
      - [`tlsSocket.localPort`](#tlssocketlocalport)
      - [`tlsSocket.remoteAddress`](#tlssocketremoteaddress)
      - [`tlsSocket.remoteFamily`](#tlssocketremotefamily)
      - [`tlsSocket.remotePort`](#tlssocketremoteport)
      - [`tlsSocket.renegotiate(options, callback)`](#tlssocketrenegotiateoptions-callback)
      - [`tlsSocket.setKeyCert(context)`](#tlssocketsetkeycertcontext)
      - [`tlsSocket.setMaxSendFragment(size)`](#tlssocketsetmaxsendfragmentsize)
    - [`tls.checkServerIdentity(hostname, cert)`](#tlscheckserveridentityhostname-cert)
    - [`tls.connect(options[, callback])`](#tlsconnectoptions-callback)
    - [`tls.connect(path[, options][, callback])`](#tlsconnectpath-options-callback)
    - [`tls.connect(port[, host][, options][, callback])`](#tlsconnectport-host-options-callback)
    - [`tls.createSecureContext([options])`](#tlscreatesecurecontextoptions)
    - [`tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])`](#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options)
    - [`tls.createServer([options][, secureConnectionListener])`](#tlscreateserveroptions-secureconnectionlistener)
    - [`tls.getCiphers()`](#tlsgetciphers)
    - [`tls.rootCertificates`](#tlsrootcertificates)
    - [`tls.DEFAULT_ECDH_CURVE`](#tlsdefault_ecdh_curve)
    - [`tls.DEFAULT_MAX_VERSION`](#tlsdefault_max_version)
    - [`tls.DEFAULT_MIN_VERSION`](#tlsdefault_min_version)
    - [`tls.DEFAULT_CIPHERS`](#tlsdefault_ciphers)

# TLS (SSL)

**소스 코드:** [lib/tls.js](https://github.com/nodejs/node/blob/v23.5.0/lib/tls.js)

`node:tls` 모듈은 OpenSSL을 기반으로 구현된 Transport Layer Security(TLS)와 Secure Socket Layer(SSL) 프로토콜을 제공합니다. 이 모듈은 다음과 같이 사용할 수 있습니다:

```js
import tls from 'node:tls';
```


### 암호화 지원이 불가능한지 확인하기

Node.js는 `node:crypto` 모듈 지원 없이 빌드될 수 있습니다. 이 경우 `tls` 모듈을 `import`하거나 `require('node:tls')`를 호출하면 오류가 발생합니다.

CommonJS를 사용할 때는 try/catch를 통해 오류를 잡을 수 있습니다:

```js
let tls;
try {
    tls = require('node:tls');
} catch (err) {
    console.error('tls 지원이 비활성화되었습니다!');
}
```

ESM의 `import` 키워드를 사용할 때는 모듈을 로드하기 전에 `process.on('uncaughtException')` 핸들러를 등록해야 오류를 잡을 수 있습니다. 예를 들어, preload 모듈을 사용할 수 있습니다.

ESM을 사용하면서 암호화 지원이 비활성화된 Node.js 빌드에서 코드가 실행될 가능성이 있다면, `import` 키워드 대신 [`import()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) 함수를 사용하는 것을 고려해 보세요:

```js
let tls;
try {
    tls = await import('node:tls');
} catch (err) {
    console.error('tls 지원이 비활성화되었습니다!');
}
```


### TLS/SSL 개념

TLS/SSL은 클라이언트와 서버 간의 안전한 통신을 가능하게 하는 프로토콜 집합입니다. 이 프로토콜은 공개 키 기반 구조(PKI)에 의존합니다. 일반적으로 각 서버는 개인 키(private key)를 가지고 있어야 합니다.

개인 키는 여러 방법으로 생성할 수 있습니다. 아래 예제는 OpenSSL 커맨드라인 인터페이스를 사용해 2048비트 RSA 개인 키를 생성하는 방법을 보여줍니다.

```bash
openssl genrsa -out ryans-key.pem 2048
```

TLS/SSL을 사용하려면 모든 서버(그리고 일부 클라이언트)는 **인증서**를 가지고 있어야 합니다. 인증서는 개인 키에 대응하는 **공개 키**이며, 인증 기관(Certificate Authority)이나 개인 키 소유자에 의해 디지털 서명이 되어 있습니다(이러한 인증서는 "자체 서명"이라고 불립니다). 인증서를 얻기 위한 첫 번째 단계는 **인증서 서명 요청**(CSR, Certificate Signing Request) 파일을 만드는 것입니다.

OpenSSL 커맨드라인 인터페이스를 사용해 개인 키에 대한 CSR을 생성할 수 있습니다.

```bash
openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem
```

CSR 파일이 생성되면, 이를 인증 기관에 서명을 요청하거나 자체 서명된 인증서를 생성하는 데 사용할 수 있습니다.

아래 예제는 OpenSSL 커맨드라인 인터페이스를 사용해 자체 서명된 인증서를 생성하는 방법을 보여줍니다.

```bash
openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem
```

인증서가 생성되면, 이를 사용해 `.pfx` 또는 `.p12` 파일을 생성할 수 있습니다.

```bash
openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \ -certfile ca-cert.pem -out ryans.pfx
```

여기서 각 옵션은 다음과 같습니다.

- `in`: 서명된 인증서
- `inkey`: 연결된 개인 키
- `certfile`: 모든 인증 기관(CA) 인증서를 하나의 파일로 합친 파일 (예: `cat ca1-cert.pem ca2-cert.pem > ca-cert.pem`)


#### 완전 순방향 비밀성(Perfect Forward Secrecy)

*[순방향 비밀성](https://en.wikipedia.org/wiki/Perfect_forward_secrecy)* 또는 *완전 순방향 비밀성*은 키 교환 방법의 기능을 설명하는 용어입니다. 이는 서버와 클라이언트의 키를 사용하여 현재 통신 세션에만 사용되는 임시 키를 협상하는 것을 의미합니다. 실제로, 이는 서버의 개인 키가 유출되더라도 공격자가 해당 세션에 대해 특별히 생성된 키 쌍을 획득하지 않는 한 통신을 해독할 수 없음을 의미합니다.

완전 순방향 비밀성은 모든 TLS/SSL 핸드셰이크마다 키 교환을 위해 임의의 키 쌍을 생성함으로써 달성됩니다(모든 세션에 동일한 키를 사용하는 것과 대조적). 이 기술을 구현하는 방법을 "임시(ephemeral)"라고 부릅니다.

현재 완전 순방향 비밀성을 달성하기 위해 일반적으로 두 가지 방법이 사용됩니다(전통적인 약어에 "E"가 추가된 것을 주목하세요):

-   [ECDHE](https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman): 타원 곡선 디피-헬만(Elliptic Curve Diffie-Hellman) 키 교환 프로토콜의 임시 버전.
-   [DHE](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange): 디피-헬만(Diffie-Hellman) 키 교환 프로토콜의 임시 버전.

ECDHE를 사용한 완전 순방향 비밀성은 기본적으로 활성화되어 있습니다. TLS 서버를 생성할 때 `ecdhCurve` 옵션을 사용하여 지원되는 ECDH 곡선 목록을 커스터마이즈할 수 있습니다. 자세한 내용은 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)를 참조하세요.

DHE는 기본적으로 비활성화되어 있지만, `dhparam` 옵션을 `'auto'`로 설정하여 ECDHE와 함께 활성화할 수 있습니다. 커스텀 DHE 파라미터도 지원되지만, 자동으로 선택된 잘 알려진 파라미터를 사용하는 것이 권장됩니다.

완전 순방향 비밀성은 TLSv1.2까지 선택 사항이었습니다. TLSv1.3부터는 (EC)DHE가 항상 사용됩니다(PSK-only 연결은 제외).


#### ALPN과 SNI

ALPN(Application-Layer Protocol Negotiation Extension)과 SNI(Server Name Indication)는 TLS 핸드셰이크 확장 기능입니다.

- **ALPN**: 하나의 TLS 서버에서 여러 프로토콜(HTTP, HTTP/2 등)을 사용할 수 있게 해줍니다.
- **SNI**: 하나의 TLS 서버에서 여러 호스트명에 대해 각각 다른 인증서를 사용할 수 있도록 지원합니다.


#### 사전 공유 키(Pre-shared keys, PSK)

TLS-PSK는 일반적인 인증서 기반 인증의 대안으로 사용할 수 있습니다. 이 방식은 인증서 대신 사전 공유 키를 사용하여 TLS 연결을 인증하며, 상호 인증을 제공합니다. TLS-PSK와 공개 키 기반 구조(PKI)는 상호 배타적이지 않습니다. 클라이언트와 서버는 둘 다 지원할 수 있으며, 일반적인 암호화 협상 단계에서 둘 중 하나를 선택할 수 있습니다.

TLS-PSK는 모든 연결 기계와 안전하게 키를 공유할 수 있는 수단이 있는 경우에만 적합한 선택입니다. 따라서 대부분의 TLS 사용 사례에서 PKI를 대체하지 않습니다. OpenSSL의 TLS-PSK 구현은 최근 몇 년 동안 많은 보안 결함이 발견되었는데, 이는 주로 소수 애플리케이션에서만 사용되기 때문입니다. PSK 암호화로 전환하기 전에 모든 대안을 고려해야 합니다. PSK를 생성할 때는 [RFC 4086](https://tools.ietf.org/html/rfc4086)에서 논의된 것처럼 충분한 엔트로피를 사용하는 것이 매우 중요합니다. 비밀번호나 낮은 엔트로피 소스에서 공유 비밀을 도출하는 것은 안전하지 않습니다.

PSK 암호화는 기본적으로 비활성화되어 있으며, TLS-PSK를 사용하려면 `ciphers` 옵션으로 암호화 스위트를 명시적으로 지정해야 합니다. 사용 가능한 암호화 스위트 목록은 `openssl ciphers -v 'PSK'` 명령으로 확인할 수 있습니다. 모든 TLS 1.3 암호화 스위트는 PSK에 적합하며, `openssl ciphers -v -s -tls1_3 -psk` 명령으로 확인할 수 있습니다. 클라이언트 연결에서는 인증서가 없을 경우 기본 `checkServerIdentity`가 실패하므로 커스텀 `checkServerIdentity`를 전달해야 합니다.

[RFC 4279](https://tools.ietf.org/html/rfc4279)에 따르면, 최대 128바이트 길이의 PSK 식별자와 최대 64바이트 길이의 PSK를 지원해야 합니다. OpenSSL 1.1.0 기준으로 최대 식별자 크기는 128바이트이고, 최대 PSK 길이는 256바이트입니다.

현재 구현은 기본 OpenSSL API의 제한으로 인해 비동기 PSK 콜백을 지원하지 않습니다.

TLS-PSK를 사용하려면 클라이언트와 서버 모두 `pskCallback` 옵션을 지정해야 합니다. 이 함수는 사용할 PSK를 반환하며, 선택한 암호화 스위트의 다이제스트와 호환되어야 합니다.

이 콜백은 먼저 클라이언트에서 호출됩니다:

-   hint: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 서버에서 클라이언트로 보내는 선택적 메시지로, 협상 중 사용할 식별자를 결정하는 데 도움을 줍니다. TLS 1.3을 사용할 경우 항상 `null`입니다.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) `{ psk: <Buffer|TypedArray|DataView>, identity: <string> }` 형태 또는 `null`.

그 다음 서버에서 호출됩니다:

-   socket: [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 서버 소켓 인스턴스로, `this`와 동일합니다.
-   identity: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 클라이언트에서 보낸 식별자 매개변수.
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView) PSK (또는 `null`).

`null`을 반환하면 협상 프로세스가 중단되고 상대방에게 `unknown_psk_identity` 경고 메시지를 보냅니다. 서버가 PSK 식별자를 알지 못했다는 사실을 숨기려면, 콜백이 협상이 끝나기 전에 `decrypt_error`로 연결을 실패시키기 위해 `psk`로 일부 랜덤 데이터를 제공해야 합니다.


#### 클라이언트가 시작하는 재협상 공격 방지

TLS 프로토콜은 클라이언트가 TLS 세션의 특정 부분을 재협상할 수 있도록 허용합니다. 하지만 세션 재협상은 서버 측 리소스를 과도하게 소모할 수 있어, 서비스 거부(DoS) 공격의 잠재적 경로가 될 수 있습니다.

이러한 위험을 줄이기 위해, 재협상은 10분 동안 최대 3번으로 제한됩니다. 이 한도를 초과하면 [`tls.TLSSocket`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 인스턴스에서 `'error'` 이벤트가 발생합니다. 이 제한은 다음과 같이 설정할 수 있습니다:

-   `tls.CLIENT_RENEG_LIMIT` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 재협상 요청 횟수를 지정합니다. **기본값:** `3`.
-   `tls.CLIENT_RENEG_WINDOW` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 재협상 시간 창을 초 단위로 지정합니다. **기본값:** `600` (10분).

기본 재협상 제한은 관련 영향과 위험을 완전히 이해하지 않고서는 수정하지 않는 것이 좋습니다.

TLSv1.3은 재협상을 지원하지 않습니다.


#### 세션 재개(Session Resumption)

TLS 세션을 설정하는 것은 상대적으로 느릴 수 있습니다. 이 과정은 세션 상태를 저장하고 나중에 재사용함으로써 속도를 높일 수 있습니다. 이를 위한 여러 메커니즘이 있으며, 여기서는 가장 오래된 것부터 최신(그리고 선호되는) 순서로 설명합니다.


##### 세션 식별자

서버는 새로운 연결에 대해 고유한 ID를 생성하고 이를 클라이언트에게 전송합니다. 클라이언트와 서버는 세션 상태를 저장합니다. 재연결 시, 클라이언트는 저장된 세션 상태의 ID를 전송하며, 서버도 해당 ID에 대한 상태를 가지고 있다면 이를 사용할 수 있습니다. 그렇지 않으면 서버는 새로운 세션을 생성합니다. 자세한 내용은 [RFC 2246](https://www.ietf.org/rfc/rfc2246.txt)의 23페이지와 30페이지를 참고하세요.

세션 식별자를 사용한 재개는 대부분의 웹 브라우저에서 HTTPS 요청 시 지원됩니다.

Node.js의 경우, 클라이언트는 [`'session'`](https://nodejs.org/docs/latest/api/tls.html#event-session) 이벤트를 기다려 세션 데이터를 가져오고, 이후 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)의 `session` 옵션에 이 데이터를 제공하여 세션을 재사용합니다. 서버는 세션을 재사용하기 위해 [`'newSession'`](https://nodejs.org/docs/latest/api/tls.html#event-newsession)과 [`'resumeSession'`](https://nodejs.org/docs/latest/api/tls.html#event-resumesession) 이벤트에 대한 핸들러를 구현해야 합니다. 이때 세션 ID를 조회 키로 사용하여 세션 데이터를 저장하고 복원합니다. 로드 밸런서나 클러스터 작업자 간에 세션을 재사용하려면, 서버는 세션 핸들러에서 Redis와 같은 공유 세션 캐시를 사용해야 합니다.


##### 세션 티켓[#](https://nodejs.org/docs/latest/api/tls.html#session-tickets)

서버는 전체 세션 상태를 암호화하여 "티켓" 형태로 클라이언트에게 전송합니다. 재연결 시, 클라이언트는 초기 연결에서 이 상태를 서버로 보냅니다. 이 메커니즘은 서버 측 세션 캐시가 필요 없게 만듭니다. 서버가 어떤 이유로든 티켓을 사용하지 못하면(복호화 실패, 너무 오래된 티켓 등), 새로운 세션을 생성하고 새로운 티켓을 보냅니다. 자세한 내용은 [RFC 5077](https://tools.ietf.org/html/rfc5077)을 참고하세요.

HTTPS 요청 시, 많은 웹 브라우저에서 세션 티켓을 통한 재개가 점점 더 지원되고 있습니다.

Node.js에서 클라이언트는 세션 식별자를 사용한 재개와 세션 티켓을 사용한 재개에 동일한 API를 사용합니다. 디버깅을 위해, [`tls.TLSSocket.getTLSTicket()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgettlsticket)이 값을 반환하면 세션 데이터에 티켓이 포함된 것이고, 그렇지 않으면 클라이언트 측 세션 상태가 포함된 것입니다.

TLSv1.3에서는 서버가 여러 티켓을 보낼 수 있으므로, 여러 `'session'` 이벤트가 발생할 수 있습니다. 자세한 내용은 [`'session'`](https://nodejs.org/docs/latest/api/tls.html#event-session)을 참고하세요.

단일 프로세스 서버는 세션 티켓을 사용하기 위해 특별한 구현이 필요 없습니다. 서버 재시작이나 로드 밸런서를 통해 세션 티켓을 사용하려면, 모든 서버가 동일한 티켓 키를 가져야 합니다. 내부적으로는 세 개의 16바이트 키가 있지만, tls API에서는 편의를 위해 이를 단일 48바이트 버퍼로 노출합니다.

티켓 키는 [`server.getTicketKeys()`](https://nodejs.org/docs/latest/api/tls.html#servergetticketkeys)를 호출하여 한 서버 인스턴스에서 가져온 후 배포할 수 있지만, 48바이트의 안전한 랜덤 데이터를 생성하여 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)의 `ticketKeys` 옵션으로 설정하는 것이 더 합리적입니다. 키는 정기적으로 재생성해야 하며, 서버의 키는 [`server.setTicketKeys()`](https://nodejs.org/docs/latest/api/tls.html#serversetticketkeyskeys)로 재설정할 수 있습니다.

세션 티켓 키는 암호화 키이며, ***반드시 안전하게 저장해야 합니다***. TLS 1.2 이하에서는 이 키가 유출되면 해당 키로 암호화된 모든 세션을 복호화할 수 있습니다. 디스크에 저장하지 말고, 정기적으로 재생성해야 합니다.

클라이언트가 티켓 지원을 알리면, 서버는 티켓을 보냅니다. 서버는 `secureOptions`에 `require('node:constants').SSL_OP_NO_TICKET`을 제공하여 티켓을 비활성화할 수 있습니다.

세션 식별자와 세션 티켓 모두 시간 초과가 발생하며, 이로 인해 서버는 새로운 세션을 생성합니다. 시간 초과는 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)의 `sessionTimeout` 옵션으로 설정할 수 있습니다.

모든 메커니즘에서, 재개가 실패하면 서버는 새로운 세션을 생성합니다. 세션 재개 실패가 TLS/HTTPS 연결 실패를 유발하지 않기 때문에, 불필요하게 나쁜 TLS 성능을 알아채기 어려울 수 있습니다. OpenSSL CLI를 사용하여 서버가 세션을 재개하는지 확인할 수 있습니다. 예를 들어 `openssl s_client`에 `-reconnect` 옵션을 사용하세요:

```bash
openssl s_client -connect localhost:443 -reconnect
```

디버그 출력을 확인하세요. 첫 연결은 "New"라고 표시됩니다. 예를 들어:

```text
New, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
```

이후 연결은 "Reused"라고 표시됩니다. 예를 들어:

```text
Reused, TLSv1.2, Cipher is ECDHE-RSA-AES128-GCM-SHA256
```


### 기본 TLS 암호화 스위트 수정하기

Node.js는 기본적으로 활성화 및 비활성화된 TLS 암호화 스위트를 내장하고 있습니다. 이 기본 암호화 목록은 Node.js를 빌드할 때 구성할 수 있으며, 배포판이 자체 기본 목록을 제공할 수 있도록 합니다.

다음 커맨드라인 명령어를 사용하여 기본 암호화 스위트를 확인할 수 있습니다:

```console
node -p crypto.constants.defaultCoreCipherList | tr ':' '\n'
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256
TLS_AES_128_GCM_SHA256
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES256-GCM-SHA384
DHE-RSA-AES128-GCM-SHA256
ECDHE-RSA-AES128-SHA256
DHE-RSA-AES128-SHA256
ECDHE-RSA-AES256-SHA384
DHE-RSA-AES256-SHA384
ECDHE-RSA-AES256-SHA256
DHE-RSA-AES256-SHA256
HIGH
!aNULL
!eNULL
!EXPORT
!DES
!RC4
!MD5
!PSK
!SRP
!CAMELLIA
```

이 기본값은 [`--tls-cipher-list`](https://nodejs.org/docs/latest/api/cli.html#--tls-cipher-listlist) 커맨드라인 스위치를 사용하여 완전히 대체할 수 있습니다. 이는 직접적으로 또는 [`NODE_OPTIONS`](https://nodejs.org/docs/latest/api/cli.html#node_optionsoptions) 환경 변수를 통해 설정할 수 있습니다. 예를 들어, 다음 명령어는 `ECDHE-RSA-AES128-GCM-SHA256:!RC4`를 기본 TLS 암호화 스위트로 설정합니다:

```bash
node --tls-cipher-list='ECDHE-RSA-AES128-GCM-SHA256:!RC4' server.js
export NODE_OPTIONS=--tls-cipher-list='ECDHE-RSA-AES128-GCM-SHA256:!RC4'
node server.js
```

설정을 확인하려면 다음 명령어를 사용하여 암호화 목록을 표시합니다. `defaultCoreCipherList`와 `defaultCipherList`의 차이를 주목하세요:

```bash
node --tls-cipher-list='ECDHE-RSA-AES128-GCM-SHA256:!RC4' -p crypto.constants.defaultCipherList | tr ':' '\n'
ECDHE-RSA-AES128-GCM-SHA256
!RC4
```

즉, `defaultCoreCipherList`는 컴파일 시점에 설정되고, `defaultCipherList`는 런타임에 설정됩니다.

런타임 내에서 기본 암호화 스위트를 수정하려면 `tls.DEFAULT_CIPHERS` 변수를 수정합니다. 이 작업은 모든 소켓에 리스닝하기 전에 수행해야 하며, 이미 열린 소켓에는 영향을 미치지 않습니다. 예를 들어:

```js
// 구식 CBC 암호화 및 RSA 키 교환 기반 암호화 제거 (Forward Secrecy 제공하지 않음)
tls.DEFAULT_CIPHERS += ':!ECDHE-RSA-AES128-SHA:!ECDHE-RSA-AES128-SHA256:!ECDHE-RSA-AES256-SHA:!ECDHE-RSA-AES256-SHA384' +
                       ':!ECDHE-ECDSA-AES128-SHA:!ECDHE-ECDSA-AES128-SHA256:!ECDHE-ECDSA-AES256-SHA:!ECDHE-ECDSA-AES256-SHA384' +
                       ':!kRSA';
```

기본값은 클라이언트 또는 서버별로 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `ciphers` 옵션을 사용하여 대체할 수도 있습니다. 이 옵션은 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener), [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback), 그리고 새로운 [`tls.TLSSocket`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)을 생성할 때도 사용할 수 있습니다.

암호화 목록은 `'TLS_'`로 시작하는 TLSv1.3 암호화 스위트 이름과 TLSv1.2 및 이하 버전의 암호화 스위트 명세를 혼합하여 포함할 수 있습니다. TLSv1.2 암호화는 레거시 명세 형식을 지원하며, 자세한 내용은 OpenSSL [암호화 목록 형식](https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT) 문서를 참조하세요. 하지만 이러한 명세는 TLSv1.3 암호화에는 적용되지 않습니다. TLSv1.3 스위트는 암호화 목록에 전체 이름을 포함해야만 활성화할 수 있습니다. 예를 들어, 레거시 TLSv1.2 `'EECDH'` 또는 `'!EECDH'` 명세를 사용하여 활성화하거나 비활성화할 수 없습니다.

TLSv1.3과 TLSv1.2 암호화 스위트의 상대적 순서에도 불구하고, TLSv1.3 프로토콜은 TLSv1.2보다 훨씬 더 안전하며, 핸드셰이크가 지원된다면 항상 TLSv1.2보다 우선적으로 선택됩니다.

Node.js에 포함된 기본 암호화 스위트는 현재의 보안 모범 사례와 위험 완화를 반영하도록 신중하게 선택되었습니다. 기본 암호화 스위트를 변경하면 애플리케이션의 보안에 큰 영향을 미칠 수 있습니다. `--tls-cipher-list` 스위치와 `ciphers` 옵션은 반드시 필요한 경우에만 사용해야 합니다.

기본 암호화 스위트는 [Chrome의 '모던 암호화' 설정](https://www.chromium.org/Home/chromium-security/education/tls#TOC-Cipher-Suites)을 위해 GCM 암호화를 선호하며, 완전한 순방향 비밀성을 위해 ECDHE와 DHE 암호화를 선호합니다. 또한 일부 하위 호환성을 제공합니다.

RC4 또는 DES 기반 암호화에 의존하는 오래된 클라이언트(예: Internet Explorer 6)는 기본 구성으로 핸드셰이크를 완료할 수 없습니다. 이러한 클라이언트를 반드시 지원해야 한다면, [TLS 권장 사항](https://wiki.mozilla.org/Security/Server_Side_TLS)에서 호환 가능한 암호화 스위트를 제공할 수 있습니다. 형식에 대한 자세한 내용은 OpenSSL [암호화 목록 형식](https://www.openssl.org/docs/man1.1.1/man1/ciphers.html#CIPHER-LIST-FORMAT) 문서를 참조하세요.

TLSv1.3 암호화 스위트는 다음과 같이 다섯 가지만 있습니다:

-   `'TLS_AES_256_GCM_SHA384'`
-   `'TLS_CHACHA20_POLY1305_SHA256'`
-   `'TLS_AES_128_GCM_SHA256'`
-   `'TLS_AES_128_CCM_SHA256'`
-   `'TLS_AES_128_CCM_8_SHA256'`

처음 세 가지는 기본적으로 활성화되어 있습니다. 두 가지 `CCM` 기반 스위트는 제한된 시스템에서 더 나은 성능을 제공할 수 있기 때문에 TLSv1.3에서 지원되지만, 보안이 낮기 때문에 기본적으로 활성화되어 있지 않습니다.


### OpenSSL 보안 레벨

OpenSSL 라이브러리는 암호화 작업에 대한 최소 보안 수준을 제어하기 위해 보안 레벨을 적용합니다. OpenSSL의 보안 레벨은 0부터 5까지 있으며, 각 레벨은 더 엄격한 보안 요구사항을 부과합니다. 기본 보안 레벨은 1이며, 이는 대부분의 현대 애플리케이션에 적합합니다. 그러나 TLSv1과 같은 일부 레거시 기능 및 프로토콜은 제대로 작동하기 위해 더 낮은 보안 레벨(`SECLEVEL=0`)이 필요합니다. 더 자세한 정보는 [OpenSSL 보안 레벨 문서](https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level.html#DEFAULT-CALLBACK-BEHAVIOUR)를 참고하세요.


#### 보안 수준 설정하기

Node.js 애플리케이션에서 보안 수준을 조정하려면, 암호 문자열 안에 `@SECLEVEL=X`를 포함시키면 됩니다. 여기서 `X`는 원하는 보안 수준을 나타냅니다. 예를 들어, 기본 OpenSSL 암호 목록을 사용하면서 보안 수준을 0으로 설정하려면 다음과 같이 작성할 수 있습니다:

```js
import { createServer, connect } from 'node:tls';

const port = 443;

createServer(
  {
    ciphers: 'DEFAULT@SECLEVEL=0',
    minVersion: 'TLSv1'
  },
  function(socket) {
    console.log('Client connected with protocol:', socket.getProtocol());
    socket.end();
    this.close();
  }
).listen(port, () => {
  connect(port, {
    ciphers: 'DEFAULT@SECLEVEL=0',
    maxVersion: 'TLSv1'
  });
});
```

이 방법은 보안 수준을 0으로 설정하여 레거시 기능을 사용할 수 있게 하면서도 기본 OpenSSL 암호를 활용할 수 있게 합니다.


#### [`--tls-cipher-list` 사용하기](https://nodejs.org/docs/latest/api/cli.html#--tls-cipher-listlist)[#](https://nodejs.org/docs/latest/api/tls.html#using---tls-cipher-list)

여러분은 [기본 TLS 암호화 스위트 수정](https://nodejs.org/docs/latest/api/tls.html#modifying-the-default-tls-cipher-suite)에서 설명한 대로 `--tls-cipher-list=DEFAULT@SECLEVEL=X`를 사용해 커맨드라인에서 보안 수준과 암호화 방식을 설정할 수 있습니다. 하지만 일반적으로 암호화 방식을 설정할 때 커맨드라인 옵션을 사용하는 것은 권장되지 않습니다. 대신 애플리케이션 코드 내에서 개별 컨텍스트에 대해 암호화 방식을 구성하는 것이 더 나은 방법입니다. 이 접근 방식은 더 세밀한 제어를 제공하고 전역적으로 보안 수준을 낮추는 위험을 줄일 수 있습니다.


### X509 인증서 오류 코드

OpenSSL에서 보고된 인증서 오류로 인해 여러 함수가 실패할 수 있습니다. 이 경우, 함수는 콜백을 통해 [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)를 제공하며, 이 오류 객체는 `code` 속성을 가지고 있습니다. 이 속성은 다음 값 중 하나를 가질 수 있습니다:

-   `'UNABLE_TO_GET_ISSUER_CERT'`: 발급자 인증서를 가져올 수 없음.
-   `'UNABLE_TO_GET_CRL'`: 인증서 CRL을 가져올 수 없음.
-   `'UNABLE_TO_DECRYPT_CERT_SIGNATURE'`: 인증서의 서명을 복호화할 수 없음.
-   `'UNABLE_TO_DECRYPT_CRL_SIGNATURE'`: CRL의 서명을 복호화할 수 없음.
-   `'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY'`: 발급자의 공개 키를 디코딩할 수 없음.
-   `'CERT_SIGNATURE_FAILURE'`: 인증서 서명 실패.
-   `'CRL_SIGNATURE_FAILURE'`: CRL 서명 실패.
-   `'CERT_NOT_YET_VALID'`: 인증서가 아직 유효하지 않음.
-   `'CERT_HAS_EXPIRED'`: 인증서가 만료됨.
-   `'CRL_NOT_YET_VALID'`: CRL이 아직 유효하지 않음.
-   `'CRL_HAS_EXPIRED'`: CRL이 만료됨.
-   `'ERROR_IN_CERT_NOT_BEFORE_FIELD'`: 인증서의 notBefore 필드 형식 오류.
-   `'ERROR_IN_CERT_NOT_AFTER_FIELD'`: 인증서의 notAfter 필드 형식 오류.
-   `'ERROR_IN_CRL_LAST_UPDATE_FIELD'`: CRL의 lastUpdate 필드 형식 오류.
-   `'ERROR_IN_CRL_NEXT_UPDATE_FIELD'`: CRL의 nextUpdate 필드 형식 오류.
-   `'OUT_OF_MEM'`: 메모리 부족.
-   `'DEPTH_ZERO_SELF_SIGNED_CERT'`: 자체 서명된 인증서.
-   `'SELF_SIGNED_CERT_IN_CHAIN'`: 인증서 체인에 자체 서명된 인증서가 포함됨.
-   `'UNABLE_TO_GET_ISSUER_CERT_LOCALLY'`: 로컬 발급자 인증서를 가져올 수 없음.
-   `'UNABLE_TO_VERIFY_LEAF_SIGNATURE'`: 첫 번째 인증서의 서명을 검증할 수 없음.
-   `'CERT_CHAIN_TOO_LONG'`: 인증서 체인이 너무 김.
-   `'CERT_REVOKED'`: 인증서가 취소됨.
-   `'INVALID_CA'`: 유효하지 않은 CA 인증서.
-   `'PATH_LENGTH_EXCEEDED'`: 경로 길이 제약을 초과함.
-   `'INVALID_PURPOSE'`: 지원되지 않는 인증서 용도.
-   `'CERT_UNTRUSTED'`: 인증서가 신뢰할 수 없음.
-   `'CERT_REJECTED'`: 인증서가 거부됨.
-   `'HOSTNAME_MISMATCH'`: 호스트명이 일치하지 않음.


### 클래스: `tls.CryptoStream`[#](https://nodejs.org/docs/latest/api/tls.html#class-tlscryptostream)

추가된 버전: v0.3.4  
더 이상 사용되지 않음: v0.11.3부터

`tls.CryptoStream` 클래스는 암호화된 데이터 스트림을 나타냅니다. 이 클래스는 더 이상 사용되지 않으며, 사용하지 않는 것이 좋습니다.


#### `cryptoStream.bytesWritten`[#](https://nodejs.org/docs/latest/api/tls.html#cryptostreambyteswritten)

추가된 버전: v0.3.4  
사용 중단된 버전: v0.11.3

`cryptoStream.bytesWritten` 속성은 TLS 프로토콜 구현에 필요한 바이트를 포함하여 기본 소켓에 기록된 총 바이트 수를 반환합니다.


### 클래스: `tls.SecurePair`[#](https://nodejs.org/docs/latest/api/tls.html#class-tlssecurepair)

추가된 버전: v0.3.2  
더 이상 사용되지 않음: v0.11.3

이 클래스는 [`tls.createSecurePair()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurepaircontext-isserver-requestcert-rejectunauthorized-options) 함수를 통해 반환됩니다.


#### 이벤트: `'secure'`[#](https://nodejs.org/docs/latest/api/tls.html#event-secure)

추가된 버전: v0.3.2  
사용 중단된 버전: v0.11.3

`'secure'` 이벤트는 `SecurePair` 객체가 보안 연결을 성공적으로 설정한 후에 발생합니다.

서버의 [`'secureConnection'`](https://nodejs.org/docs/latest/api/tls.html#event-secureconnection) 이벤트를 확인할 때와 마찬가지로, `pair.cleartext.authorized`를 검사하여 사용된 인증서가 올바르게 승인되었는지 확인해야 합니다.


### 클래스: `tls.Server`[#](https://nodejs.org/docs/latest/api/tls.html#class-tlsserver)

추가된 버전: v0.3.2

-   상속: [`<net.Server>`](https://nodejs.org/docs/latest/api/net.html#class-netserver)

TLS 또는 SSL을 사용하여 암호화된 연결을 수락합니다.


#### 이벤트: `'connection'`[#](https://nodejs.org/docs/latest/api/tls.html#event-connection)

추가된 버전: v0.3.2

-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 이벤트는 새로운 TCP 스트림이 설정되고, TLS 핸드셰이크가 시작되기 전에 발생합니다. `socket`은 일반적으로 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 타입의 객체이지만, [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver)의 `'connection'` 이벤트로 생성된 소켓과 달리 이벤트를 받지 않습니다. 보통 사용자들은 이 이벤트에 접근할 필요가 없습니다.

이 이벤트는 사용자가 명시적으로 TLS 서버에 연결을 주입하기 위해 발생시킬 수도 있습니다. 이 경우, 어떤 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림이든 전달할 수 있습니다.


#### 이벤트: `'keylog'`[#](https://nodejs.org/docs/latest/api/tls.html#event-keylog)

추가된 버전: v12.3.0, v10.20.0

-   `line` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) NSS `SSLKEYLOGFILE` 형식의 ASCII 텍스트 라인.
-   `tlsSocket` [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 이벤트가 발생한 `tls.TLSSocket` 인스턴스.

`keylog` 이벤트는 서버와의 연결에서 키 자료가 생성되거나 수신될 때 발생합니다. 일반적으로 핸드셰이크가 완료되기 전에 발생하지만, 반드시 그렇지는 않습니다. 이 키 자료는 디버깅을 위해 저장될 수 있으며, 이를 통해 캡처된 TLS 트래픽을 복호화할 수 있습니다. 각 소켓에 대해 여러 번 발생할 수 있습니다.

일반적인 사용 사례는 받은 라인을 공통 텍스트 파일에 추가하는 것입니다. 이 파일은 나중에 Wireshark와 같은 소프트웨어에서 트래픽을 복호화하는 데 사용됩니다:

```js
const logFile = fs.createWriteStream('/tmp/ssl-keys.log', { flags: 'a' });

server.on('keylog', (line, tlsSocket) => {
    if (tlsSocket.remoteAddress !== '...') return; // 특정 IP에 대한 키만 기록
    logFile.write(line);
});
```


#### 이벤트: `'newSession'`

`'newSession'` 이벤트는 새로운 TLS 세션이 생성될 때 발생합니다. 이 이벤트는 외부 저장소에 세션을 저장하는 데 사용할 수 있습니다. 이 데이터는 [`'resumeSession'`](https://nodejs.org/docs/latest/api/tls.html#event-resumesession) 콜백에 제공되어야 합니다.

이벤트 리스너 콜백은 호출될 때 세 가지 인자를 받습니다:

-   `sessionId` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer): TLS 세션 식별자
-   `sessionData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer): TLS 세션 데이터
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function): 인자를 받지 않는 콜백 함수로, 이 함수를 호출해야만 보안 연결을 통해 데이터를 주고받을 수 있습니다.

이 이벤트를 리스닝하는 것은 이벤트 리스너가 추가된 이후에 생성된 연결에만 영향을 미칩니다.


#### 이벤트: `'OCSPRequest'`[#](https://nodejs.org/docs/latest/api/tls.html#event-ocsprequest)

추가된 버전: v0.11.13

`'OCSPRequest'` 이벤트는 클라이언트가 인증서 상태 요청을 보낼 때 발생합니다. 리스너 콜백은 호출될 때 세 가지 인자를 받습니다:

-   `certificate` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 서버 인증서
-   `issuer` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 발급자 인증서
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) OCSP 요청 결과를 제공하기 위해 반드시 호출해야 하는 콜백 함수

서버의 현재 인증서를 파싱하여 OCSP URL과 인증서 ID를 얻을 수 있습니다. OCSP 응답을 얻은 후에는 `callback(null, resp)`를 호출합니다. 여기서 `resp`는 OCSP 응답을 포함하는 `Buffer` 인스턴스입니다. `certificate`와 `issuer`는 모두 기본 인증서와 발급자 인증서의 `Buffer` DER 표현입니다. 이를 사용하여 OCSP 인증서 ID와 OCSP 엔드포인트 URL을 얻을 수 있습니다.

또는 `callback(null, null)`을 호출하여 OCSP 응답이 없음을 나타낼 수도 있습니다.

`callback(err)`를 호출하면 `socket.destroy(err)` 호출이 발생합니다.

OCSP 요청의 일반적인 흐름은 다음과 같습니다:

1.  클라이언트가 서버에 연결하고 `'OCSPRequest'`를 보냅니다 (ClientHello의 상태 정보 확장을 통해).
2.  서버가 요청을 받고 `'OCSPRequest'` 이벤트를 발생시킵니다. 등록된 리스너가 있다면 호출합니다.
3.  서버가 `certificate` 또는 `issuer`에서 OCSP URL을 추출하고 CA에 [OCSP 요청](https://en.wikipedia.org/wiki/OCSP_stapling)을 수행합니다.
4.  서버가 CA로부터 `'OCSPResponse'`를 받고 `callback` 인자를 통해 클라이언트에게 다시 보냅니다.
5.  클라이언트가 응답을 검증하고 소켓을 닫거나 핸드셰이크를 수행합니다.

인증서가 자체 서명되었거나 발급자가 루트 인증서 목록에 없는 경우 `issuer`는 `null`일 수 있습니다. (TLS 연결을 설정할 때 `ca` 옵션을 통해 발급자를 제공할 수 있습니다.)

이 이벤트를 리스닝하는 것은 이벤트 리스너가 추가된 후에 설정된 연결에만 영향을 미칩니다.

[asn1.js](https://www.npmjs.com/package/asn1.js)와 같은 npm 모듈을 사용하여 인증서를 파싱할 수 있습니다.


#### 이벤트: `'resumeSession'`[#](https://nodejs.org/docs/latest/api/tls.html#event-resumesession)

추가된 버전: v0.9.2

`'resumeSession'` 이벤트는 클라이언트가 이전 TLS 세션을 재개하려고 요청할 때 발생합니다. 이벤트 리스너 콜백은 호출될 때 두 개의 인자를 받습니다:

-   `sessionId` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) TLS 세션 식별자
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 이전 세션이 복구되었을 때 호출될 콜백 함수: `callback([err[, sessionData]])`
    -   `err` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
    -   `sessionData` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이벤트 리스너는 주어진 `sessionId`를 사용하여 [`'newSession'`](https://nodejs.org/docs/latest/api/tls.html#event-newsession) 이벤트 핸들러에 의해 저장된 `sessionData`를 외부 저장소에서 조회해야 합니다. 데이터를 찾으면 `callback(null, sessionData)`를 호출하여 세션을 재개합니다. 데이터를 찾지 못하면 세션을 재개할 수 없습니다. `callback()`은 `sessionData` 없이 호출해야 하며, 이렇게 해야 핸드셰이크가 계속되고 새로운 세션이 생성될 수 있습니다. `callback(err)`를 호출하여 들어오는 연결을 종료하고 소켓을 파괴할 수도 있습니다.

이 이벤트를 리스닝하면 이벤트 리스너가 추가된 이후에 생성된 연결에만 영향을 미칩니다.

다음은 TLS 세션을 재개하는 예제입니다:

```js
const tlsSessionStore = {};

server.on('newSession', (id, data, cb) => {
    tlsSessionStore[id.toString('hex')] = data;
    cb();
});

server.on('resumeSession', (id, cb) => {
    cb(null, tlsSessionStore[id.toString('hex')] || null);
});
```


#### 이벤트: `'secureConnection'`[#](https://nodejs.org/docs/latest/api/tls.html#event-secureconnection)

추가된 버전: v0.3.2

`'secureConnection'` 이벤트는 새로운 연결에 대한 핸드셰이킹 과정이 성공적으로 완료된 후에 발생합니다. 리스너 콜백이 호출될 때 단일 인자가 전달됩니다:

-   `tlsSocket` [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 설정된 TLS 소켓.

`tlsSocket.authorized` 속성은 클라이언트가 서버에 제공된 인증 기관 중 하나에 의해 검증되었는지 여부를 나타내는 `boolean` 값입니다. `tlsSocket.authorized`가 `false`인 경우, `socket.authorizationError`는 인증이 실패한 이유를 설명하도록 설정됩니다. TLS 서버의 설정에 따라, 인증되지 않은 연결도 여전히 허용될 수 있습니다.

`tlsSocket.alpnProtocol` 속성은 선택된 ALPN 프로토콜을 포함하는 문자열입니다. 클라이언트나 서버가 ALPN 확장을 보내지 않아 ALPN이 선택된 프로토콜이 없는 경우, `tlsSocket.alpnProtocol`은 `false`입니다.

`tlsSocket.servername` 속성은 SNI를 통해 요청된 서버 이름을 포함하는 문자열입니다.


#### 이벤트: `'tlsClientError'`[#](https://nodejs.org/docs/latest/api/tls.html#event-tlsclienterror)

추가된 버전: v6.0.0

`'tlsClientError'` 이벤트는 보안 연결이 확립되기 전에 오류가 발생했을 때 발생합니다. 이벤트 리스너 콜백은 호출될 때 두 개의 인자를 받습니다:

-   `exception` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 오류를 설명하는 `Error` 객체
-   `tlsSocket` [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 오류가 발생한 `tls.TLSSocket` 인스턴스


#### `server.addContext(hostname, context)`[#](https://nodejs.org/docs/latest/api/tls.html#serveraddcontexthostname-context)

추가된 버전: v0.5.3

-   `hostname` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) SNI 호스트 이름 또는 와일드카드 (예: `'*'`)
-   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<tls.SecureContext>`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions) [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `options` 인자에서 가능한 속성들 (예: `key`, `cert`, `ca` 등)을 포함한 객체, 또는 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)로 생성된 TLS 컨텍스트 객체

`server.addContext()` 메서드는 클라이언트 요청의 SNI 이름이 제공된 `hostname` (또는 와일드카드)와 일치할 때 사용될 보안 컨텍스트를 추가합니다.

여러 개의 일치하는 컨텍스트가 있는 경우, 가장 최근에 추가된 컨텍스트가 사용됩니다.


#### `server.address()`[#](https://nodejs.org/docs/latest/api/tls.html#serveraddress)

추가된 버전: v0.6.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 메서드는 운영체제가 보고한 서버의 바인딩된 주소, 주소 패밀리 이름, 그리고 포트를 반환합니다. 더 자세한 정보는 [`net.Server.address()`](https://nodejs.org/docs/latest/api/net.html#serveraddress)를 참고하세요.


#### `server.close([callback])`[#](https://nodejs.org/docs/latest/api/tls.html#serverclosecallback)

추가된 버전: v0.3.2

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 서버 인스턴스의 `'close'` 이벤트를 감지하기 위해 등록되는 리스너 콜백 함수.
-   반환값: [`<tls.Server>`](https://nodejs.org/docs/latest/api/tls.html#class-tlsserver)

`server.close()` 메서드는 서버가 새로운 연결을 수락하지 못하도록 중단합니다.

이 함수는 비동기적으로 동작합니다. 서버에 더 이상 열려 있는 연결이 없을 때 `'close'` 이벤트가 발생합니다.


#### `server.getTicketKeys()`[#](https://nodejs.org/docs/latest/api/tls.html#servergetticketkeys)

추가된 버전: v3.0.0

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 세션 티켓 키를 포함하는 48바이트 버퍼

세션 티켓 키를 반환합니다.

자세한 내용은 [세션 재개(Session Resumption)](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.


#### `server.listen()`[#](https://nodejs.org/docs/latest/api/tls.html#serverlisten)

이 메서드는 암호화된 연결을 수신하기 위해 서버를 시작합니다. 이 메서드는 [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver)의 [`server.listen()`](https://nodejs.org/docs/latest/api/net.html#serverlisten)과 동일합니다.


#### `server.setSecureContext(options)`[#](https://nodejs.org/docs/latest/api/tls.html#serversetsecurecontextoptions)

추가된 버전: v11.0.0

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `options` 인자로 가능한 속성들을 포함하는 객체 (예: `key`, `cert`, `ca` 등).

`server.setSecureContext()` 메서드는 기존 서버의 보안 컨텍스트를 교체합니다. 서버에 연결된 기존 연결은 중단되지 않습니다.


#### `server.setTicketKeys(keys)`[#](https://nodejs.org/docs/latest/api/tls.html#serversetticketkeyskeys)

추가된 버전: v3.0.0

-   `keys` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<TypedArray>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) | [`<DataView>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView)  
    세션 티켓 키를 포함하는 48바이트 버퍼입니다.

세션 티켓 키를 설정합니다.

티켓 키 변경은 **새로운 서버 연결**에만 적용됩니다. 기존에 연결된 서버나 현재 진행 중인 연결은 이전 키를 사용합니다.

자세한 내용은 [세션 재개(Session Resumption)](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.


### 클래스: `tls.TLSSocket`[#](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)

추가된 버전: v0.11.4

-   상속: [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)

`tls.TLSSocket`은 작성된 데이터와 필요한 모든 TLS 협상을 투명하게 암호화합니다.

`tls.TLSSocket`의 인스턴스는 듀플렉스 [스트림](https://nodejs.org/docs/latest/api/stream.html#stream) 인터페이스를 구현합니다.

TLS 연결 메타데이터를 반환하는 메서드(예: [`tls.TLSSocket.getPeerCertificate()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeercertificatedetailed))는 연결이 열려 있는 동안에만 데이터를 반환합니다.


#### `new tls.TLSSocket(socket[, options])`[#](https://nodejs.org/docs/latest/api/tls.html#new-tlstlssocketsocket-options)

-   `socket` [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) | [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)  
    서버 측에서는 모든 `Duplex` 스트림을 사용할 수 있습니다. 클라이언트 측에서는 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 사용해야 합니다. 클라이언트 측에서 일반적인 `Duplex` 스트림을 지원하려면 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)를 사용해야 합니다.

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `enableTrace`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)를 참조하세요.
    -   `isServer`: SSL/TLS 프로토콜은 비대칭적이므로, TLSSocket은 서버로 동작할지 클라이언트로 동작할지 알아야 합니다. `true`로 설정하면 TLS 소켓이 서버로 인스턴스화됩니다. **기본값:** `false`.
    -   `server` [`<net.Server>`](https://nodejs.org/docs/latest/api/net.html#class-netserver)  
        [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver) 인스턴스입니다.
    -   `requestCert`: 원격 피어의 인증서를 요청하여 인증할지 여부를 결정합니다. 클라이언트는 항상 서버 인증서를 요청합니다. 서버(`isServer`가 `true`인 경우)는 클라이언트 인증서를 요청하기 위해 `requestCert`를 `true`로 설정할 수 있습니다.
    -   `rejectUnauthorized`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)를 참조하세요.
    -   `ALPNProtocols`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)를 참조하세요.
    -   `SNICallback`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)를 참조하세요.
    -   `session` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)  
        TLS 세션을 포함하는 `Buffer` 인스턴스입니다.
    -   `requestOCSP` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)  
        `true`로 설정하면, 클라이언트 hello에 OCSP 상태 요청 확장이 추가되고, 보안 통신이 설정되기 전에 소켓에서 `'OCSPResponse'` 이벤트가 발생합니다.
    -   `secureContext`: [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)로 생성된 TLS 컨텍스트 객체입니다. `secureContext`가 제공되지 않으면, 전체 `options` 객체를 `tls.createSecureContext()`에 전달하여 생성됩니다.
    -   ...: `secureContext` 옵션이 누락된 경우 사용되는 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions) 옵션들입니다. 그렇지 않으면 무시됩니다.

기존 TCP 소켓에서 새로운 `tls.TLSSocket` 객체를 생성합니다.


#### 이벤트: `'keylog'`[#](https://nodejs.org/docs/latest/api/tls.html#event-keylog_1)

추가된 버전: v12.3.0, v10.20.0

-   `line` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) NSS `SSLKEYLOGFILE` 형식의 ASCII 텍스트 라인.

`keylog` 이벤트는 `tls.TLSSocket`에서 키 자료가 생성되거나 소켓에 의해 수신될 때 발생합니다. 이 키 자료는 디버깅을 위해 저장될 수 있으며, 캡처된 TLS 트래픽을 복호화할 수 있게 해줍니다. 이 이벤트는 핸드셰이크가 완료되기 전이나 후에 여러 번 발생할 수 있습니다.

일반적인 사용 사례는 수신된 라인을 공통 텍스트 파일에 추가하는 것입니다. 이 파일은 나중에 Wireshark와 같은 소프트웨어에서 트래픽을 복호화하는 데 사용됩니다:

```js
const logFile = fs.createWriteStream('/tmp/ssl-keys.log', { flags: 'a' });
tlsSocket.on('keylog', (line) => logFile.write(line));
```


#### 이벤트: `'OCSPResponse'`[#](https://nodejs.org/docs/latest/api/tls.html#event-ocspresponse)

추가된 버전: v0.11.13

`'OCSPResponse'` 이벤트는 `tls.TLSSocket`이 생성될 때 `requestOCSP` 옵션이 설정되었고, OCSP 응답을 받은 경우에 발생합니다. 리스너 콜백이 호출될 때 단일 인자가 전달됩니다:

-   `response` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 서버의 OCSP 응답

일반적으로 `response`는 서버의 CA(인증 기관)에서 디지털 서명된 객체로, 서버의 인증서 폐기 상태에 대한 정보를 포함합니다.


#### 이벤트: `'secureConnect'`[#](https://nodejs.org/docs/latest/api/tls.html#event-secureconnect)

추가된 버전: v0.11.4

`'secureConnect'` 이벤트는 새로운 연결을 위한 핸드셰이크 과정이 성공적으로 완료된 후에 발생합니다. 리스너 콜백은 서버의 인증서가 승인되었는지 여부와 상관없이 호출됩니다. 서버 인증서가 지정된 CA(Certificate Authority) 중 하나에 의해 서명되었는지 확인하는 것은 클라이언트의 책임입니다. `tlsSocket.authorized` 속성을 확인하여 서버 인증서가 승인되었는지 판단할 수 있습니다. 만약 `tlsSocket.authorized === false`라면, `tlsSocket.authorizationError` 속성을 조사하여 오류를 확인할 수 있습니다. ALPN(Application-Layer Protocol Negotiation)이 사용된 경우, `tlsSocket.alpnProtocol` 속성을 확인하여 협상된 프로토콜을 확인할 수 있습니다.

`'secureConnect'` 이벤트는 `new tls.TLSSocket()` 생성자를 사용하여 [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)이 생성될 때는 발생하지 않습니다.


#### 이벤트: `'session'`[#](https://nodejs.org/docs/latest/api/tls.html#event-session)

추가된 버전: v11.10.0

-   `session` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

`'session'` 이벤트는 클라이언트 `tls.TLSSocket`에서 새로운 세션이나 TLS 티켓이 사용 가능할 때 발생합니다. 이 이벤트는 협상된 TLS 프로토콜 버전에 따라 핸드셰이크가 완료되기 전이나 후에 발생할 수 있습니다. 서버에서는 이 이벤트가 발생하지 않으며, 연결이 재개된 경우처럼 새로운 세션이 생성되지 않았을 때도 발생하지 않습니다. 일부 TLS 프로토콜 버전에서는 이 이벤트가 여러 번 발생할 수 있으며, 이 경우 모든 세션을 재개에 사용할 수 있습니다.

클라이언트에서는 `session`을 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)의 `session` 옵션에 제공하여 연결을 재개할 수 있습니다.

자세한 내용은 [세션 재개](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참조하세요.

TLSv1.2 이하 버전에서는 핸드셰이크가 완료된 후 [`tls.TLSSocket.getSession()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetsession)을 호출할 수 있습니다. TLSv1.3에서는 프로토콜상 티켓 기반 재개만 허용되며, 여러 티켓이 전송되고 핸드셰이크가 완료된 후에야 티켓이 전송됩니다. 따라서 재개 가능한 세션을 얻기 위해서는 `'session'` 이벤트를 기다려야 합니다. 모든 TLS 버전에서 동작하도록 보장하려면 애플리케이션은 `getSession()` 대신 `'session'` 이벤트를 사용해야 합니다. 단일 세션만을 얻거나 사용하려는 애플리케이션은 이 이벤트를 한 번만 수신해야 합니다:

```js
tlsSocket.once('session', (session) => {
    // 세션을 즉시 사용하거나 나중에 사용할 수 있습니다.
    tls.connect({
        session: session,
        // 기타 연결 옵션...
    });
});
```


#### `tlsSocket.address()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketaddress)

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

운영체제가 보고한 바인딩된 `address`, 주소 `family` 이름, 그리고 `port`를 반환합니다. 반환되는 객체는 다음과 같은 형태입니다: `{ port: 12346, family: 'IPv4', address: '127.0.0.1' }`.


#### `tlsSocket.authorizationError`

추가된 버전: v0.11.4

이 속성은 피어(peer)의 인증서가 검증되지 않은 이유를 반환합니다. 이 속성은 `tlsSocket.authorized === false`일 때만 설정됩니다.


#### `tlsSocket.authorized`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketauthorized)

추가된 버전: v0.11.4

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 프로퍼티는 `tls.TLSSocket` 인스턴스를 생성할 때 지정된 CA(Certificate Authority) 중 하나가 피어(peer) 인증서를 서명한 경우 `true`가 되고, 그렇지 않으면 `false`가 됩니다.


#### `tlsSocket.disableRenegotiation()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketdisablerenegotiation)

추가된 버전: v8.4.0

이 `TLSSocket` 인스턴스에 대해 TLS 재협상(renegotiation)을 비활성화합니다. 이 메서드를 호출한 후, 재협상을 시도하면 `TLSSocket`에서 `'error'` 이벤트가 발생합니다.


#### `tlsSocket.enableTrace()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketenabletrace)

추가된 버전: v12.2.0

이 기능을 활성화하면 TLS 패킷 추적 정보가 `stderr`에 기록됩니다. 이를 통해 TLS 연결 문제를 디버깅할 수 있습니다.

출력 형식은 `openssl s_client -trace` 또는 `openssl s_server -trace`의 출력과 동일합니다. 이 출력은 OpenSSL의 `SSL_trace()` 함수에 의해 생성되지만, 형식은 문서화되지 않았으며 예고 없이 변경될 수 있으므로 의존해서는 안 됩니다.


#### `tlsSocket.encrypted`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketencrypted)

추가된 버전: v0.11.4

항상 `true`를 반환합니다. 이 속성은 TLS 소켓과 일반 `net.Socket` 인스턴스를 구별하는 데 사용할 수 있습니다.


#### `tlsSocket.exportKeyingMaterial(length, label[, context])`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketexportkeyingmateriallength-label-context)

추가된 버전: v13.10.0, v12.17.0

-   `length` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 추출할 키 자료의 바이트 수
    
-   `label` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 애플리케이션 특화 레이블, 일반적으로 [IANA Exporter Label Registry](https://www.iana.org/assignments/tls-parameters/tls-parameters.xhtml#exporter-labels)의 값을 사용한다.
    
-   `context` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 선택적으로 컨텍스트를 제공할 수 있다.
    
-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 요청된 키 자료의 바이트

키 자료는 네트워크 프로토콜에서 다양한 공격을 방지하기 위한 검증에 사용된다. 예를 들어, IEEE 802.1X 명세에서 활용된다.

예제

```js
const keyingMaterial = tlsSocket.exportKeyingMaterial(128, 'client finished');
/* keyingMaterial의 예시 반환값: */
```

더 많은 정보는 OpenSSL의 [`SSL_export_keying_material`](https://www.openssl.org/docs/man1.1.1/man3/SSL_export_keying_material.html) 문서를 참고한다.


#### `tlsSocket.getCertificate()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetcertificate)

추가된 버전: v11.2.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

로컬 인증서를 나타내는 객체를 반환합니다. 반환된 객체는 인증서의 필드에 해당하는 몇 가지 속성을 가지고 있습니다.

인증서 구조에 대한 예제는 [`tls.TLSSocket.getPeerCertificate()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeercertificatedetailed)를 참고하세요.

로컬 인증서가 없는 경우 빈 객체가 반환됩니다. 소켓이 파괴된 경우 `null`이 반환됩니다.


#### `tlsSocket.getCipher()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetcipher)

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) OpenSSL에서 사용하는 암호화 스위트 이름.
    -   `standardName` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) IETF에서 정의한 암호화 스위트 이름.
    -   `version` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 이 암호화 스위트가 지원하는 최소 TLS 프로토콜 버전. 실제로 협상된 프로토콜은 [`tls.TLSSocket.getProtocol()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetprotocol)을 참조.

이 메서드는 협상된 암호화 스위트에 대한 정보를 담은 객체를 반환합니다.

예를 들어, TLSv1.2 프로토콜과 AES256-SHA 암호화 스위트를 사용하는 경우:

```json
{
    "name": "AES256-SHA",
    "standardName": "TLS_RSA_WITH_AES_256_CBC_SHA",
    "version": "SSLv3"
}
```

더 자세한 정보는 [SSL\_CIPHER\_get\_name](https://www.openssl.org/docs/man1.1.1/man3/SSL_CIPHER_get_name.html)을 참고하세요.


#### `tlsSocket.getEphemeralKeyInfo()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetephemeralkeyinfo)

추가된 버전: v5.0.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

클라이언트 연결에서 [완전 순방향 비밀성](https://nodejs.org/docs/latest/api/tls.html#perfect-forward-secrecy)을 위한 임시 키 교환의 타입, 이름, 그리고 파라미터 크기를 나타내는 객체를 반환합니다. 키 교환이 임시적이지 않은 경우 빈 객체를 반환합니다. 이 기능은 클라이언트 소켓에서만 지원되며, 서버 소켓에서 호출하면 `null`이 반환됩니다. 지원되는 타입은 `'DH'`와 `'ECDH'`입니다. `name` 속성은 타입이 `'ECDH'`일 때만 사용 가능합니다.

예시: `{ type: 'ECDH', name: 'prime256v1', size: 256 }`.


#### `tlsSocket.getFinished()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetfinished)

v9.9.0에서 추가됨

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  소켓에 전송된 가장 최근의 `Finished` 메시지를 반환합니다. 이 메시지는 SSL/TLS 핸드셰이크의 일부로 전송됩니다. 아직 `Finished` 메시지가 전송되지 않았다면 `undefined`를 반환합니다.

`Finished` 메시지는 전체 핸드셰이크의 메시지 다이제스트입니다. (TLS 1.0의 경우 총 192비트, SSL 3.0의 경우 더 많은 비트를 사용합니다.) 이 메시지는 SSL/TLS가 제공하는 인증이 충분하지 않거나 원하지 않을 때 외부 인증 절차에 사용될 수 있습니다.

이 메서드는 OpenSSL의 `SSL_get_finished` 루틴에 대응하며, [RFC 5929](https://tools.ietf.org/html/rfc5929)의 `tls-unique` 채널 바인딩을 구현하는 데 사용될 수 있습니다.


#### `tlsSocket.getPeerCertificate([detailed])`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeercertificatedetailed)

추가된 버전: v0.11.4

-   `detailed` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면 전체 인증서 체인을 포함하고, 그렇지 않으면 피어의 인증서만 포함합니다.
-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 인증서 객체

피어의 인증서를 나타내는 객체를 반환합니다. 피어가 인증서를 제공하지 않으면 빈 객체가 반환됩니다. 소켓이 파괴된 경우 `null`이 반환됩니다.

전체 인증서 체인을 요청한 경우, 각 인증서는 발급자의 인증서를 나타내는 객체를 포함하는 `issuerCertificate` 속성을 갖게 됩니다.


##### Certificate 객체

Certificate 객체는 인증서의 필드에 해당하는 속성들을 가지고 있습니다.

- `ca` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type): 인증 기관(CA)인 경우 `true`, 그렇지 않으면 `false`.
- `raw` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer): DER로 인코딩된 X.509 인증서 데이터.
- `subject` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): 인증서 주체. 국가(`C`), 주 또는 도(`ST`), 지역(`L`), 조직(`O`), 조직 단위(`OU`), 일반 이름(`CN`)으로 설명됩니다. 일반 이름은 보통 TLS 인증서에서 DNS 이름입니다. 예: `{C: 'UK', ST: 'BC', L: 'Metro', O: 'Node Fans', OU: 'Docs', CN: 'example.com'}`.
- `issuer` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object): 인증서 발급자. `subject`와 동일한 방식으로 설명됩니다.
- `valid_from` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): 인증서가 유효한 시작 날짜와 시간.
- `valid_to` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): 인증서가 유효한 종료 날짜와 시간.
- `serialNumber` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): 인증서 일련번호. 16진수 문자열로 표시됩니다. 예: `'B9B0D332A1AA5635'`.
- `fingerprint` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): DER로 인코딩된 인증서의 SHA-1 다이제스트. `:`로 구분된 16진수 문자열로 반환됩니다. 예: `'2A:7A:C2:DD:...'`.
- `fingerprint256` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): DER로 인코딩된 인증서의 SHA-256 다이제스트. `:`로 구분된 16진수 문자열로 반환됩니다. 예: `'2A:7A:C2:DD:...'`.
- `fingerprint512` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): DER로 인코딩된 인증서의 SHA-512 다이제스트. `:`로 구분된 16진수 문자열로 반환됩니다. 예: `'2A:7A:C2:DD:...'`.
- `ext_key_usage` [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) (선택 사항): 확장 키 사용. OID 집합입니다.
- `subjectaltname` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) (선택 사항): 주체의 대체 이름을 포함한 문자열. `subject` 이름의 대안입니다.
- `infoAccess` [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) (선택 사항): AuthorityInfoAccess를 설명하는 배열. OCSP와 함께 사용됩니다.
- `issuerCertificate` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) (선택 사항): 발급자 인증서 객체. 자체 서명된 인증서의 경우 순환 참조가 될 수 있습니다.

인증서는 키 타입에 따라 공개 키에 대한 정보를 포함할 수 있습니다.

RSA 키의 경우 다음 속성이 정의될 수 있습니다:

- `bits` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): RSA 비트 크기. 예: `1024`.
- `exponent` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): RSA 지수. 16진수 표기법의 문자열로 표시됩니다. 예: `'0x010001'`.
- `modulus` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type): RSA 모듈러스. 16진수 문자열로 표시됩니다. 예: `'B56CE45CB7...'`.
- `pubkey` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer): 공개 키.

EC 키의 경우 다음 속성이 정의될 수 있습니다:

- `pubkey` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer): 공개 키.
- `bits` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 키 크기(비트). 예: `256`.
- `asn1Curve` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) (선택 사항): 타원 곡선의 OID에 대한 ASN.1 이름. 잘 알려진 곡선은 OID로 식별됩니다. 드물지만 곡선이 수학적 속성으로 식별될 경우 OID가 없을 수 있습니다. 예: `'prime256v1'`.
- `nistCurve` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) (선택 사항): 타원 곡선의 NIST 이름. 모든 잘 알려진 곡선이 NIST에서 이름을 부여받은 것은 아닙니다. 예: `'P-256'`.

예제 인증서:

```js
{
  subject: {
    OU: ['Domain Control Validated', 'PositiveSSL Wildcard'],
    CN: '*.nodejs.org'
  },
  issuer: {
    C: 'GB',
    ST: 'Greater Manchester',
    L: 'Salford',
    O: 'COMODO CA Limited',
    CN: 'COMODO RSA Domain Validation Secure Server CA'
  },
  subjectaltname: 'DNS:*.nodejs.org, DNS:nodejs.org',
  infoAccess: {
    'CA Issuers - URI': ['http://crt.comodoca.com/COMODORSADomainValidationSecureServerCA.crt'],
    'OCSP - URI': ['http://ocsp.comodoca.com']
  },
  modulus: 'B56CE45CB740B09A13F64AC543B712FF9EE8E4C284B542A1708A27E82A8D151CA178153E12E6DDA15BF70FFD96CB8A88618641BDFCCA03527E665B70D779C8A349A6F88FD4EF6557180BD4C98192872BCFE3AF56E863C09DDD8BC1EC58DF9D94F914F0369102B2870BECFA1348A0838C9C49BD1C20124B442477572347047506B1FCD658A80D0C44BCC16BC5C5496CFE6E4A8428EF654CD3D8972BF6E5BFAD59C93006830B5EB1056BBB38B53D1464FA6E02BFDF2FF66CD949486F0775EC43034EC2602AEFBF1703AD221DAA2A88353C3B6A688EFE8387811F645CEED7B3FE46E1F8B9F59FAD028F349B9BC14211D5830994D055EEA3D547911E07A0ADDEB8A82B9188E58720D95CD478EEC9AF1F17BE8141BE80906F1A339445A7EB5B285F68039B0F294598A7D1C0005FC22B5271B0752F58CCDEF8C8FD856FB7AE21C80B8A2CE983AE94046E53EDE4CB89F42502D31B5360771C01C80155918637490550E3F555E2EE75CC8C636DDE3633CFEDD62E91BF0F7688273694EEEBA20C2FC9F14A2A435517BC1D7373922463409AB603295CEB0BB53787A334C9CA3CA8B30005C5A62FC0715083462E00719A8FA3ED0A9828C3871360A73F8B04A4FC1E71302844E9BB9940B77E745C9D91F226D71AFCAD4B113AAF68D92B24DDB4A2136B55A1CD1ADF39605B63CB639038ED0F4C987689866743A68769CC55847E4A06D6E2E3F1',
  exponent: '0x10001',
  pubkey: ,
  valid_from: 'Aug 14 00:00:00 2017 GMT',
  valid_to: 'Nov 20 23:59:59 2019 GMT',
  fingerprint: '01:02:59:D9:C3:D2:0D:08:F7:82:4E:44:A4:B4:53:C5:E2:3A:87:4D',
  fingerprint256: '69:AE:1A:6A:D4:3D:C6:C1:1B:EA:C6:23:DE:BA:2A:14:62:62:93:5C:7A:EA:06:41:9B:0B:BC:87:CE:48:4E:02',
  fingerprint512: '19:2B:3E:C3:B3:5B:32:E8:AE:BB:78:97:27:E4:BA:6C:39:C9:92:79:4F:31:46:39:E2:70:E5:5F:89:42:17:C9:E8:64:CA:FF:BB:72:56:73:6E:28:8A:92:7E:A3:2A:15:8B:C2:E0:45:CA:C3:BC:EA:40:52:EC:CA:A2:68:CB:32',
  ext_key_usage: ['1.3.6.1.5.5.7.3.1', '1.3.6.1.5.5.7.3.2'],
  serialNumber: '66593D57F20CBC573E433381B5FEC280',
  raw: 
}
```


#### `tlsSocket.getPeerFinished()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeerfinished)

v9.9.0에서 추가됨

-   반환값: [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)  
  소켓에서 SSL/TLS 핸드셰이크의 일부로 예상되거나 실제로 수신된 최신 `Finished` 메시지를 반환합니다. 아직 `Finished` 메시지가 없다면 `undefined`를 반환합니다.

`Finished` 메시지는 전체 핸드셰이크의 메시지 다이제스트입니다. (TLS 1.0의 경우 총 192비트, SSL 3.0의 경우 더 많은 비트를 사용합니다.) SSL/TLS가 제공하는 인증이 원하지 않거나 충분하지 않을 때, 외부 인증 절차에 이 메시지를 사용할 수 있습니다.

이 메서드는 OpenSSL의 `SSL_get_peer_finished` 루틴에 대응하며, [RFC 5929](https://tools.ietf.org/html/rfc5929)의 `tls-unique` 채널 바인딩을 구현하는 데 사용될 수 있습니다.


#### `tlsSocket.getPeerX509Certificate()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeerx509certificate)

추가된 버전: v15.9.0

-   반환값: [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate)

피어(상대방)의 인증서를 [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate) 객체로 반환합니다.

피어 인증서가 없거나 소켓이 파괴된 경우 `undefined`를 반환합니다.


#### `tlsSocket.getProtocol()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetprotocol)

추가된 버전: v5.7.0

-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<null>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Null_type)

현재 연결에서 협상된 SSL/TLS 프로토콜 버전을 문자열로 반환합니다. 핸드셰이킹 과정이 완료되지 않은 연결된 소켓의 경우 `'unknown'` 값이 반환됩니다. 서버 소켓이나 연결이 끊어진 클라이언트 소켓의 경우 `null`이 반환됩니다.

지원되는 프로토콜 버전은 다음과 같습니다:

-   `'SSLv3'`
-   `'TLSv1'`
-   `'TLSv1.1'`
-   `'TLSv1.2'`
-   `'TLSv1.3'`

더 자세한 정보는 OpenSSL의 [`SSL_get_version`](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_version.html) 문서를 참고하세요.


#### `tlsSocket.getSession()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetsession)

추가된 버전: v0.11.4

-   [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

TLS 세션 데이터를 반환합니다. 세션이 협상되지 않은 경우 `undefined`를 반환합니다. 클라이언트에서는 이 데이터를 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)의 `session` 옵션에 제공하여 연결을 재개할 수 있습니다. 서버에서는 디버깅에 유용할 수 있습니다.

자세한 내용은 [세션 재개(Session Resumption)](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.

참고: `getSession()`은 TLSv1.2 및 이하 버전에서만 동작합니다. TLSv1.3의 경우, 애플리케이션은 [`'session'`](https://nodejs.org/docs/latest/api/tls.html#event-session) 이벤트를 사용해야 합니다(이 이벤트는 TLSv1.2 및 이하 버전에서도 동작합니다).


#### `tlsSocket.getSharedSigalgs()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetsharedsigalgs)

추가된 버전: v12.11.0

-   반환값: [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) 서버와 클라이언트 간에 공유된 서명 알고리즘 목록을 선호도가 높은 순서대로 반환합니다.

자세한 내용은 [SSL\_get\_shared\_sigalgs](https://www.openssl.org/docs/man1.1.1/man3/SSL_get_shared_sigalgs.html)를 참고하세요.


#### `tlsSocket.getTLSTicket()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgettlsticket)

추가된 버전: v0.11.4

-   [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

클라이언트의 경우, 사용 가능한 TLS 세션 티켓을 반환합니다. 만약 티켓이 없다면 `undefined`를 반환합니다. 서버의 경우 항상 `undefined`를 반환합니다.

이 메서드는 디버깅에 유용할 수 있습니다.

자세한 내용은 [세션 재개(Session Resumption)](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.


#### `tlsSocket.getX509Certificate()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetx509certificate)

추가된 버전: v15.9.0

-   반환값: [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate)

로컬 인증서를 [`<X509Certificate>`](https://nodejs.org/docs/latest/api/crypto.html#class-x509certificate) 객체로 반환합니다.

로컬 인증서가 없거나 소켓이 파괴된 경우 `undefined`가 반환됩니다.


#### `tlsSocket.isSessionReused()`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketissessionreused)

추가된 버전: v0.5.6

-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 세션이 재사용된 경우 `true`, 그렇지 않으면 `false`를 반환합니다.

자세한 내용은 [세션 재개(Session Resumption)](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.


#### `tlsSocket.localAddress`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketlocaladdress)

추가된 버전: v0.11.4

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

로컬 IP 주소의 문자열 표현을 반환합니다.


#### `tlsSocket.localPort`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketlocalport)

추가된 버전: v0.11.4

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

로컬 포트의 숫자 표현을 반환합니다.


#### `tlsSocket.remoteAddress`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketremoteaddress)

추가된 버전: v0.11.4

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

원격 IP 주소의 문자열 표현을 반환합니다. 예를 들어, `'74.125.127.100'` 또는 `'2001:4860:a005::68'`과 같은 값을 반환합니다.


#### `tlsSocket.remoteFamily`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketremotefamily)

추가된 버전: v0.11.4

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

원격 IP 패밀리의 문자열 표현을 반환합니다. `'IPv4'` 또는 `'IPv6'` 중 하나입니다.


#### `tlsSocket.remotePort`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketremoteport)

추가된 버전: v0.11.4

-   [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

원격 포트의 숫자 표현을 반환합니다. 예를 들어, `443`과 같은 값을 반환할 수 있습니다.


#### `tlsSocket.renegotiate(options, callback)`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketrenegotiateoptions-callback)

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    
    -   `rejectUnauthorized` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `false`가 아닌 경우, 서버 인증서가 제공된 CA 목록에 대해 검증됩니다. 검증이 실패하면 `'error'` 이벤트가 발생하며, `err.code`에는 OpenSSL 에러 코드가 포함됩니다. **기본값:** `true`.
    -   `requestCert`
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) `renegotiate()`가 `true`를 반환하면, 콜백은 `'secure'` 이벤트에 한 번 연결됩니다. `renegotiate()`가 `false`를 반환하면, `callback`은 다음 틱에서 에러와 함께 호출됩니다. 단, `tlsSocket`이 이미 파괴된 경우에는 `callback`이 호출되지 않습니다.
    
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 재협상이 시작되면 `true`, 그렇지 않으면 `false`를 반환합니다.
    

`tlsSocket.renegotiate()` 메서드는 TLS 재협상 프로세스를 시작합니다. 완료되면, `callback` 함수는 요청이 실패한 경우 `Error`를, 성공한 경우 `null`을 인자로 받습니다.

이 메서드는 보안 연결이 설정된 후 피어의 인증서를 요청하는 데 사용할 수 있습니다.

서버로 실행 중일 때, 소켓은 `handshakeTimeout` 시간 초과 후 에러와 함께 파괴됩니다.

TLSv1.3의 경우, 재협상을 시작할 수 없으며 프로토콜에서 지원하지 않습니다.


#### `tlsSocket.setKeyCert(context)`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketsetkeycertcontext)

추가된 버전: v22.5.0, v20.17.0

-   `context` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<tls.SecureContext>`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions) [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `options`에서 최소한 `key`와 `cert` 속성을 포함하는 객체, 또는 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)로 생성된 TLS 컨텍스트 객체.

`tlsSocket.setKeyCert()` 메서드는 소켓에 사용할 개인 키와 인증서를 설정합니다. 이 메서드는 주로 TLS 서버의 `ALPNCallback`에서 서버 인증서를 선택하고자 할 때 유용합니다.


#### `tlsSocket.setMaxSendFragment(size)`[#](https://nodejs.org/docs/latest/api/tls.html#tlssocketsetmaxsendfragmentsize)

추가된 버전: v0.11.11

-   `size` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 최대 TLS 프래그먼트 크기. 최대값은 `16384`입니다. **기본값:** `16384`.
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`tlsSocket.setMaxSendFragment()` 메서드는 최대 TLS 프래그먼트 크기를 설정합니다. 제한 설정이 성공하면 `true`를 반환하고, 실패하면 `false`를 반환합니다.

작은 프래그먼트 크기는 클라이언트의 버퍼링 지연을 줄입니다. 큰 프래그먼트는 TLS 레이어에서 전체 프래그먼트가 수신되고 무결성이 확인될 때까지 버퍼링됩니다. 큰 프래그먼트는 여러 왕복을 거칠 수 있으며, 패킷 손실이나 재정렬로 인해 처리 지연이 발생할 수 있습니다. 그러나 작은 프래그먼트는 추가적인 TLS 프레이밍 바이트와 CPU 오버헤드를 추가하여 전체 서버 처리량을 감소시킬 수 있습니다.


### `tls.checkServerIdentity(hostname, cert)`

- `hostname` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 인증서를 검증할 호스트 이름 또는 IP 주소
- `cert` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 상대방의 인증서를 나타내는 [certificate object](https://nodejs.org/docs/latest/api/tls.html#certificate-object)
- 반환값: [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

`cert` 인증서가 `hostname`에 발급되었는지 확인합니다.

실패 시 `reason`, `host`, `cert`를 포함한 [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) 객체를 반환합니다. 성공 시 [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)를 반환합니다.

이 함수는 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)에 전달할 수 있는 `checkServerIdentity` 옵션과 함께 사용하기 위해 설계되었으며, [certificate object](https://nodejs.org/docs/latest/api/tls.html#certificate-object)를 기반으로 동작합니다. 다른 목적이라면 [`x509.checkHost()`](https://nodejs.org/docs/latest/api/crypto.html#x509checkhostname-options)를 사용하는 것을 고려해보세요.

이 함수는 `tls.connect()`에 전달되는 `options.checkServerIdentity` 옵션으로 대체 함수를 제공하여 덮어쓸 수 있습니다. 덮어쓴 함수는 추가 검증을 위해 `tls.checkServerIdentity()`를 호출할 수도 있습니다.

이 함수는 인증서가 신뢰할 수 있는 CA(`options.ca`)에 의해 발급되었는지와 같은 다른 모든 검사를 통과한 경우에만 호출됩니다.

이전 버전의 Node.js는 `uniformResourceIdentifier` 주체 대체 이름이 일치하는 경우 `hostname`에 대한 인증서를 잘못 수락했습니다 ([CVE-2021-44531](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44531) 참조). `uniformResourceIdentifier` 주체 대체 이름을 수락하려는 애플리케이션은 원하는 동작을 구현하는 커스텀 `options.checkServerIdentity` 함수를 사용할 수 있습니다.


### `tls.connect(options[, callback])`

- `options` [`<Object>`]
    - `enableTrace`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
    - `host` [`<string>`] 클라이언트가 연결할 호스트. **기본값:** `'localhost'`
    - `port` [`<number>`] 클라이언트가 연결할 포트
    - `path` [`<string>`] Unix 소켓 연결을 생성할 경로. 이 옵션을 지정하면 `host`와 `port`는 무시됨
    - `socket` [`<stream.Duplex>`] 새로운 소켓을 생성하지 않고 주어진 소켓에 보안 연결을 설정. 일반적으로 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 인스턴스이지만, 모든 `Duplex` 스트림이 허용됨. 이 옵션을 지정하면 `path`, `host`, `port`는 무시되며, 인증서 검증에만 사용됨. 보통 소켓은 `tls.connect()`에 전달될 때 이미 연결되어 있지만, 나중에 연결할 수도 있음. 소켓의 연결/해제/파괴는 사용자의 책임이며, `tls.connect()`를 호출해도 `net.connect()`가 호출되지 않음
    - `allowHalfOpen` [`<boolean>`] `false`로 설정하면 읽기 가능한 쪽이 종료될 때 쓰기 가능한 쪽도 자동으로 종료됨. `socket` 옵션이 설정된 경우 이 옵션은 효과가 없음. 자세한 내용은 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 `allowHalfOpen` 옵션 참조. **기본값:** `false`
    - `rejectUnauthorized` [`<boolean>`] `false`가 아니면 서버 인증서가 제공된 CA 목록에 대해 검증됨. 검증이 실패하면 `'error'` 이벤트가 발생하며, `err.code`에 OpenSSL 에러 코드가 포함됨. **기본값:** `true`
    - `pskCallback` [`<Function>`] TLS-PSK 협상을 위한 콜백 함수. [Pre-shared keys](https://nodejs.org/docs/latest/api/tls.html#pre-shared-keys) 참조
    - `ALPNProtocols`: [`<string[]>`] | [`<Buffer[]>`] | [`<TypedArray[]>`] | [`<DataView[]>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`] 지원하는 ALPN 프로토콜을 포함한 문자열, `Buffer`, `TypedArray`, `DataView` 배열 또는 단일 `Buffer`, `TypedArray`, `DataView`. `Buffer`는 `[len][name][len][name]...` 형식이어야 함. 예: `'\x08http/1.1\x08http/1.0'`, 여기서 `len` 바이트는 다음 프로토콜 이름의 길이. 배열을 전달하는 것이 일반적으로 더 간단함. 예: `['http/1.1', 'http/1.0']`. 리스트의 앞쪽에 있는 프로토콜이 더 높은 우선순위를 가짐
    - `servername`: [`<string>`] SNI (Server Name Indication) TLS 확장을 위한 서버 이름. 연결할 호스트의 이름이며, IP 주소가 아닌 호스트 이름이어야 함. 멀티홈 서버가 클라이언트에게 제공할 올바른 인증서를 선택하는 데 사용할 수 있음. 자세한 내용은 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)의 `SNICallback` 옵션 참조
    - `checkServerIdentity(servername, cert)` [`<Function>`] 서버의 호스트 이름(또는 명시적으로 설정된 `servername`)을 인증서와 비교할 때 내장된 `tls.checkServerIdentity()` 함수 대신 사용할 콜백 함수. 검증이 실패하면 [`<Error>`]를 반환해야 함. `servername`과 `cert`가 검증되면 `undefined`를 반환해야 함
    - `session` [`<Buffer>`] TLS 세션을 포함하는 `Buffer` 인스턴스
    - `minDHSize` [`<number>`] TLS 연결을 수락하기 위한 DH 매개변수의 최소 크기(비트 단위). 서버가 `minDHSize`보다 작은 크기의 DH 매개변수를 제공하면 TLS 연결이 종료되고 에러가 발생함. **기본값:** `1024`
    - `highWaterMark`: [`<number>`] 읽기 가능한 스트림의 `highWaterMark` 매개변수와 일치. **기본값:** `16 * 1024`
    - `secureContext`: [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)로 생성된 TLS 컨텍스트 객체. `secureContext`가 제공되지 않으면 전체 `options` 객체를 `tls.createSecureContext()`에 전달하여 생성됨
    - `onread` [`<Object>`] `socket` 옵션이 누락된 경우, 들어오는 데이터는 단일 `buffer`에 저장되고 소켓에 데이터가 도착하면 제공된 `callback`에 전달됨. 그렇지 않으면 이 옵션은 무시됨. 자세한 내용은 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 `onread` 옵션 참조
    - ...: `secureContext` 옵션이 누락된 경우 사용되는 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions) 옵션. 그렇지 않으면 무시됨
    - ...: 이미 나열되지 않은 [`socket.connect()`](https://nodejs.org/docs/latest/api/net.html#socketconnectoptions-connectlistener) 옵션
- `callback` [`<Function>`]
- 반환값: [`<tls.TLSSocket>`]

`callback` 함수가 지정된 경우, [`'secureConnect'`](https://nodejs.org/docs/latest/api/tls.html#event-secureconnect) 이벤트의 리스너로 추가됨.

`tls.connect()`는 [`tls.TLSSocket`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket) 객체를 반환함.

`https` API와 달리, `tls.connect()`는 기본적으로 SNI (Server Name Indication) 확장을 활성화하지 않음. 이로 인해 일부 서버가 잘못된 인증서를 반환하거나 연결을 거부할 수 있음. SNI를 활성화하려면 `host` 외에 `servername` 옵션을 설정해야 함.

다음은 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)의 에코 서버 예제에 대한 클라이언트를 보여줌:

```js
// 포트 8000에서 대기 중인 에코 서버를 가정함.
import { connect } from 'node:tls';
import { readFileSync } from 'node:fs';
import { stdin } from 'node:process';

const options = {
    // 서버가 클라이언트 인증서 인증을 요구하는 경우에만 필요함.
    key: readFileSync('client-key.pem'),
    cert: readFileSync('client-cert.pem'),
    // 서버가 자체 서명된 인증서를 사용하는 경우에만 필요함.
    ca: [ readFileSync('server-cert.pem') ],
    // 서버의 인증서가 "localhost"가 아닌 경우에만 필요함.
    checkServerIdentity: () => {
        return null;
    },
};

const socket = connect(8000, options, () => {
    console.log('client connected', socket.authorized ? 'authorized' : 'unauthorized');
    stdin.pipe(socket);
    stdin.resume();
});

socket.setEncoding('utf8');
socket.on('data', (data) => {
    console.log(data);
});
socket.on('end', () => {
    console.log('server ends connection');
});
```

이 예제를 위한 인증서와 키를 생성하려면 다음 명령을 실행:

```bash
openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' \
    -keyout client-key.pem -out client-cert.pem
```

그런 다음, 이 예제를 위한 `server-cert.pem` 인증서를 생성하려면 다음 명령을 실행:

```bash
openssl pkcs12 -certpbe AES-256-CBC -export -out server-cert.pem \
    -inkey client-key.pem -in client-cert.pem
```


### `tls.connect(path[, options][, callback])`[#](https://nodejs.org/docs/latest/api/tls.html#tlsconnectpath-options-callback)

추가된 버전: v0.11.3

-   `path` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `options.path`의 기본값.
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)를 참조하세요.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)를 참조하세요.
-   반환값: [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)

`tls.connect()`와 동일하지만, `path`를 옵션 대신 인자로 제공할 수 있습니다.

`path` 옵션이 지정된 경우, `path` 인자보다 우선 적용됩니다.


### `tls.connect(port[, host][, options][, callback])`[#](https://nodejs.org/docs/latest/api/tls.html#tlsconnectport-host-options-callback)

추가된 버전: v0.11.3

-   `port` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `options.port`의 기본값.
-   `host` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `options.host`의 기본값.
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback) 참조.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback) 참조.
-   반환값: [`<tls.TLSSocket>`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)

`tls.connect()`와 동일하지만, `port`와 `host`를 옵션 대신 인자로 제공할 수 있습니다.

`port` 또는 `host` 옵션이 지정된 경우, 해당 옵션이 인자보다 우선 적용됩니다.


### `tls.createSecureContext([options])`

- `options` [`<Object>`]
  - `allowPartialTrustChain` [`<boolean>`] 신뢰 CA 인증서 목록에 있는 중간(자체 서명되지 않은) 인증서를 신뢰할 수 있는 것으로 간주합니다.
  - `ca` [`<string>`] | [`<string[]>`] | [`<Buffer>`] | [`<Buffer[]>`] 신뢰할 수 있는 CA 인증서를 선택적으로 재정의합니다. 기본값은 Mozilla가 관리하는 잘 알려진 CA를 신뢰합니다. 이 옵션을 사용하여 CA를 명시적으로 지정하면 Mozilla의 CA가 완전히 대체됩니다. 값은 문자열, `Buffer`, 또는 문자열과/또는 `Buffer`의 배열일 수 있습니다. 문자열이나 `Buffer`는 여러 PEM CA를 연결하여 포함할 수 있습니다. 피어의 인증서는 서버가 신뢰하는 CA에 연결 가능해야 인증이 성공합니다. 잘 알려진 CA에 연결되지 않는 인증서를 사용할 경우, 해당 인증서의 CA를 명시적으로 신뢰할 수 있는 것으로 지정해야 합니다. 그렇지 않으면 인증이 실패합니다. 피어가 기본 CA와 일치하거나 연결되지 않는 인증서를 사용하는 경우, `ca` 옵션을 사용하여 피어의 인증서가 일치하거나 연결할 수 있는 CA 인증서를 제공해야 합니다. 자체 서명된 인증서의 경우, 인증서 자체가 CA이며 반드시 제공되어야 합니다. PEM 인코딩된 인증서의 경우, 지원되는 타입은 "TRUSTED CERTIFICATE", "X509 CERTIFICATE", "CERTIFICATE"입니다. [`tls.rootCertificates`](https://nodejs.org/docs/latest/api/tls.html#tlsrootcertificates)도 참고하세요.
  - `cert` [`<string>`] | [`<string[]>`] | [`<Buffer>`] | [`<Buffer[]>`] PEM 형식의 인증서 체인입니다. 각 개인 키마다 하나의 인증서 체인이 제공되어야 합니다. 각 인증서 체인은 제공된 개인 `key`에 대한 PEM 형식의 인증서로 시작하고, 중간 인증서(있는 경우)가 순서대로 이어지며, 루트 CA는 포함되지 않습니다(루트 CA는 피어에게 미리 알려져 있어야 합니다. `ca` 참조). 여러 인증서 체인을 제공할 때, `key`의 개인 키와 같은 순서일 필요는 없습니다. 중간 인증서가 제공되지 않으면 피어가 인증서를 검증할 수 없고 핸드셰이크가 실패합니다.
  - `sigalgs` [`<string>`] 지원되는 서명 알고리즘의 콜론으로 구분된 목록입니다. 목록은 다이제스트 알고리즘(`SHA256`, `MD5` 등), 공개 키 알고리즘(`RSA-PSS`, `ECDSA` 등), 둘의 조합(예: 'RSA+SHA384') 또는 TLS v1.3 스키마 이름(예: `rsa_pss_pss_sha512`)을 포함할 수 있습니다. 자세한 내용은 [OpenSSL 매뉴얼 페이지](https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_set1_sigalgs_list.html)를 참고하세요.
  - `ciphers` [`<string>`] 기본값을 대체하는 암호 스위트 사양입니다. 자세한 내용은 [기본 TLS 암호 스위트 수정](https://nodejs.org/docs/latest/api/tls.html#modifying-the-default-tls-cipher-suite)을 참고하세요. 허용된 암호는 [`tls.getCiphers()`](https://nodejs.org/docs/latest/api/tls.html#tlsgetciphers)를 통해 얻을 수 있습니다. OpenSSL이 암호를 받아들이려면 암호 이름을 대문자로 작성해야 합니다.
  - `clientCertEngine` [`<string>`] 클라이언트 인증서를 제공할 수 있는 OpenSSL 엔진의 이름입니다. **더 이상 사용되지 않음.**
  - `crl` [`<string>`] | [`<string[]>`] | [`<Buffer>`] | [`<Buffer[]>`] PEM 형식의 CRL(인증서 취소 목록)입니다.
  - `dhparam` [`<string>`] | [`<Buffer>`] `'auto'` 또는 커스텀 Diffie-Hellman 매개변수로, ECDHE가 아닌 [완전 순방향 비밀성](https://nodejs.org/docs/latest/api/tls.html#perfect-forward-secrecy)에 필요합니다. 생략하거나 유효하지 않으면 매개변수는 조용히 버려지고 DHE 암호를 사용할 수 없게 됩니다. [ECDHE](https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman) 기반의 [완전 순방향 비밀성](https://nodejs.org/docs/latest/api/tls.html#perfect-forward-secrecy)은 여전히 사용 가능합니다.
  - `ecdhCurve` [`<string>`] ECDH 키 교환에 사용할 명명된 곡선 또는 곡선 NID 또는 이름의 콜론으로 구분된 목록을 설명하는 문자열입니다. 예: `P-521:P-384:P-256`. `auto`로 설정하면 곡선을 자동으로 선택합니다. 사용 가능한 곡선 이름 목록은 [`crypto.getCurves()`](https://nodejs.org/docs/latest/api/crypto.html#cryptogetcurves)를 통해 얻을 수 있습니다. 최신 릴리스에서는 `openssl ecparam -list_curves`를 통해 각 사용 가능한 타원 곡선의 이름과 설명을 확인할 수 있습니다. **기본값:** [`tls.DEFAULT_ECDH_CURVE`](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_ecdh_curve).
  - `honorCipherOrder` [`<boolean>`] 클라이언트의 암호 스위트 선호도 대신 서버의 암호 스위트 선호도를 사용하려고 시도합니다. `true`로 설정하면 `secureOptions`에 `SSL_OP_CIPHER_SERVER_PREFERENCE`가 설정됩니다. 자세한 내용은 [OpenSSL 옵션](https://nodejs.org/docs/latest/api/crypto.html#openssl-options)을 참고하세요.
  - `key` [`<string>`] | [`<string[]>`] | [`<Buffer>`] | [`<Buffer[]>`] | [`<Object[]>`] PEM 형식의 개인 키입니다. PEM은 개인 키가 암호화될 수 있는 옵션을 허용합니다. 암호화된 키는 `options.passphrase`로 복호화됩니다. 다른 알고리즘을 사용하는 여러 키는 암호화되지 않은 키 문자열이나 버퍼의 배열로 제공되거나, `{pem: <string|buffer>[, passphrase: <string>`]}` 형태의 객체 배열로 제공될 수 있습니다. 객체 형태는 배열에서만 사용할 수 있습니다. `object.passphrase`는 선택 사항입니다. 암호화된 키는 `object.passphrase`가 제공되면 그것으로, 그렇지 않으면 `options.passphrase`로 복호화됩니다.
  - `privateKeyEngine` [`<string>`] 개인 키를 가져올 OpenSSL 엔진의 이름입니다. `privateKeyIdentifier`와 함께 사용해야 합니다. **더 이상 사용되지 않음.**
  - `privateKeyIdentifier` [`<string>`] OpenSSL 엔진이 관리하는 개인 키의 식별자입니다. `privateKeyEngine`과 함께 사용해야 합니다. `key`와 함께 설정해서는 안 됩니다. 두 옵션은 서로 다른 방식으로 개인 키를 정의하기 때문입니다. **더 이상 사용되지 않음.**
  - `maxVersion` [`<string>`] 허용할 최대 TLS 버전을 선택적으로 설정합니다. `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, `'TLSv1'` 중 하나입니다. `secureProtocol` 옵션과 함께 지정할 수 없습니다. 둘 중 하나를 사용하세요. **기본값:** [`tls.DEFAULT_MAX_VERSION`](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_max_version).
  - `minVersion` [`<string>`] 허용할 최소 TLS 버전을 선택적으로 설정합니다. `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, `'TLSv1'` 중 하나입니다. `secureProtocol` 옵션과 함께 지정할 수 없습니다. 둘 중 하나를 사용하세요. TLSv1.2 미만으로 설정하는 것은 피해야 하지만, 상호 운용성을 위해 필요할 수 있습니다. TLSv1.2 이전 버전은 [OpenSSL 보안 수준](https://nodejs.org/docs/latest/api/tls.html#openssl-security-level)을 낮춰야 할 수 있습니다. **기본값:** [`tls.DEFAULT_MIN_VERSION`](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_min_version).
  - `passphrase` [`<string>`] 단일 개인 키 및/또는 PFX에 사용되는 공유 암호입니다.
  - `pfx` [`<string>`] | [`<string[]>`] | [`<Buffer>`] | [`<Buffer[]>`] | [`<Object[]>`] PFX 또는 PKCS12로 인코딩된 개인 키와 인증서 체인입니다. `pfx`는 `key`와 `cert`를 개별적으로 제공하는 대안입니다. PFX는 일반적으로 암호화되어 있으며, 암호화된 경우 `passphrase`로 복호화됩니다. 여러 PFX는 암호화되지 않은 PFX 버퍼의 배열로 제공되거나, `{buf: <string|buffer>[, passphrase: <string>`]}` 형태의 객체 배열로 제공될 수 있습니다. 객체 형태는 배열에서만 사용할 수 있습니다. `object.passphrase`는 선택 사항입니다. 암호화된 PFX는 `object.passphrase`가 제공되면 그것으로, 그렇지 않으면 `options.passphrase`로 복호화됩니다.
  - `secureOptions` [`<number>`] OpenSSL 프로토콜 동작에 영향을 미치는 선택적 옵션으로, 일반적으로 필요하지 않습니다. 사용할 경우 주의해서 사용하세요! 값은 [OpenSSL 옵션](https://nodejs.org/docs/latest/api/crypto.html#openssl-options)의 `SSL_OP_*` 옵션의 숫자 비트마스크입니다.
  - `secureProtocol` [`<string>`] 사용할 TLS 프로토콜 버전을 선택하는 레거시 메커니즘으로, 최소 및 최대 버전을 독립적으로 제어할 수 없으며 TLSv1.3으로 프로토콜을 제한할 수 없습니다. 대신 `minVersion`과 `maxVersion`을 사용하세요. 가능한 값은 [SSL\_METHODS](https://www.openssl.org/docs/man1.1.1/man7/ssl.html#Dealing-with-Protocol-Methods)에 나열되어 있으며, 함수 이름을 문자열로 사용합니다. 예를 들어, `'TLSv1_1_method'`를 사용하여 TLS 버전 1.1을 강제하거나, `'TLS_method'`를 사용하여 TLSv1.3까지의 모든 TLS 프로토콜 버전을 허용할 수 있습니다. TLS 1.2 미만 버전을 사용하는 것은 권장되지 않지만, 상호 운용성을 위해 필요할 수 있습니다. **기본값:** 없음, `minVersion` 참고.
  - `sessionIdContext` [`<string>`] 서버가 애플리케이션 간에 세션 상태가 공유되지 않도록 하는 불투명 식별자입니다. 클라이언트에서는 사용되지 않습니다.
  - `ticketKeys`: [`<Buffer>`] 암호학적으로 강력한 의사 난수 데이터 48바이트입니다. 자세한 내용은 [세션 재개](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요.
  - `sessionTimeout` [`<number>`] 서버가 생성한 TLS 세션이 더 이상 재개할 수 없게 되는 시간(초)입니다. 자세한 내용은 [세션 재개](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참고하세요. **기본값:** `300`.

[`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)는 `honorCipherOrder` 옵션의 기본값을 `true`로 설정합니다. 다른 API는 이 옵션을 설정하지 않습니다.

[`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener)는 `process.argv`에서 생성된 128비트 잘린 SHA1 해시 값을 `sessionIdContext` 옵션의 기본값으로 사용합니다. 다른 API는 이 옵션에 기본값을 설정하지 않습니다.

`tls.createSecureContext()` 메서드는 `SecureContext` 객체를 생성합니다. 이 객체는 [`server.addContext()`](https://nodejs.org/docs/latest/api/tls.html#serveraddcontexthostname-context)와 같은 여러 `tls` API의 인수로 사용할 수 있지만, 공개 메서드는 없습니다. [`tls.Server`](https://nodejs.org/docs/latest/api/tls.html#class-tlsserver) 생성자와 [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 메서드는 `secureContext` 옵션을 지원하지 않습니다.

인증서를 사용하는 암호에는 키가 **필수**입니다. `key` 또는 `pfx`를 사용하여 제공할 수 있습니다.

`ca` 옵션이 제공되지 않으면 Node.js는 [Mozilla의 공개적으로 신뢰할 수 있는 CA 목록](https://hg.mozilla.org/mozilla-central/raw-file/tip/security/nss/lib/ckfw/builtins/certdata.txt)을 기본값으로 사용합니다.

커스텀 DHE 매개변수는 새로운 `dhparam: 'auto'` 옵션을 선호하여 사용하지 않는 것이 좋습니다. `'auto'`로 설정하면 충분한 강도의 잘 알려진 DHE 매개변수가 자동으로 선택됩니다. 그렇지 않으면 필요한 경우 `openssl dhparam`을 사용하여 커스텀 매개변수를 생성할 수 있습니다. 키 길이는 1024비트 이상이어야 하며, 그렇지 않으면 오류가 발생합니다. 1024비트는 허용되지만, 더 강한 보안을 위해 2048비트 이상을 사용하세요.


### `tls.createSecurePair([context][, isServer][, requestCert][, rejectUnauthorized][, options])`

- `context` [`<Object>`] `tls.createSecureContext()`가 반환한 보안 컨텍스트 객체
- `isServer` [`<boolean>`] 이 TLS 연결을 서버로 열려면 `true`로 설정
- `requestCert` [`<boolean>`] 서버가 연결하는 클라이언트로부터 인증서를 요청할지 여부. `isServer`가 `true`일 때만 적용
- `rejectUnauthorized` [`<boolean>`] `false`가 아니면 서버가 유효하지 않은 인증서를 가진 클라이언트를 자동으로 거부. `isServer`가 `true`일 때만 적용
- `options`
  - `enableTrace`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
  - `secureContext`: [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)가 반환한 TLS 컨텍스트 객체
  - `isServer`: `true`면 TLS 소켓이 서버 모드로 생성. **기본값:** `false`
  - `server` [`<net.Server>`] [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver) 인스턴스
  - `requestCert`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
  - `rejectUnauthorized`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
  - `ALPNProtocols`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
  - `SNICallback`: [`tls.createServer()`](https://nodejs.org/docs/latest/api/tls.html#tlscreateserveroptions-secureconnectionlistener) 참조
  - `session` [`<Buffer>`] TLS 세션을 포함하는 `Buffer` 인스턴스
  - `requestOCSP` [`<boolean>`] `true`면 클라이언트 hello에 OCSP 상태 요청 확장을 추가하고, 보안 통신을 시작하기 전에 소켓에서 `'OCSPResponse'` 이벤트를 발생

이 함수는 두 개의 스트림을 가진 새로운 보안 페어 객체를 생성합니다. 하나는 암호화된 데이터를 읽고 쓰고, 다른 하나는 평문 데이터를 읽고 씁니다. 일반적으로 암호화된 스트림은 들어오는 암호화된 데이터 스트림과 연결되고, 평문 스트림은 초기 암호화된 스트림을 대체하는 데 사용됩니다.

`tls.createSecurePair()`는 `cleartext`와 `encrypted` 스트림 속성을 가진 `tls.SecurePair` 객체를 반환합니다.

`cleartext`는 [`tls.TLSSocket`](https://nodejs.org/docs/latest/api/tls.html#class-tlstlssocket)과 동일한 API를 제공합니다.

`tls.createSecurePair()` 메서드는 이제 `tls.TLSSocket()`을 대신 사용하는 것이 권장됩니다. 예를 들어, 다음 코드:

```js
pair = tls.createSecurePair(/* ... */);
pair.encrypted.pipe(socket);
socket.pipe(pair.encrypted);
```

는 다음과 같이 대체할 수 있습니다:

```js
secureSocket = tls.TLSSocket(socket, options);
```

여기서 `secureSocket`은 `pair.cleartext`와 동일한 API를 제공합니다.


### `tls.createServer([options][, secureConnectionListener])`

- `options` [`<Object>`]
  - `ALPNProtocols`: [`<string[]>`] | [`<Buffer[]>`] | [`<TypedArray[]>`] | [`<DataView[]>`] | [`<Buffer>`] | [`<TypedArray>`] | [`<DataView>`]  
    지원하는 ALPN 프로토콜을 포함한 문자열, `Buffer`, `TypedArray`, 또는 `DataView` 배열 또는 단일 `Buffer`, `TypedArray`, `DataView`. `Buffer`는 `[len][name][len][name]...` 형식이어야 합니다. 예를 들어, `0x05hello0x05world`에서 첫 번째 바이트는 다음 프로토콜 이름의 길이입니다. 배열을 전달하는 것이 일반적으로 더 간단합니다. 예: `['hello', 'world']`. (프로토콜은 우선순위에 따라 정렬되어야 합니다.)
  
  - `ALPNCallback`: [`<Function>`]  
    설정된 경우, 클라이언트가 ALPN 확장을 사용하여 연결을 열 때 호출됩니다. 콜백에는 `servername`과 `protocols` 필드를 포함한 객체가 전달됩니다. `servername`은 SNI 확장에서 가져온 서버 이름이고, `protocols`는 ALPN 프로토콜 이름 문자열 배열입니다. 콜백은 `protocols`에 나열된 문자열 중 하나를 반환해야 하며, 이는 클라이언트에게 선택된 ALPN 프로토콜로 반환됩니다. 또는 `undefined`를 반환하여 연결을 거부할 수 있습니다. 클라이언트의 ALPN 프로토콜과 일치하지 않는 문자열을 반환하면 오류가 발생합니다. 이 옵션은 `ALPNProtocols` 옵션과 함께 사용할 수 없으며, 두 옵션을 모두 설정하면 오류가 발생합니다.
  
  - `clientCertEngine` [`<string>`]  
    클라이언트 인증서를 제공할 수 있는 OpenSSL 엔진 이름. **더 이상 사용되지 않음.**
  
  - `enableTrace` [`<boolean>`]  
    `true`인 경우, 새로운 연결에 대해 [`tls.TLSSocket.enableTrace()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketenabletrace)가 호출됩니다. 트레이싱은 보안 연결이 설정된 후에도 활성화할 수 있지만, 보안 연결 설정을 트레이싱하려면 이 옵션을 사용해야 합니다. **기본값:** `false`.
  
  - `handshakeTimeout` [`<number>`]  
    SSL/TLS 핸드셰이크가 지정된 시간(밀리초) 내에 완료되지 않으면 연결을 중단합니다. 핸드셰이크가 시간 초과될 때마다 `tls.Server` 객체에서 `'tlsClientError'` 이벤트가 발생합니다. **기본값:** `120000` (120초).
  
  - `rejectUnauthorized` [`<boolean>`]  
    `false`가 아닌 경우, 서버는 제공된 CA 목록으로 인증되지 않은 모든 연결을 거부합니다. 이 옵션은 `requestCert`가 `true`인 경우에만 효과가 있습니다. **기본값:** `true`.
  
  - `requestCert` [`<boolean>`]  
    `true`인 경우, 서버는 연결하는 클라이언트로부터 인증서를 요청하고 해당 인증서를 검증하려고 시도합니다. **기본값:** `false`.
  
  - `sessionTimeout` [`<number>`]  
    서버가 생성한 TLS 세션이 더 이상 재개할 수 없게 되는 시간(초). 자세한 내용은 [세션 재개](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참조하세요. **기본값:** `300`.
  
  - `SNICallback(servername, callback)` [`<Function>`]  
    클라이언트가 SNI TLS 확장을 지원하는 경우 호출될 함수. 호출 시 두 개의 인자가 전달됩니다: `servername`과 `callback`. `callback`은 두 개의 선택적 인자를 받는 에러 우선 콜백입니다: `error`와 `ctx`. `ctx`가 제공되면 `SecureContext` 인스턴스입니다. [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)를 사용하여 적절한 `SecureContext`를 얻을 수 있습니다. `callback`이 거짓값인 `ctx` 인자와 함께 호출되면 서버의 기본 보안 컨텍스트가 사용됩니다. `SNICallback`이 제공되지 않으면 고수준 API의 기본 콜백이 사용됩니다 (아래 참조).
  
  - `ticketKeys`: [`<Buffer>`]  
    48바이트의 암호학적으로 강력한 의사 난수 데이터. 자세한 내용은 [세션 재개](https://nodejs.org/docs/latest/api/tls.html#session-resumption)를 참조하세요.
  
  - `pskCallback` [`<Function>`]  
    TLS-PSK 협상을 위한 함수. 자세한 내용은 [Pre-shared keys](https://nodejs.org/docs/latest/api/tls.html#pre-shared-keys)를 참조하세요.
  
  - `pskIdentityHint` [`<string>`]  
    TLS-PSK 협상 중 클라이언트가 ID를 선택하는 데 도움을 주기 위해 보낼 선택적 힌트. TLS 1.3에서는 무시됩니다. `pskIdentityHint` 설정에 실패하면 `'ERR_TLS_PSK_SET_IDENTITY_HINT_FAILED'` 코드와 함께 `'tlsClientError'` 이벤트가 발생합니다.
  
  - ...: [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 모든 옵션을 제공할 수 있습니다. 서버의 경우, ID 옵션(`pfx`, `key`/`cert`, 또는 `pskCallback`)이 일반적으로 필요합니다.
  
  - ...: [`net.createServer()`](https://nodejs.org/docs/latest/api/net.html#netcreateserveroptions-connectionlistener)의 모든 옵션을 제공할 수 있습니다.

- `secureConnectionListener` [`<Function>`]
- 반환값: [`<tls.Server>`]

새로운 [`tls.Server`](https://nodejs.org/docs/latest/api/tls.html#class-tlsserver)를 생성합니다. `secureConnectionListener`가 제공되면, 자동으로 [`'secureConnection'`](https://nodejs.org/docs/latest/api/tls.html#event-secureconnection) 이벤트의 리스너로 설정됩니다.

`ticketKeys` 옵션은 `node:cluster` 모듈의 작업자 간에 자동으로 공유됩니다.

다음은 간단한 에코 서버 예제입니다:

```js
import { createServer } from 'node:tls';
import { readFileSync } from 'node:fs';

const options = {
  key: readFileSync('server-key.pem'),
  cert: readFileSync('server-cert.pem'),
  // 클라이언트 인증서 인증을 사용하는 경우에만 필요합니다.
  requestCert: true,
  // 클라이언트가 자체 서명된 인증서를 사용하는 경우에만 필요합니다.
  ca: [ readFileSync('client-cert.pem') ],
};

const server = createServer(options, (socket) => {
  console.log('server connected', socket.authorized ? 'authorized' : 'unauthorized');
  socket.write('welcome!\n');
  socket.setEncoding('utf8');
  socket.pipe(socket);
});

server.listen(8000, () => {
  console.log('server bound');
});
```

이 예제를 위한 인증서와 키를 생성하려면 다음 명령을 실행하세요:

```bash
openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' \
  -keyout server-key.pem -out server-cert.pem
```

그리고 `client-cert.pem` 인증서를 생성하려면 다음 명령을 실행하세요:

```bash
openssl pkcs12 -certpbe AES-256-CBC -export -out client-cert.pem \
  -inkey server-key.pem -in server-cert.pem
```

서버는 [`tls.connect()`](https://nodejs.org/docs/latest/api/tls.html#tlsconnectoptions-callback)의 예제 클라이언트를 사용하여 연결하여 테스트할 수 있습니다.


### `tls.getCiphers()`[#](https://nodejs.org/docs/latest/api/tls.html#tlsgetciphers)

추가된 버전: v0.10.2

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

지원되는 TLS 암호화 알고리즘의 이름을 배열로 반환합니다. 이름은 역사적인 이유로 소문자로 되어 있지만, [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `ciphers` 옵션에서 사용하려면 대문자로 변환해야 합니다.

모든 지원되는 암호화 알고리즘이 기본적으로 활성화되어 있지는 않습니다. [기본 TLS 암호화 알고리즘 수정](https://nodejs.org/docs/latest/api/tls.html#modifying-the-default-tls-cipher-suite)을 참고하세요.

`'tls_'`로 시작하는 암호화 알고리즘 이름은 TLSv1.3용이고, 나머지는 TLSv1.2 및 이하 버전용입니다.

```js
console.log(tls.getCiphers()); // ['aes128-gcm-sha256', 'aes128-sha', ...]
```


### `tls.rootCertificates`[#](https://nodejs.org/docs/latest/api/tls.html#tlsrootcertificates)

추가된 버전: v12.3.0

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`tls.rootCertificates`는 현재 Node.js 버전에서 제공하는 Mozilla CA 저장소의 루트 인증서(PEM 형식)를 나타내는 문자열 배열입니다. 이 배열은 변경할 수 없습니다.

Node.js에서 제공하는 CA 저장소는 릴리스 시점에 고정된 Mozilla CA 저장소의 스냅샷입니다. 이 저장소는 모든 지원 플랫폼에서 동일합니다.


### `tls.DEFAULT_ECDH_CURVE`[#](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_ecdh_curve)

이 설정은 TLS 서버에서 ECDH(Elliptic Curve Diffie-Hellman) 키 교환에 사용할 기본 곡선 이름을 지정합니다. 기본값은 `'auto'`입니다. 더 자세한 정보는 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)를 참고하세요.


### `tls.DEFAULT_MAX_VERSION`[#](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_max_version)

추가된 버전: v11.4.0

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `maxVersion` 옵션의 기본값입니다. 이 값은 지원되는 TLS 프로토콜 버전인 `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, 또는 `'TLSv1'` 중 하나로 설정할 수 있습니다. **기본값:** CLI 옵션을 사용하여 변경하지 않는 한 `'TLSv1.3'`입니다. `--tls-max-v1.2`를 사용하면 기본값이 `'TLSv1.2'`로 설정됩니다. `--tls-max-v1.3`을 사용하면 기본값이 `'TLSv1.3'`으로 설정됩니다. 여러 옵션이 제공되면 가장 높은 최대값이 사용됩니다.


### `tls.DEFAULT_MIN_VERSION`[#](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_min_version)

추가된 버전: v11.4.0

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `minVersion` 옵션의 기본값입니다. 이 값은 지원되는 TLS 프로토콜 버전인 `'TLSv1.3'`, `'TLSv1.2'`, `'TLSv1.1'`, 또는 `'TLSv1'` 중 하나로 설정할 수 있습니다. TLSv1.2 이전 버전을 사용하려면 [OpenSSL 보안 수준](https://nodejs.org/docs/latest/api/tls.html#openssl-security-level)을 낮춰야 할 수 있습니다. **기본값:** `'TLSv1.2'`이며, CLI 옵션을 통해 변경할 수 있습니다. `--tls-min-v1.0`을 사용하면 기본값이 `'TLSv1'`로 설정됩니다. `--tls-min-v1.1`을 사용하면 기본값이 `'TLSv1.1'`로 설정됩니다. `--tls-min-v1.3`을 사용하면 기본값이 `'TLSv1.3'`로 설정됩니다. 여러 옵션이 제공되면 가장 낮은 최소값이 사용됩니다.


### `tls.DEFAULT_CIPHERS`[#](https://nodejs.org/docs/latest/api/tls.html#tlsdefault_ciphers)

추가된 버전: v19.8.0, v18.16.0

- **[`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)**  
  이 값은 [`tls.createSecureContext()`](https://nodejs.org/docs/latest/api/tls.html#tlscreatesecurecontextoptions)의 `ciphers` 옵션의 기본값입니다. 지원되는 OpenSSL 암호화 알고리즘 중 어떤 것이든 할당할 수 있습니다. 기본값은 `crypto.constants.defaultCoreCipherList`의 내용을 사용하며, `--tls-default-ciphers` 커맨드라인 옵션을 통해 변경하지 않는 한 이 값이 적용됩니다.


