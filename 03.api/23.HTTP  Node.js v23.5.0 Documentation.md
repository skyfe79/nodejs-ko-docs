# HTTP

**소스 코드:** [lib/http.js](https://github.com/nodejs/node/blob/v23.5.0/lib/http.js)

이 모듈은 클라이언트와 서버를 모두 포함하며, `require('node:http')` (CommonJS) 또는 `import * as http from 'node:http'` (ES 모듈)로 불러올 수 있습니다.

Node.js의 HTTP 인터페이스는 전통적으로 사용하기 어려웠던 프로토콜의 다양한 기능을 지원하도록 설계되었습니다. 특히, 크기가 크고 청크 인코딩이 가능한 메시지를 처리할 수 있습니다. 이 인터페이스는 전체 요청이나 응답을 버퍼링하지 않도록 주의하여, 사용자가 데이터를 스트리밍할 수 있게 합니다.

HTTP 메시지 헤더는 다음과 같은 객체로 표현됩니다:

```json
{ "content-length": "123", "content-type": "text/plain", "connection": "keep-alive", "host": "example.com", "accept": "*/*" }
```

키는 소문자로 변환됩니다. 값은 수정되지 않습니다.

가능한 모든 HTTP 애플리케이션을 지원하기 위해, Node.js HTTP API는 매우 저수준으로 설계되었습니다. 이 API는 스트림 처리와 메시지 파싱만을 다룹니다. 메시지를 헤더와 본문으로 파싱하지만, 실제 헤더나 본문을 파싱하지는 않습니다.

중복 헤더가 어떻게 처리되는지에 대한 자세한 내용은 [`message.headers`](https://nodejs.org/docs/latest/api/http.html#messageheaders)를 참조하세요.

수신된 원시 헤더는 `rawHeaders` 속성에 보존되며, 이는 `[key, value, key2, value2, ...]` 형태의 배열입니다. 예를 들어, 앞서 언급한 메시지 헤더 객체는 다음과 같은 `rawHeaders` 목록을 가질 수 있습니다:

```js
[ 'ConTent-Length', '123456', 'content-LENGTH', '123', 'content-type', 'text/plain', 'CONNECTION', 'keep-alive', 'Host', 'example.com', 'accepT', '*/*' ]
```


### 클래스: `http.Agent`[#](https://nodejs.org/docs/latest/api/http.html#class-httpagent)

추가된 버전: v0.3.4

`Agent`는 HTTP 클라이언트의 연결 지속성과 재사용을 관리하는 역할을 합니다. 이 클래스는 특정 호스트와 포트에 대한 대기 중인 요청 큐를 유지하며, 큐가 비워질 때까지 단일 소켓 연결을 재사용합니다. 큐가 비면 소켓은 파괴되거나 풀에 저장되어 동일한 호스트와 포트에 대한 요청에 다시 사용됩니다. 소켓이 파괴될지 풀에 저장될지는 `keepAlive` [옵션](https://nodejs.org/docs/latest/api/http.html#new-agentoptions)에 따라 결정됩니다.

풀에 저장된 연결은 TCP Keep-Alive가 활성화되어 있지만, 서버가 유휴 상태의 연결을 닫을 수도 있습니다. 이 경우 연결은 풀에서 제거되고, 해당 호스트와 포트에 대한 새로운 HTTP 요청이 발생할 때 새로운 연결이 생성됩니다. 서버가 동일한 연결을 통해 여러 요청을 허용하지 않을 수도 있습니다. 이 경우 각 요청마다 새로운 연결이 필요하며, 연결을 풀에 저장할 수 없습니다. `Agent`는 여전히 해당 서버에 요청을 보내지만, 각 요청은 새로운 연결을 통해 이루어집니다.

클라이언트나 서버가 연결을 닫으면, 해당 연결은 풀에서 제거됩니다. 풀에 있는 사용되지 않는 소켓은 `unref` 처리되어, 더 이상 대기 중인 요청이 없을 때 Node.js 프로세스가 계속 실행되지 않도록 합니다. (참조: [`socket.unref()`](https://nodejs.org/docs/latest/api/net.html#socketunref)).

더 이상 사용하지 않는 `Agent` 인스턴스를 [`destroy()`](https://nodejs.org/docs/latest/api/http.html#agentdestroy)하는 것이 좋은 습관입니다. 사용되지 않는 소켓은 운영 체제 리소스를 소모하기 때문입니다.

소켓이 `'close'` 이벤트나 `'agentRemove'` 이벤트를 발생시키면, 해당 소켓은 `Agent`에서 제거됩니다. 하나의 HTTP 요청을 오랫동안 열어두면서 `Agent`에 유지하지 않으려면 다음과 같은 코드를 사용할 수 있습니다:

```js
http.get(options, (res) => { 
    // 작업 수행 
}).on('socket', (socket) => { 
    socket.emit('agentRemove'); 
});
```

`Agent`는 개별 요청에도 사용할 수 있습니다. `http.get()` 또는 `http.request()` 함수에 `{agent: false}` 옵션을 제공하면, 해당 클라이언트 연결에 대해 기본 옵션을 가진 일회용 `Agent`가 사용됩니다.

`agent:false` 예제:

```js
http.get({ 
    hostname: 'localhost', 
    port: 80, 
    path: '/', 
    agent: false, // 이 요청을 위해 새로운 agent 생성
}, (res) => { 
    // 응답 처리 
});
```


#### `new Agent([options])`

- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 에이전트에 설정할 수 있는 옵션 객체입니다. 다음 필드를 포함할 수 있습니다:
    - `keepAlive` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 요청이 없더라도 소켓을 유지하여, 향후 요청 시 TCP 연결을 다시 설정하지 않고 사용할 수 있게 합니다. `Connection` 헤더의 `keep-alive` 값과 혼동하지 마세요. 에이전트를 사용할 때 `Connection: keep-alive` 헤더는 항상 전송되지만, `Connection` 헤더가 명시적으로 지정되거나 `keepAlive`와 `maxSockets` 옵션이 각각 `false`와 `Infinity`로 설정된 경우에는 `Connection: close`가 사용됩니다. **기본값:** `false`.
    - `keepAliveMsecs` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `keepAlive` 옵션을 사용할 때 TCP Keep-Alive 패킷의 초기 지연 시간을 지정합니다. `keepAlive` 옵션이 `false` 또는 `undefined`인 경우 무시됩니다. **기본값:** `1000`.
    - `maxSockets` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 호스트당 허용할 최대 소켓 수입니다. 동일한 호스트가 여러 동시 연결을 열면, 각 요청은 `maxSockets` 값에 도달할 때까지 새로운 소켓을 사용합니다. 호스트가 `maxSockets`보다 많은 연결을 시도하면, 추가 요청은 대기 큐에 들어가고 기존 연결이 종료되면 활성 연결 상태로 전환됩니다. 이를 통해 특정 호스트에서 활성 연결 수가 항상 `maxSockets` 이하로 유지됩니다. **기본값:** `Infinity`.
    - `maxTotalSockets` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 모든 호스트에 대해 허용할 최대 소켓 수입니다. 각 요청은 최대값에 도달할 때까지 새로운 소켓을 사용합니다. **기본값:** `Infinity`.
    - `maxFreeSockets` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 호스트당 유휴 상태로 유지할 최대 소켓 수입니다. `keepAlive`가 `true`로 설정된 경우에만 유효합니다. **기본값:** `256`.
    - `scheduling` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 다음 유휴 소켓을 선택할 때 적용할 스케줄링 전략입니다. `'fifo'` 또는 `'lifo'` 중 하나를 선택할 수 있습니다. 두 스케줄링 전략의 주요 차이점은 `'lifo'`는 가장 최근에 사용된 소켓을 선택하고, `'fifo'`는 가장 오래전에 사용된 소켓을 선택한다는 점입니다. 초당 요청률이 낮은 경우 `'lifo'` 스케줄링은 서버가 비활성 상태로 인해 닫힌 소켓을 선택할 위험을 줄입니다. 초당 요청률이 높은 경우 `'fifo'` 스케줄링은 열린 소켓 수를 최대화하고, `'lifo'` 스케줄링은 이를 최소로 유지합니다. **기본값:** `'lifo'`.
    - `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 소켓 타임아웃 시간(밀리초)입니다. 소켓이 생성될 때 타임아웃을 설정합니다.

[`socket.connect()`](https://nodejs.org/docs/latest/api/net.html#socketconnectoptions-connectlistener)의 `options`도 지원됩니다.

이 중 하나를 설정하려면 커스텀 [`http.Agent`](https://nodejs.org/docs/latest/api/http.html#class-httpagent) 인스턴스를 생성해야 합니다.

```js
import { Agent, request } from 'node:http';
const keepAliveAgent = new Agent({ keepAlive: true });
options.agent = keepAliveAgent;
request(options, onResponseCallback);
```


#### `agent.createConnection(options[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#agentcreateconnectionoptions-callback)

추가된 버전: v0.11.4

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 연결 세부 정보를 포함하는 옵션. 옵션 형식은 [`net.createConnection()`](https://nodejs.org/docs/latest/api/net.html#netcreateconnectionoptions-connectlistener)을 참고하세요.
-   `callback` [`<Function>`](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function) 생성된 소켓을 받는 콜백 함수
-   반환값: [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

HTTP 요청에 사용할 소켓/스트림을 생성합니다.

기본적으로 이 함수는 [`net.createConnection()`](https://nodejs.org/docs/latest/api/net.html#netcreateconnectionoptions-connectlistener)과 동일합니다. 하지만 커스텀 에이전트는 더 큰 유연성이 필요할 경우 이 메서드를 재정의할 수 있습니다.

소켓/스트림은 두 가지 방식으로 제공될 수 있습니다. 이 함수에서 소켓/스트림을 반환하거나, 소켓/스트림을 `callback`에 전달하는 방식입니다.

이 메서드는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 반환합니다.

`callback`은 `(err, stream)` 형식의 시그니처를 가집니다.


#### `agent.keepSocketAlive(socket)`[#](https://nodejs.org/docs/latest/api/http.html#agentkeepsocketalivesocket)

추가된 버전: v8.1.0

-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 메서드는 `socket`이 요청에서 분리되고 `Agent`에 의해 유지될 수 있을 때 호출됩니다. 기본 동작은 다음과 같습니다:

```js
socket.setKeepAlive(true, this.keepAliveMsecs);
socket.unref();
return true;
```

이 메서드는 특정 `Agent` 서브클래스에서 재정의할 수 있습니다. 만약 이 메서드가 거짓값을 반환하면, 소켓은 다음 요청에 사용하기 위해 유지되지 않고 파괴됩니다.

`socket` 인자는 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스이거나 [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 서브클래스일 수 있습니다.


#### `agent.reuseSocket(socket, request)`[#](https://nodejs.org/docs/latest/api/http.html#agentreusesocketsocket-request)

추가된 버전: v8.1.0

-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)
-   `request` [`<http.ClientRequest>`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)

이 메서드는 keep-alive 옵션으로 인해 유지된 `socket`이 `request`에 연결될 때 호출됩니다. 기본 동작은 다음과 같습니다:

```js
socket.ref();
```

이 메서드는 특정 `Agent` 서브클래스에서 재정의할 수 있습니다.

`socket` 인자는 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스이거나 [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 서브클래스일 수 있습니다.


#### `agent.destroy()`[#](https://nodejs.org/docs/latest/api/http.html#agentdestroy)

추가된 버전: v0.11.4

현재 에이전트가 사용 중인 모든 소켓을 파괴합니다.

일반적으로 이 작업을 수행할 필요는 없습니다. 하지만 `keepAlive`가 활성화된 에이전트를 사용하는 경우, 더 이상 필요하지 않을 때 명시적으로 에이전트를 종료하는 것이 좋습니다. 그렇지 않으면 서버가 소켓을 종료하기 전까지 소켓이 오랫동안 열려 있을 수 있습니다.


#### `agent.freeSockets`[#](https://nodejs.org/docs/latest/api/http.html#agentfreesockets)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 객체는 `keepAlive`가 활성화된 상태에서 에이전트가 사용을 기다리고 있는 소켓들의 배열을 포함합니다. 이 객체를 직접 수정하지 마세요.

`freeSockets` 목록에 있는 소켓들은 `'timeout'` 이벤트가 발생하면 자동으로 제거되고 배열에서 삭제됩니다.


#### `agent.getName([options])`[#](https://nodejs.org/docs/latest/api/http.html#agentgetnameoptions)

-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 이름 생성에 필요한 정보를 제공하는 옵션 객체
    -   `host` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청을 보낼 서버의 도메인 이름 또는 IP 주소
    -   `port` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원격 서버의 포트 번호
    -   `localAddress` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 시 네트워크 연결에 사용할 로컬 인터페이스
    -   `family` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `undefined`가 아닌 경우 4 또는 6이어야 함
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

요청 옵션에 대한 고유한 이름을 반환합니다. 이 이름은 연결을 재사용할 수 있는지 여부를 결정하는 데 사용됩니다. HTTP 에이전트의 경우 `host:port:localAddress` 또는 `host:port:localAddress:family`를 반환합니다. HTTPS 에이전트의 경우, 이름에는 CA, 인증서, 암호화 방식 및 소켓 재사용 가능성을 결정하는 기타 HTTPS/TLS 관련 옵션이 포함됩니다.


#### `agent.maxFreeSockets`[#](https://nodejs.org/docs/latest/api/http.html#agentmaxfreesockets)

추가된 버전: v0.11.7

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

기본값은 256으로 설정되어 있습니다. `keepAlive`가 활성화된 에이전트의 경우, 이 설정은 유휴 상태로 남아 있을 수 있는 소켓의 최대 개수를 지정합니다.


#### `agent.maxSockets`[#](https://nodejs.org/docs/latest/api/http.html#agentmaxsockets)

추가된 버전: v0.3.6

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

기본값은 `Infinity`로 설정되어 있습니다. 이 옵션은 에이전트가 각 오리진(origin)당 동시에 열 수 있는 소켓의 최대 수를 결정합니다. 오리진은 [`agent.getName()`](https://nodejs.org/docs/latest/api/http.html#agentgetnameoptions) 메서드가 반환하는 값입니다.


#### `agent.maxTotalSockets`[#](https://nodejs.org/docs/latest/api/http.html#agentmaxtotalsockets)

추가된 버전: v14.5.0, v12.19.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

기본값은 `Infinity`로 설정되어 있습니다. 이 옵션은 에이전트가 동시에 열 수 있는 소켓의 최대 수를 결정합니다. `maxSockets`와 달리, 이 매개변수는 모든 오리진에 걸쳐 적용됩니다.


#### `agent.requests`[#](https://nodejs.org/docs/latest/api/http.html#agentrequests)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 객체는 아직 소켓에 할당되지 않은 요청들의 큐를 포함하고 있습니다. 이 객체를 수정하지 마세요.


#### `agent.sockets`[#](https://nodejs.org/docs/latest/api/http.html#agentsockets)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 객체는 현재 에이전트가 사용 중인 소켓들의 배열을 포함합니다. 이 객체를 수정하지 마세요.


### 클래스: `http.ClientRequest`[#](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)

추가된 버전: v0.1.17

-   상속: [`<http.OutgoingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpoutgoingmessage)

이 객체는 내부적으로 생성되며 [`http.request()`](https://nodejs.org/docs/latest/api/http.html#httprequestoptions-callback)에서 반환됩니다. 이 객체는 헤더가 이미 큐에 들어간 *진행 중인* 요청을 나타냅니다. 헤더는 여전히 [`setHeader(name, value)`](https://nodejs.org/docs/latest/api/http.html#requestsetheadername-value), [`getHeader(name)`](https://nodejs.org/docs/latest/api/http.html#requestgetheadername), [`removeHeader(name)`](https://nodejs.org/docs/latest/api/http.html#requestremoveheadername) API를 사용하여 변경할 수 있습니다. 실제 헤더는 첫 번째 데이터 청크와 함께 전송되거나 [`request.end()`](https://nodejs.org/docs/latest/api/http.html#requestenddata-encoding-callback)를 호출할 때 전송됩니다.

응답을 받으려면 요청 객체에 [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 리스너를 추가하세요. [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트는 응답 헤더가 수신되었을 때 요청 객체에서 발생합니다. [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트는 [`http.IncomingMessage`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)의 인스턴스인 하나의 인자와 함께 실행됩니다.

[`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트 동안, 응답 객체에 리스너를 추가할 수 있습니다. 특히 `'data'` 이벤트를 수신하기 위해 리스너를 추가할 수 있습니다.

[`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 핸들러가 추가되지 않으면 응답은 완전히 버려집니다. 그러나 [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트 핸들러가 추가되면, 응답 객체의 데이터를 반드시 소비해야 합니다. 이는 `'readable'` 이벤트가 발생할 때마다 `response.read()`를 호출하거나, `'data'` 핸들러를 추가하거나, `.resume()` 메서드를 호출함으로써 가능합니다. 데이터가 소비될 때까지 `'end'` 이벤트는 발생하지 않습니다. 또한 데이터가 읽히지 않으면 메모리를 소비하게 되어 결국 '프로세스 메모리 부족' 오류를 일으킬 수 있습니다.

이전 버전과의 호환성을 위해, `res`는 `'error'` 리스너가 등록된 경우에만 `'error'`를 발생시킵니다.

`Content-Length` 헤더를 설정하여 응답 본문의 크기를 제한하세요. [`response.strictContentLength`](https://nodejs.org/docs/latest/api/http.html#responsestrictcontentlength)가 `true`로 설정된 경우, `Content-Length` 헤더 값이 일치하지 않으면 `code:` [`'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`](https://nodejs.org/docs/latest/api/errors.html#err_http_content_length_mismatch)로 식별되는 `Error`가 발생합니다.

`Content-Length` 값은 문자 단위가 아닌 바이트 단위여야 합니다. [`Buffer.byteLength()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferbytelengthstring-encoding)를 사용하여 본문의 길이를 바이트 단위로 확인하세요.


#### 이벤트: `'abort'`[#](https://nodejs.org/docs/latest/api/http.html#event-abort)

추가된 버전: v1.4.1  
더 이상 사용되지 않음: v17.0.0, v16.12.0

[안정성: 0](https://nodejs.org/docs/latest/api/documentation.html#stability-index) - 더 이상 사용되지 않음. 대신 `'close'` 이벤트를 사용하세요.

클라이언트가 요청을 중단했을 때 발생하는 이벤트입니다. 이 이벤트는 `abort()`가 처음 호출될 때만 발생합니다.


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/http.html#event-close)

추가된 버전: v0.5.4

이 이벤트는 요청이 완료되었거나, 응답이 완료되기 전에 기본 연결이 조기에 종료되었음을 나타냅니다.


#### 이벤트: `'connect'`[#](https://nodejs.org/docs/latest/api/http.html#event-connect)

추가된 버전: v0.7.0

-   `response` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)
-   `head` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 이벤트는 서버가 `CONNECT` 메서드로 요청에 응답할 때마다 발생합니다. 이 이벤트를 리스닝하지 않으면, `CONNECT` 메서드를 받은 클라이언트의 연결이 종료됩니다.

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 서브클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 전달받습니다.

다음은 클라이언트와 서버가 `'connect'` 이벤트를 리스닝하는 방법을 보여주는 예제입니다:

```js
import { createServer, request } from 'node:http';
import { connect } from 'node:net';
import { URL } from 'node:url';

// HTTP 터널링 프록시 생성
const proxy = createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('okay');
});

proxy.on('connect', (req, clientSocket, head) => {
    // 오리진 서버에 연결
    const { port, hostname } = new URL(`http://${req.url}`);
    const serverSocket = connect(port || 80, hostname, () => {
        clientSocket.write('HTTP/1.1 200 Connection Established\r\n' +
                          'Proxy-agent: Node.js-Proxy\r\n' +
                          '\r\n');
        serverSocket.write(head);
        serverSocket.pipe(clientSocket);
        clientSocket.pipe(serverSocket);
    });
});

// 프록시 실행
proxy.listen(1337, '127.0.0.1', () => {
    // 터널링 프록시에 요청 보내기
    const options = {
        port: 1337,
        host: '127.0.0.1',
        method: 'CONNECT',
        path: 'www.google.com:80',
    };
    const req = request(options);
    req.end();

    req.on('connect', (res, socket, head) => {
        console.log('got connected!');

        // HTTP 터널을 통해 요청 보내기
        socket.write('GET / HTTP/1.1\r\n' +
                     'Host: www.google.com:80\r\n' +
                     'Connection: close\r\n' +
                     '\r\n');

        socket.on('data', (chunk) => {
            console.log(chunk.toString());
        });

        socket.on('end', () => {
            proxy.close();
        });
    });
});
```


#### 이벤트: `'continue'`[#](https://nodejs.org/docs/latest/api/http.html#event-continue)

추가된 버전: v0.3.2

서버가 '100 Continue' HTTP 응답을 보낼 때 발생합니다. 이는 일반적으로 요청에 'Expect: 100-continue'가 포함되어 있을 때 발생합니다. 이 이벤트는 클라이언트가 요청 본문을 보내야 한다는 지시를 의미합니다.


#### 이벤트: `'finish'`[#](https://nodejs.org/docs/latest/api/http.html#event-finish)

추가된 버전: v0.3.6

이 이벤트는 요청이 전송되었을 때 발생합니다. 좀 더 구체적으로 말하면, 응답 헤더와 본문의 마지막 부분이 네트워크를 통해 전송되기 위해 운영체제로 넘겨졌을 때 이 이벤트가 발생합니다. 이 이벤트가 발생했다고 해서 서버가 아무것도 받았다는 것을 의미하지는 않습니다.


#### 이벤트: `'information'`[#](https://nodejs.org/docs/latest/api/http.html#event-information)

추가된 버전: v10.0.0

-   `info` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `httpVersion` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `httpVersionMajor` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `httpVersionMinor` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `statusCode` [`<integer>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
    -   `statusMessage` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
    -   `headers` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
    -   `rawHeaders` [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

이 이벤트는 서버가 1xx 중간 응답(101 업그레이드 제외)을 보낼 때 발생합니다. 이 이벤트의 리스너는 HTTP 버전, 상태 코드, 상태 메시지, 키-값 헤더 객체, 그리고 원시 헤더 이름과 해당 값으로 구성된 배열을 포함하는 객체를 받습니다.

```js
import { request } from 'node:http';

const options = {
    host: '127.0.0.1',
    port: 8080,
    path: '/length_request',
};

// 요청 생성
const req = request(options);
req.end();

req.on('information', (info) => {
    console.log(`Got information prior to main response: ${info.statusCode}`);
});
```

101 업그레이드 상태는 웹 소켓, 인플레이스 TLS 업그레이드, HTTP 2.0과 같이 전통적인 HTTP 요청/응답 체인에서 벗어나기 때문에 이 이벤트를 발생시키지 않습니다. 101 업그레이드 알림을 받으려면 [`'upgrade'`](https://nodejs.org/docs/latest/api/http.html#event-upgrade) 이벤트를 대신 사용하세요.


#### 이벤트: `'response'`[#](https://nodejs.org/docs/latest/api/http.html#event-response)

추가된 버전: v0.1.0

-   `response` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)

이 요청에 대한 응답을 받았을 때 발생하는 이벤트입니다. 이 이벤트는 한 번만 발생합니다.


#### 이벤트: `'socket'`[#](https://nodejs.org/docs/latest/api/http.html#event-socket)

추가된 버전: v0.5.3

-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 전달받는 것이 보장됩니다.


#### 이벤트: `'timeout'`[#](https://nodejs.org/docs/latest/api/http.html#event-timeout)

추가된 버전: v0.7.8

이 이벤트는 기본 소켓이 비활성 상태로 인해 타임아웃이 발생했을 때 발생합니다. 이 이벤트는 단순히 소켓이 유휴 상태임을 알려줄 뿐입니다. 요청은 수동으로 종료해야 합니다.

참고: [`request.setTimeout()`](https://nodejs.org/docs/latest/api/http.html#requestsettimeouttimeout-callback)


#### 이벤트: `'upgrade'`[#](https://nodejs.org/docs/latest/api/http.html#event-upgrade)

추가된 버전: v0.1.94

-   `response` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)
-   `head` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)

이 이벤트는 서버가 요청에 대해 업그레이드 응답을 보낼 때마다 발생합니다. 이 이벤트를 수신하지 않고 응답 상태 코드가 101 Switching Protocols인 경우, 업그레이드 헤더를 받은 클라이언트의 연결은 종료됩니다.

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 전달받습니다.

`'upgrade'` 이벤트를 수신하는 방법을 보여주는 클라이언트-서버 쌍 예제입니다.

```js
import http from 'node:http';
import process from 'node:process';

// HTTP 서버 생성
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('okay');
});

server.on('upgrade', (req, socket, head) => {
    socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
                 'Upgrade: WebSocket\r\n' +
                 'Connection: Upgrade\r\n' +
                 '\r\n');
    socket.pipe(socket); // 에코 백
});

// 서버 실행
server.listen(1337, '127.0.0.1', () => {
    // 요청 생성
    const options = {
        port: 1337,
        host: '127.0.0.1',
        headers: {
            'Connection': 'Upgrade',
            'Upgrade': 'websocket',
        },
    };

    const req = http.request(options);
    req.end();

    req.on('upgrade', (res, socket, upgradeHead) => {
        console.log('got upgraded!');
        socket.end();
        process.exit(0);
    });
});
```


#### `request.abort()`[#](https://nodejs.org/docs/latest/api/http.html#requestabort)

추가된 버전: v0.3.8  
더 이상 사용되지 않음: v14.1.0, v13.14.0

이 메서드는 요청을 중단하도록 표시합니다. 이 메서드를 호출하면 응답에 남아 있는 데이터가 버려지고 소켓이 파괴됩니다.


#### `request.aborted`[#](https://nodejs.org/docs/latest/api/http.html#requestaborted)

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`request.aborted` 속성은 요청이 중단된 경우 `true` 값을 가집니다.


#### `request.connection`[#](https://nodejs.org/docs/latest/api/http.html#requestconnection)

추가된 버전: v0.3.0  
사용 중단(deprecated) 버전: v13.0.0

-   [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

자세한 내용은 [`request.socket`](https://nodejs.org/docs/latest/api/http.html#requestsocket)을 참고하세요.


#### `request.cork()`[#](https://nodejs.org/docs/latest/api/http.html#requestcork)

추가된 버전: v13.2.0, v12.16.0

[`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork)를 참고하세요.


#### `request.end([data[, encoding]][, callback])`[#](https://nodejs.org/docs/latest/api/http.html#requestenddata-encoding-callback)

-   `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   Returns: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

요청 전송을 완료합니다. 만약 전송되지 않은 본문 데이터가 있다면, 스트림으로 플러시합니다. 요청이 청크(chunked) 방식이라면, 종료를 나타내는 `'0\r\n\r\n'`을 전송합니다.

`data`가 지정된 경우, [`request.write(data, encoding)`](https://nodejs.org/docs/latest/api/http.html#requestwritechunk-encoding-callback)을 호출한 후 `request.end(callback)`을 호출하는 것과 동일합니다.

`callback`이 지정된 경우, 요청 스트림이 완료되면 호출됩니다.


#### `request.destroy([error])`[#](https://nodejs.org/docs/latest/api/http.html#requestdestroyerror)

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) (선택 사항): `'error'` 이벤트와 함께 발생시킬 오류.
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

요청을 종료합니다. 선택적으로 `'error'` 이벤트를 발생시키고, `'close'` 이벤트를 발생시킵니다. 이 메서드를 호출하면 응답에 남아 있는 데이터가 버려지고 소켓이 종료됩니다.

자세한 내용은 [`writable.destroy()`](https://nodejs.org/docs/latest/api/stream.html#writabledestroyerror)를 참고하세요.


##### `request.destroyed`[#](https://nodejs.org/docs/latest/api/http.html#requestdestroyed)

추가된 버전: v14.1.0, v13.14.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`request.destroy()`](https://nodejs.org/docs/latest/api/http.html#requestdestroyerror)가 호출된 후 `true`가 됩니다.

자세한 내용은 [`writable.destroyed`](https://nodejs.org/docs/latest/api/stream.html#writabledestroyed)를 참고하세요.


#### `request.finished`[#](https://nodejs.org/docs/latest/api/http.html#requestfinished)

추가된 버전: v0.0.1  
사용 중단(deprecated) 버전: v13.4.0, v12.16.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`request.finished` 프로퍼티는 [`request.end()`](https://nodejs.org/docs/latest/api/http.html#requestenddata-encoding-callback)가 호출된 경우 `true`가 됩니다. 만약 요청이 [`http.get()`](https://nodejs.org/docs/latest/api/http.html#httpgetoptions-callback)을 통해 시작되었다면, `request.end()`는 자동으로 호출됩니다.


#### `request.flushHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#requestflushheaders)

추가된 버전: v1.6.0

요청 헤더를 즉시 전송합니다.

성능상의 이유로, Node.js는 일반적으로 `request.end()`가 호출되거나 첫 번째 요청 데이터 청크가 작성될 때까지 요청 헤더를 버퍼링합니다. 그런 다음 요청 헤더와 데이터를 단일 TCP 패킷으로 묶으려고 시도합니다.

이 방식은 일반적으로 바람직합니다(TCP 왕복 시간을 절약하기 때문). 하지만 첫 번째 데이터가 훨씬 나중에 전송될 가능성이 있는 경우에는 적합하지 않습니다. `request.flushHeaders()`는 이 최적화를 우회하고 요청을 즉시 시작합니다.


#### `request.getHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#requestgetheadername)

추가된 버전: v1.6.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

요청에 있는 헤더를 읽어옵니다. 헤더 이름은 대소문자를 구분하지 않습니다. 반환값의 타입은 [`request.setHeader()`](https://nodejs.org/docs/latest/api/http.html#requestsetheadername-value)에 제공된 인자에 따라 결정됩니다.

```js
request.setHeader('content-type', 'text/html');
request.setHeader('Content-Length', Buffer.byteLength(body));
request.setHeader('Cookie', ['type=ninja', 'language=javascript']);

const contentType = request.getHeader('Content-Type'); // 'contentType'은 'text/html'
const contentLength = request.getHeader('Content-Length'); // 'contentLength'은 number 타입
const cookie = request.getHeader('Cookie'); // 'cookie'는 string[] 타입
```


#### `request.getHeaderNames()`[#](https://nodejs.org/docs/latest/api/http.html#requestgetheadernames)

추가된 버전: v7.7.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

현재 전송 중인 헤더의 고유한 이름을 담은 배열을 반환합니다. 모든 헤더 이름은 소문자로 표시됩니다.

```js
request.setHeader('Foo', 'bar');
request.setHeader('Cookie', ['foo=bar', 'bar=baz']);
const headerNames = request.getHeaderNames();
// headerNames === ['foo', 'cookie']
```


#### `request.getHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#requestgetheaders)

추가된 버전: v7.7.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

현재 전송 중인 헤더의 얕은 복사본을 반환합니다. 얕은 복사본이 사용되기 때문에, 배열 값은 다양한 헤더 관련 http 모듈 메서드를 추가로 호출하지 않고도 변경될 수 있습니다. 반환된 객체의 키는 헤더 이름이고, 값은 해당 헤더 값입니다. 모든 헤더 이름은 소문자로 표시됩니다.

`request.getHeaders()` 메서드가 반환하는 객체는 JavaScript `Object`로부터 프로토타입 상속을 받지 않습니다. 이는 `obj.toString()`, `obj.hasOwnProperty()`와 같은 일반적인 `Object` 메서드가 정의되지 않으며 **작동하지 않는다**는 것을 의미합니다.

```js
request.setHeader('Foo', 'bar');
request.setHeader('Cookie', ['foo=bar', 'bar=baz']);
const headers = request.getHeaders();
// headers === { foo: 'bar', 'cookie': ['foo=bar', 'bar=baz'] }
```


#### `request.getRawHeaderNames()`[#](https://nodejs.org/docs/latest/api/http.html#requestgetrawheadernames)

추가된 버전: v15.13.0, v14.17.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

현재 전송 중인 원시 헤더의 고유한 이름을 배열로 반환합니다. 헤더 이름은 설정된 대소문자 그대로 반환됩니다.

```js
request.setHeader('Foo', 'bar');
request.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
const headerNames = request.getRawHeaderNames();
// headerNames === ['Foo', 'Set-Cookie']
```


#### `request.hasHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#requesthasheadername)

v7.7.0 버전에서 추가됨

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`name`으로 지정된 헤더가 현재 전송 중인 헤더에 설정되어 있으면 `true`를 반환합니다. 헤더 이름은 대소문자를 구분하지 않습니다.

```js
const hasContentType = request.hasHeader('content-type');
```


#### `request.maxHeadersCount`

- **[`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)** **기본값:** `2000`

이 옵션은 응답 헤더의 최대 개수를 제한합니다. 값을 0으로 설정하면 제한이 적용되지 않습니다.


#### `request.path`[#](https://nodejs.org/docs/latest/api/http.html#requestpath)

추가된 버전: v0.4.0

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 경로를 나타냅니다.


#### `request.method`[#](https://nodejs.org/docs/latest/api/http.html#requestmethod)

추가된 버전: v0.1.97

- [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 메서드입니다.


#### `request.host`[#](https://nodejs.org/docs/latest/api/http.html#requesthost)

추가된 버전: v14.5.0, v12.19.0

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 호스트를 나타냅니다.


#### `request.protocol`[#](https://nodejs.org/docs/latest/api/http.html#requestprotocol)

추가된 버전: v14.5.0, v12.19.0

- [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 프로토콜을 나타냅니다.


#### `request.removeHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#requestremoveheadername)

추가된 버전: v1.6.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

헤더 객체에 이미 정의된 헤더를 제거합니다.

```js
request.removeHeader('Content-Type');
```


#### `request.reusedSocket`[#](https://nodejs.org/docs/latest/api/http.html#requestreusedsocket)

추가된 버전: v13.0.0, v12.16.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 요청이 재사용된 소켓을 통해 전송되었는지 여부를 나타냅니다.

keep-alive가 활성화된 에이전트를 통해 요청을 보낼 때, 기본 소켓이 재사용될 수 있습니다. 하지만 서버가 적절하지 않은 시점에 연결을 종료하면 클라이언트는 'ECONNRESET' 오류를 마주할 수 있습니다.

```js
import http from 'node:http';

// 서버는 기본적으로 5초의 keep-alive 타임아웃을 가짐
http
    .createServer((req, res) => {
        res.write('hello\n');
        res.end();
    })
    .listen(3000);

setInterval(() => {
    // keep-alive 에이전트를 사용하여 요청 보내기
    http.get('http://localhost:3000', { agent }, (res) => {
        res.on('data', (data) => {
            // 아무 작업도 하지 않음
        });
    });
}, 5000); // 5초 간격으로 요청을 보내어 idle 타임아웃을 쉽게 발생시킴
```

요청이 소켓을 재사용했는지 여부를 표시함으로써, 이를 기반으로 자동 오류 재시도를 수행할 수 있습니다.

```js
import http from 'node:http';

const agent = new http.Agent({ keepAlive: true });

function retriableRequest() {
    const req = http
        .get('http://localhost:3000', { agent }, (res) => {
            // ...
        })
        .on('error', (err) => {
            // 재시도가 필요한지 확인
            if (req.reusedSocket && err.code === 'ECONNRESET') {
                retriableRequest();
            }
        });
}

retriableRequest();
```


#### `request.setHeader(name, value)`[#](https://nodejs.org/docs/latest/api/http.html#requestsetheadername-value)

추가된 버전: v1.6.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

헤더 객체에 단일 헤더 값을 설정합니다. 만약 이 헤더가 이미 전송될 헤더에 존재한다면, 그 값은 대체됩니다. 동일한 이름으로 여러 헤더를 보내려면 문자열 배열을 사용하세요. 문자열이 아닌 값은 수정 없이 저장됩니다. 따라서 [`request.getHeader()`](https://nodejs.org/docs/latest/api/http.html#requestgetheadername)는 문자열이 아닌 값을 반환할 수 있습니다. 하지만, 문자열이 아닌 값은 네트워크 전송을 위해 문자열로 변환됩니다.

```js
request.setHeader('Content-Type', 'application/json');
```

또는

```js
request.setHeader('Cookie', ['type=ninja', 'language=javascript']);
```

값이 문자열일 때, `latin1` 인코딩 외의 문자를 포함하면 예외가 발생합니다.

값에 UTF-8 문자를 전달해야 한다면, [RFC 8187](https://www.rfc-editor.org/rfc/rfc8187.txt) 표준을 사용하여 값을 인코딩하세요.

```js
const filename = 'Rock 🎵.txt';
request.setHeader('Content-Disposition', `attachment; filename*=utf-8''${encodeURIComponent(filename)}`);
```


#### `request.setNoDelay([noDelay])`[#](https://nodejs.org/docs/latest/api/http.html#requestsetnodelaynodelay)

추가된 버전: v0.5.9

-   `noDelay` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 요청에 소켓이 할당되고 연결되면 [`socket.setNoDelay()`](https://nodejs.org/docs/latest/api/net.html#socketsetnodelaynodelay)가 호출됩니다.


#### `request.setSocketKeepAlive([enable][, initialDelay])`[#](https://nodejs.org/docs/latest/api/http.html#requestsetsocketkeepaliveenable-initialdelay)

추가된 버전: v0.5.9

-   `enable` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)
-   `initialDelay` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

이 요청에 소켓이 할당되고 연결되면 [`socket.setKeepAlive()`](https://nodejs.org/docs/latest/api/net.html#socketsetkeepaliveenable-initialdelay)가 호출됩니다.


#### `request.setTimeout(timeout[, callback])`

- `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 요청이 타임아웃되기 전의 시간(밀리초 단위)
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 타임아웃이 발생했을 때 호출될 선택적 함수. `'timeout'` 이벤트에 바인딩하는 것과 동일
- 반환값: [`<http.ClientRequest>`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)

소켓이 이 요청에 할당되고 연결되면 [`socket.setTimeout()`](https://nodejs.org/docs/latest/api/net.html#socketsettimeouttimeout-callback)이 호출됩니다.


#### `request.socket`

추가된 버전: v0.3.0

-   [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

기본 소켓을 참조합니다. 일반적으로 사용자는 이 속성에 접근할 필요가 없습니다. 특히, 프로토콜 파서가 소켓에 연결되는 방식 때문에 소켓은 `'readable'` 이벤트를 발생시키지 않습니다.

```js
import http from 'node:http';

const options = {
    host: 'www.google.com',
};

const req = http.get(options);
req.end();

req.once('response', (res) => {
    const ip = req.socket.localAddress;
    const port = req.socket.localPort;
    console.log(`Your IP address is ${ip} and your source port is ${port}.`);
    // 응답 객체를 소비합니다
});
```

이 속성은 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스임이 보장됩니다.


#### `request.uncork()`[#](https://nodejs.org/docs/latest/api/http.html#requestuncork)

추가된 버전: v13.2.0, v12.16.0

[`writable.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork)를 참고하세요.


#### `request.writableEnded`[#](https://nodejs.org/docs/latest/api/http.html#requestwritableended)

추가된 버전: v12.9.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

[`request.end()`](https://nodejs.org/docs/latest/api/http.html#requestenddata-encoding-callback)가 호출된 후 `true`가 됩니다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다. 이를 확인하려면 [`request.writableFinished`](https://nodejs.org/docs/latest/api/http.html#requestwritablefinished)를 사용하세요.


#### `request.writableFinished`[#](https://nodejs.org/docs/latest/api/http.html#requestwritablefinished)

추가된 버전: v12.7.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 값은 모든 데이터가 하위 시스템으로 플러시된 직후, [`'finish'`](https://nodejs.org/docs/latest/api/http.html#event-finish) 이벤트가 발생하기 전에 `true`가 됩니다.


#### `request.write(chunk[, encoding][, callback])`

-   `chunk` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드는 요청 본문의 일부를 전송합니다. 여러 번 호출할 수 있습니다. `Content-Length`가 설정되지 않은 경우, 데이터는 자동으로 HTTP Chunked 전송 인코딩으로 인코딩되어 서버가 데이터의 끝을 알 수 있게 됩니다. 이때 `Transfer-Encoding: chunked` 헤더가 추가됩니다. 요청 전송을 완료하려면 [`request.end()`](https://nodejs.org/docs/latest/api/http.html#requestenddata-encoding-callback)를 호출해야 합니다.

`encoding` 인자는 선택 사항이며, `chunk`가 문자열일 때만 적용됩니다. 기본값은 `'utf8'`입니다.

`callback` 인자도 선택 사항이며, 이 데이터 청크가 플러시될 때 호출됩니다. 단, 청크가 비어 있지 않은 경우에만 호출됩니다.

전체 데이터가 커널 버퍼로 성공적으로 플러시되면 `true`를 반환합니다. 데이터의 일부 또는 전체가 사용자 메모리에 큐에 들어간 경우 `false`를 반환합니다. 버퍼가 다시 비워지면 `'drain'` 이벤트가 발생합니다.

`write` 함수가 빈 문자열이나 버퍼와 함께 호출되면 아무 작업도 하지 않고 추가 입력을 기다립니다.


### 클래스: `http.Server`[#](https://nodejs.org/docs/latest/api/http.html#class-httpserver)

추가된 버전: v0.1.17

-   상속: [`<net.Server>`](https://nodejs.org/docs/latest/api/net.html#class-netserver)


#### 이벤트: `'checkContinue'`[#](https://nodejs.org/docs/latest/api/http.html#event-checkcontinue)

추가된 버전: v0.3.0

-   `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   `response` [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

HTTP `Expect: 100-continue` 헤더가 포함된 요청이 들어올 때마다 발생합니다. 이 이벤트를 처리하지 않으면 서버는 적절한 경우 자동으로 `100 Continue` 응답을 보냅니다.

이 이벤트를 처리할 때는 클라이언트가 요청 본문을 계속 보내야 하는 경우 [`response.writeContinue()`](https://nodejs.org/docs/latest/api/http.html#responsewritecontinue)를 호출하거나, 클라이언트가 요청 본문을 보내지 않아야 하는 경우 적절한 HTTP 응답(예: 400 Bad Request)을 생성해야 합니다.

이 이벤트가 발생하고 처리되면, [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트는 발생하지 않습니다.


#### 이벤트: `'checkExpectation'`[#](https://nodejs.org/docs/latest/api/http.html#event-checkexpectation)

추가된 버전: v5.5.0

-   `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   `response` [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

HTTP `Expect` 헤더가 포함된 요청이 수신될 때마다 발생하며, 이때 헤더 값이 `100-continue`가 아닌 경우에만 이벤트가 발생합니다. 이 이벤트에 대한 리스너가 등록되어 있지 않으면, 서버는 적절히 `417 Expectation Failed`로 응답합니다.

이 이벤트가 발생하고 처리되면, [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트는 발생하지 않습니다.


#### 이벤트: `'clientError'`

-   `exception` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

클라이언트 연결에서 `'error'` 이벤트가 발생하면, 이 이벤트로 전달됩니다. 이 이벤트의 리스너는 기본 소켓을 닫거나 파괴할 책임이 있습니다. 예를 들어, 연결을 갑자기 끊는 대신 커스텀 HTTP 응답으로 소켓을 더 우아하게 닫고 싶을 수 있습니다. 리스너가 종료되기 전에 **소켓을 반드시 닫거나 파괴해야 합니다**.

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스가 전달되는 것이 보장됩니다.

기본 동작은 HTTP '400 Bad Request' 또는 [`HPE_HEADER_OVERFLOW`](https://nodejs.org/docs/latest/api/errors.html#hpe_header_overflow) 오류의 경우 HTTP '431 Request Header Fields Too Large'로 소켓을 닫으려고 시도하는 것입니다. 소켓이 쓰기 가능하지 않거나 현재 연결된 [`http.ServerResponse`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)의 헤더가 이미 전송된 경우, 소켓은 즉시 파괴됩니다.

`socket`은 오류가 발생한 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 객체입니다.

```js
import http from 'node:http';

const server = http.createServer((req, res) => {
    res.end();
});

server.on('clientError', (err, socket) => {
    socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
});

server.listen(8000);
```

`'clientError'` 이벤트가 발생할 때는 `request`나 `response` 객체가 없으므로, 응답 헤더와 페이로드를 포함한 모든 HTTP 응답은 반드시 `socket` 객체에 직접 작성해야 합니다. 응답이 올바르게 형식화된 HTTP 응답 메시지인지 확인해야 합니다.

`err`는 두 가지 추가 컬럼을 가진 `Error`의 인스턴스입니다:

-   `bytesParsed`: Node.js가 올바르게 파싱한 요청 패킷의 바이트 수
-   `rawPacket`: 현재 요청의 원시 패킷

`ECONNRESET` 오류와 같은 경우, 클라이언트가 이미 응답을 받았거나 소켓이 이미 파괴된 상태일 수 있습니다. 소켓에 데이터를 보내기 전에 여전히 쓰기 가능한지 확인하는 것이 좋습니다.

```js
server.on('clientError', (err, socket) => {
    if (err.code === 'ECONNRESET' || !socket.writable) {
        return;
    }
    socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
});
```


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/http.html#event-close_1)

추가된 버전: v0.1.4

서버가 닫힐 때 발생하는 이벤트입니다.


#### 이벤트: `'connect'`[#](https://nodejs.org/docs/latest/api/http.html#event-connect_1)

추가된 버전: v0.7.0

-   `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage) HTTP 요청에 대한 인자로, [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트와 동일합니다.
-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 서버와 클라이언트 간의 네트워크 소켓입니다.
-   `head` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) 터널링 스트림의 첫 번째 패킷(비어 있을 수 있음)입니다.

클라이언트가 HTTP `CONNECT` 메서드를 요청할 때마다 이 이벤트가 발생합니다. 이 이벤트를 리스닝하지 않으면, `CONNECT` 메서드를 요청한 클라이언트의 연결이 종료됩니다.

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 서브클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 전달받는 것이 보장됩니다.

이 이벤트가 발생한 후, 요청의 소켓에는 `'data'` 이벤트 리스너가 없으므로, 해당 소켓으로 서버에 전송된 데이터를 처리하려면 리스너를 바인딩해야 합니다.


#### 이벤트: `'connection'`[#](https://nodejs.org/docs/latest/api/http.html#event-connection)

추가된 버전: v0.1.0

-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 이벤트는 새로운 TCP 스트림이 생성될 때 발생합니다. `socket`은 일반적으로 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 타입의 객체입니다. 보통 사용자들은 이 이벤트에 접근할 필요가 없습니다. 특히, 프로토콜 파서가 소켓에 연결되는 방식 때문에 소켓은 `'readable'` 이벤트를 발생시키지 않습니다. `socket`은 `request.socket`에서도 접근할 수 있습니다.

이 이벤트는 사용자가 HTTP 서버에 연결을 주입하기 위해 명시적으로 발생시킬 수도 있습니다. 이 경우, 어떤 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림이든 전달할 수 있습니다.

여기서 `socket.setTimeout()`을 호출하면, 소켓이 요청을 처리한 후 `server.keepAliveTimeout`으로 타임아웃이 대체됩니다 (`server.keepAliveTimeout`이 0이 아닌 경우).

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스가 전달되는 것이 보장됩니다.


#### 이벤트: `'dropRequest'`[#](https://nodejs.org/docs/latest/api/http.html#event-droprequest)

추가된 버전: v18.7.0, v16.17.0

-   `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage) HTTP 요청에 대한 인자로, [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트와 동일합니다.
-   `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 서버와 클라이언트 간의 네트워크 소켓입니다.

소켓 상의 요청 수가 `server.maxRequestsPerSocket` 임계값에 도달하면, 서버는 새로운 요청을 거부하고 `'dropRequest'` 이벤트를 발생시킨 후 클라이언트에게 `503` 상태 코드를 보냅니다.


#### 이벤트: `'request'`[#](https://nodejs.org/docs/latest/api/http.html#event-request)

추가된 버전: v0.1.0

-   `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)
-   `response` [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

요청이 있을 때마다 발생하는 이벤트입니다. HTTP Keep-Alive 연결의 경우, 하나의 연결에 여러 요청이 있을 수 있습니다.


#### 이벤트: `'upgrade'`

- `request` [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)  
  HTTP 요청에 대한 인자로, [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트와 동일합니다.
  
- `socket` [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)  
  서버와 클라이언트 간의 네트워크 소켓입니다.
  
- `head` [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer)  
  업그레이드된 스트림의 첫 번째 패킷입니다. (비어 있을 수도 있습니다.)

이 이벤트는 클라이언트가 HTTP 업그레이드를 요청할 때마다 발생합니다. 이 이벤트를 수신하는 것은 선택 사항이며, 클라이언트는 프로토콜 변경을 강제할 수 없습니다.

이 이벤트가 발생한 후, 요청의 소켓에는 `'data'` 이벤트 리스너가 없습니다. 따라서 해당 소켓으로 서버에 전송된 데이터를 처리하려면 리스너를 직접 바인딩해야 합니다.

이 이벤트는 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스를 전달받는 것이 보장됩니다.


#### `server.close([callback])`[#](https://nodejs.org/docs/latest/api/http.html#serverclosecallback)

-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

서버가 새로운 연결을 받지 못하도록 중단하고, 요청을 보내거나 응답을 기다리지 않는 모든 연결을 닫습니다. 자세한 내용은 [`net.Server.close()`](https://nodejs.org/docs/latest/api/net.html#serverclosecallback)를 참조하세요.

```js
const http = require('node:http');

const server = http.createServer({ keepAliveTimeout: 60000 }, (req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ data: 'Hello World!' }));
});

server.listen(8000);

// 10초 후 서버를 닫음
setTimeout(() => {
    server.close(() => {
        console.log('포트 8000의 서버가 성공적으로 닫혔습니다.');
    });
}, 10000);
```


#### `server.closeAllConnections()`[#](https://nodejs.org/docs/latest/api/http.html#servercloseallconnections)

추가된 버전: v18.2.0

이 메서드는 서버에 연결된 모든 HTTP(S) 연결을 강제로 종료합니다. 이는 요청을 보내거나 응답을 기다리는 활성 연결도 포함됩니다. 단, WebSocket이나 HTTP/2와 같이 다른 프로토콜로 업그레이드된 소켓은 종료하지 않습니다.

> 이 메서드는 모든 연결을 강제로 닫는 방식이므로 주의해서 사용해야 합니다. `server.close`와 함께 사용할 때는, `server.close`를 먼저 호출한 후 이 메서드를 호출하는 것이 좋습니다. 이렇게 하면 `server.closeAllConnections`와 `server.close` 사이에 새로운 연결이 생성되는 경쟁 상태를 방지할 수 있습니다.

```js
const http = require('node:http');

const server = http.createServer({ keepAliveTimeout: 60000 }, (req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ data: 'Hello World!' }));
});

server.listen(8000);

// 10초 후 서버를 종료
setTimeout(() => {
    server.close(() => {
        console.log('server on port 8000 closed successfully');
    });

    // 모든 연결을 종료하여 서버가 성공적으로 닫히도록 보장
    server.closeAllConnections();
}, 10000);
```


#### `server.closeIdleConnections()`[#](https://nodejs.org/docs/latest/api/http.html#servercloseidleconnections)

추가된 버전: v18.2.0

이 메서드는 현재 요청을 보내지 않거나 응답을 기다리지 않는 모든 연결을 닫습니다.

> Node.js 19.0.0부터는 `keep-alive` 연결을 정리하기 위해 이 메서드를 `server.close`와 함께 호출할 필요가 없습니다. 하지만 이 메서드를 사용해도 문제는 없으며, 19.0.0 이전 버전을 지원해야 하는 라이브러리나 애플리케이션에서 역호환성을 보장하기 위해 유용할 수 있습니다. 이 메서드를 `server.close`와 함께 사용할 때는, `server.close`를 호출한 *후에* 이 메서드를 호출하는 것이 좋습니다. 이렇게 하면 `server.close` 호출과 이 메서드 호출 사이에 새로운 연결이 생성되는 경쟁 상태를 방지할 수 있습니다.

```js
const http = require('node:http');

const server = http.createServer({ keepAliveTimeout: 60000 }, (req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ data: 'Hello World!' }));
});

server.listen(8000);

// 10초 후 서버를 닫음
setTimeout(() => {
    server.close(() => {
        console.log('server on port 8000 closed successfully');
    });

    // keep-alive 연결과 같은 유휴 연결을 닫음.
    // 남아 있는 활성 연결이 종료되면 서버가 닫힘
    server.closeIdleConnections();
}, 10000);
```


#### `server.headersTimeout`

- **[`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)**  
  **기본값:** [`server.requestTimeout`](https://nodejs.org/docs/latest/api/http.html#serverrequesttimeout)과 `60000` 중 더 작은 값

이 설정은 HTTP 헤더를 완전히 받기 위해 파서가 기다리는 시간을 제한합니다.

타임아웃이 만료되면, 서버는 요청을 리스너로 전달하지 않고 상태 코드 408로 응답한 후 연결을 닫습니다.

서버가 리버스 프록시 없이 배포된 경우, 잠재적인 서비스 거부 공격(Denial-of-Service)을 방지하기 위해 이 값을 0이 아닌 값(예: 120초)으로 설정해야 합니다.


#### `server.listen()`[#](https://nodejs.org/docs/latest/api/http.html#serverlisten)

HTTP 서버가 연결을 기다리기 시작합니다. 이 메서드는 [`net.Server`](https://nodejs.org/docs/latest/api/net.html#class-netserver)의 [`server.listen()`](https://nodejs.org/docs/latest/api/net.html#serverlisten)과 동일합니다.


#### `server.listening`[#](https://nodejs.org/docs/latest/api/http.html#serverlistening)

추가된 버전: v5.7.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 서버가 연결을 수신 중인지 여부를 나타냅니다.


#### `server.maxHeadersCount`[#](https://nodejs.org/docs/latest/api/http.html#servermaxheaderscount)

추가된 버전: v0.7.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `2000`

들어오는 헤더의 최대 개수를 제한합니다. 값을 0으로 설정하면 제한이 적용되지 않습니다.


#### `server.requestTimeout`[#](https://nodejs.org/docs/latest/api/http.html#serverrequesttimeout)

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `300000`

클라이언트로부터 전체 요청을 받는 데 걸리는 시간 제한을 밀리초 단위로 설정합니다.

시간 제한이 만료되면, 서버는 요청을 리스너로 전달하지 않고 상태 코드 408로 응답한 후 연결을 종료합니다.

이 값은 반드시 0이 아닌 값(예: 120초)으로 설정해야 합니다. 이는 서버가 리버스 프록시 없이 배포된 경우 발생할 수 있는 서비스 거부 공격(Denial-of-Service)을 방지하기 위함입니다.


#### `server.setTimeout([msecs][, callback])`[#](https://nodejs.org/docs/latest/api/http.html#serversettimeoutmsecs-callback)

-   `msecs` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** 0 (타임아웃 없음)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<http.Server>`](https://nodejs.org/docs/latest/api/http.html#class-httpserver)

소켓의 타임아웃 값을 설정합니다. 타임아웃이 발생하면 Server 객체에서 `'timeout'` 이벤트를 발생시키고, 소켓을 인자로 전달합니다.

Server 객체에 `'timeout'` 이벤트 리스너가 등록되어 있다면, 타임아웃이 발생한 소켓을 인자로 받아 호출됩니다.

기본적으로 Server는 소켓에 타임아웃을 설정하지 않습니다. 하지만 Server의 `'timeout'` 이벤트에 콜백 함수가 할당된 경우, 타임아웃을 명시적으로 처리해야 합니다.


#### `server.maxRequestsPerSocket`[#](https://nodejs.org/docs/latest/api/http.html#servermaxrequestspersocket)

**추가된 버전:** v16.10.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 소켓당 요청 수. **기본값:** 0 (제한 없음)

이 옵션은 소켓이 keep alive 연결을 종료하기 전에 처리할 수 있는 최대 요청 수를 설정합니다.

값이 `0`이면 제한이 없음을 의미합니다.

제한에 도달하면 `Connection` 헤더 값을 `close`로 설정하지만, 실제로 연결을 종료하지는 않습니다. 제한에 도달한 후에 보내진 요청은 `503 Service Unavailable` 응답을 받게 됩니다.


#### `server.timeout`[#](https://nodejs.org/docs/latest/api/http.html#servertimeout)

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 밀리초 단위의 타임아웃. **기본값:** 0 (타임아웃 없음)

소켓이 타임아웃된 것으로 간주되기 전까지의 비활성 시간을 밀리초 단위로 설정합니다.

값이 `0`이면 들어오는 연결에 대한 타임아웃 동작을 비활성화합니다.

소켓 타임아웃 로직은 연결 시점에 설정되므로, 이 값을 변경하면 서버에 새로 들어오는 연결에만 영향을 미치고 기존 연결에는 영향을 주지 않습니다.


#### `server.keepAliveTimeout`[#](https://nodejs.org/docs/latest/api/http.html#serverkeepalivetimeout)

추가된 버전: v8.0.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 밀리초 단위의 타임아웃. **기본값:** `5000` (5초).

서버가 마지막 응답을 완료한 후, 추가로 들어오는 데이터를 기다리는 동안 비활성 상태로 유지되는 시간(밀리초)입니다. 이 시간이 지나면 소켓이 종료됩니다. 만약 서버가 keep-alive 타임아웃이 발생하기 전에 새로운 데이터를 받으면, 일반적인 비활성 타임아웃(예: [`server.timeout`](https://nodejs.org/docs/latest/api/http.html#servertimeout))이 재설정됩니다.

값이 `0`이면 들어오는 연결에 대해 keep-alive 타임아웃 동작이 비활성화됩니다. 이 값은 Node.js 8.0.0 이전 버전과 유사하게 동작하게 하며, 이전 버전에는 keep-alive 타임아웃이 없었습니다.

소켓 타임아웃 로직은 연결 시점에 설정되므로, 이 값을 변경하면 서버에 새로 연결되는 연결에만 영향을 미치고, 기존 연결에는 영향을 주지 않습니다.


#### `server[Symbol.asyncDispose]()`[#](https://nodejs.org/docs/latest/api/http.html#serversymbolasyncdispose)

추가된 버전: v20.4.0

`server[Symbol.asyncDispose]()`는 [`server.close()`](https://nodejs.org/docs/latest/api/http.html#serverclosecallback)를 호출하고, 서버가 닫힐 때 이행되는 Promise를 반환합니다.


### 클래스: `http.ServerResponse`[#](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

추가된 버전: v0.1.17

-   상속: [`<http.OutgoingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpoutgoingmessage)

이 객체는 HTTP 서버에 의해 내부적으로 생성되며, 사용자가 직접 생성하지 않습니다. 이 객체는 [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트의 두 번째 인자로 전달됩니다.


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/http.html#event-close_2)

추가된 버전: v0.6.7

이 이벤트는 응답이 완료되었거나, 응답 완료 전에 기본 연결이 조기에 종료되었음을 나타냅니다.


#### 이벤트: `'finish'`[#](https://nodejs.org/docs/latest/api/http.html#event-finish_1)

추가된 버전: v0.3.6

이 이벤트는 응답이 전송되었을 때 발생합니다. 좀 더 구체적으로 말하면, 응답 헤더와 본문의 마지막 부분이 네트워크를 통해 전송되도록 운영체제에 넘겨졌을 때 이 이벤트가 발생합니다. 이 이벤트는 클라이언트가 아무것도 받았다는 것을 의미하지는 않습니다.


#### `response.addTrailers(headers)`[#](https://nodejs.org/docs/latest/api/http.html#responseaddtrailersheaders)

추가된 버전: v0.3.0

-   `headers` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 메서드는 HTTP 트레일러 헤더(메시지의 끝에 위치하는 헤더)를 응답에 추가합니다.

트레일러는 **오직** 응답에 청크 인코딩이 사용될 때만 전송됩니다. 청크 인코딩이 사용되지 않는 경우(예: HTTP/1.0 요청), 트레일러는 조용히 무시됩니다.

HTTP는 트레일러를 전송하기 위해 `Trailer` 헤더를 보내야 하며, 이 헤더의 값에는 트레일러 헤더 필드 목록이 포함되어야 합니다. 예를 들면 다음과 같습니다.

```js
response.writeHead(200, { 'Content-Type': 'text/plain', 'Trailer': 'Content-MD5' });
response.write(fileData);
response.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });
response.end();
```

헤더 필드 이름이나 값에 유효하지 않은 문자가 포함된 경우, [`TypeError`](https://nodejs.org/docs/latest/api/errors.html#class-typeerror)가 발생합니다.


#### `response.connection`[#](https://nodejs.org/docs/latest/api/http.html#responseconnection)

추가된 버전: v0.3.0  
사용 중단(deprecated) 버전: v13.0.0

-   [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

자세한 내용은 [`response.socket`](https://nodejs.org/docs/latest/api/http.html#responsesocket)을 참고하세요.


#### `response.cork()`[#](https://nodejs.org/docs/latest/api/http.html#responsecork)

추가된 버전: v13.2.0, v12.16.0

[`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork)를 참고하세요.


#### `response.end([data[, encoding]][, callback])`[#](https://nodejs.org/docs/latest/api/http.html#responseenddata-encoding-callback)

-   `data` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   Returns: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

이 메서드는 서버에 응답 헤더와 본문이 모두 전송되었음을 알립니다. 서버는 이 메시지를 완료된 것으로 간주합니다. `response.end()` 메서드는 모든 응답에서 반드시 호출되어야 합니다.

`data`가 지정되면, [`response.write(data, encoding)`](https://nodejs.org/docs/latest/api/http.html#responsewritechunk-encoding-callback)을 호출한 후 `response.end(callback)`을 호출하는 것과 같은 효과를 가집니다.

`callback`이 지정되면, 응답 스트림이 완료될 때 호출됩니다.


#### `response.finished`[#](https://nodejs.org/docs/latest/api/http.html#responsefinished)

추가된 버전: v0.0.2  
사용 중단(deprecated)된 버전: v13.4.0, v12.16.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`response.finished` 속성은 [`response.end()`](https://nodejs.org/docs/latest/api/http.html#responseenddata-encoding-callback)가 호출된 경우 `true`가 됩니다.


#### `response.flushHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#responseflushheaders)

추가된 버전: v1.6.0

이 메서드는 응답 헤더를 즉시 전송합니다. 관련 메서드로는 [`request.flushHeaders()`](https://nodejs.org/docs/latest/api/http.html#requestflushheaders)가 있습니다.


#### `response.getHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#responsegetheadername)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

클라이언트에게 아직 전송되지 않은 대기 중인 헤더를 읽어옵니다. 헤더 이름은 대소문자를 구분하지 않습니다. 반환값의 타입은 [`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)에 제공된 인자에 따라 결정됩니다.

```js
response.setHeader('Content-Type', 'text/html');
response.setHeader('Content-Length', Buffer.byteLength(body));
response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);

const contentType = response.getHeader('content-type'); // contentType은 'text/html'
const contentLength = response.getHeader('Content-Length'); // contentLength는 number 타입
const setCookie = response.getHeader('set-cookie'); // setCookie는 string[] 타입
```


#### `response.getHeaderNames()`[#](https://nodejs.org/docs/latest/api/http.html#responsegetheadernames)

추가된 버전: v7.7.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

현재 전송 중인 헤더의 고유한 이름들을 배열로 반환합니다. 모든 헤더 이름은 소문자로 표시됩니다.

```js
response.setHeader('Foo', 'bar');
response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
const headerNames = response.getHeaderNames();
// headerNames === ['foo', 'set-cookie']
```


#### `response.getHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#responsegetheaders)

추가된 버전: v7.7.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

현재 전송 중인 헤더의 얕은 복사본을 반환합니다. 얕은 복사가 사용되므로, 배열 값은 다양한 헤더 관련 http 모듈 메서드를 추가로 호출하지 않고도 변경될 수 있습니다. 반환된 객체의 키는 헤더 이름이고, 값은 해당 헤더 값입니다. 모든 헤더 이름은 소문자로 표시됩니다.

`response.getHeaders()` 메서드가 반환하는 객체는 JavaScript `Object`로부터 프로토타입 상속을 받지 않습니다. 이는 `obj.toString()`, `obj.hasOwnProperty()`와 같은 일반적인 `Object` 메서드가 정의되지 않으며 **작동하지 않는다**는 것을 의미합니다.

```js
response.setHeader('Foo', 'bar');
response.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
const headers = response.getHeaders();
// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
```


#### `response.hasHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#responsehasheadername)

추가된 버전: v7.7.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`name`으로 식별된 헤더가 현재 전송 중인 헤더에 설정되어 있으면 `true`를 반환합니다. 헤더 이름은 대소문자를 구분하지 않습니다.

```js
const hasContentType = response.hasHeader('content-type');
```


#### `response.headersSent`[#](https://nodejs.org/docs/latest/api/http.html#responseheaderssent)

추가된 버전: v0.9.3

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

불리언 타입(읽기 전용). 헤더가 전송되었으면 `true`, 그렇지 않으면 `false`를 반환합니다.


#### `response.removeHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#responseremoveheadername)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

암시적으로 전송되기 위해 대기 중인 헤더를 제거합니다.

```js
response.removeHeader('Content-Encoding');
```


#### `response.req`[#](https://nodejs.org/docs/latest/api/http.html#responsereq)

추가된 버전: v15.7.0

- [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)

원본 HTTP `request` 객체에 대한 참조입니다.


#### `response.sendDate`[#](https://nodejs.org/docs/latest/api/http.html#responsesenddate)

추가된 버전: v0.7.5

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 값이 `true`로 설정되면, 응답 헤더에 `Date` 헤더가 없을 경우 자동으로 생성되어 전송됩니다. 기본값은 `true`입니다.

이 기능은 테스트 목적으로만 비활성화해야 합니다. HTTP 표준에 따르면 응답에 `Date` 헤더가 포함되어야 합니다.


#### `response.setHeader(name, value)`[#](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)
-   반환값: [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

응답 객체를 반환합니다.

암시적 헤더에 대한 단일 헤더 값을 설정합니다. 이미 전송될 헤더에 해당 헤더가 존재한다면, 그 값이 대체됩니다. 동일한 이름으로 여러 헤더를 보내려면 문자열 배열을 사용합니다. 문자열이 아닌 값은 수정 없이 저장됩니다. 따라서 [`response.getHeader()`](https://nodejs.org/docs/latest/api/http.html#responsegetheadername)는 문자열이 아닌 값을 반환할 수 있습니다. 하지만, 문자열이 아닌 값은 네트워크 전송을 위해 문자열로 변환됩니다. 호출 체이닝을 가능하게 하기 위해 동일한 응답 객체가 호출자에게 반환됩니다.

```js
response.setHeader('Content-Type', 'text/html');
```

또는

```js
response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
```

헤더 필드 이름이나 값에 유효하지 않은 문자가 포함되어 있다면 [`TypeError`](https://nodejs.org/docs/latest/api/errors.html#class-typeerror)가 발생합니다.

[`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)로 헤더를 설정한 후, [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더와 병합됩니다. 이때 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더가 우선순위를 가집니다.

```js
// content-type = text/plain 반환
const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('ok');
});
```

[`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers) 메서드가 호출되었고 이 메서드가 호출되지 않았다면, 제공된 헤더 값을 내부적으로 캐싱하지 않고 네트워크 채널에 직접 기록합니다. 이 경우 [`response.getHeader()`](https://nodejs.org/docs/latest/api/http.html#responsegetheadername)를 사용해 헤더를 조회하면 예상한 결과를 얻을 수 없습니다. 헤더를 점진적으로 채우고 나중에 검색 및 수정할 가능성이 있다면, [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers) 대신 [`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)를 사용하세요.


#### `response.setTimeout(msecs[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#responsesettimeoutmsecs-callback)

추가된 버전: v0.9.12

-   `msecs` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

소켓의 타임아웃 값을 `msecs`로 설정합니다. 콜백이 제공되면, 이 콜백은 응답 객체의 `'timeout'` 이벤트에 리스너로 추가됩니다.

요청, 응답, 또는 서버에 `'timeout'` 리스너가 추가되지 않으면, 소켓은 타임아웃 시 자동으로 파괴됩니다. 만약 요청, 응답, 또는 서버의 `'timeout'` 이벤트에 핸들러가 할당되었다면, 타임아웃된 소켓은 명시적으로 처리해야 합니다.


#### `response.socket`

추가된 버전: v0.3.0

- [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 속성은 기본 소켓을 참조합니다. 일반적으로 사용자가 이 속성에 접근할 필요는 없습니다. 특히, 프로토콜 파서가 소켓에 연결되는 방식 때문에 소켓은 `'readable'` 이벤트를 발생시키지 않습니다. `response.end()` 이후에는 이 속성이 `null`로 설정됩니다.

```js
import http from 'node:http';

const server = http.createServer((req, res) => {
    const ip = res.socket.remoteAddress;
    const port = res.socket.remotePort;
    res.end(`Your IP address is ${ip} and your source port is ${port}.`);
}).listen(3000);
```

이 속성은 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하지 않는 한, [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 서브클래스인 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)의 인스턴스임이 보장됩니다.


#### `response.statusCode`[#](https://nodejs.org/docs/latest/api/http.html#responsestatuscode)

추가된 버전: v0.4.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `200`

명시적으로 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)를 호출하지 않고 암시적 헤더를 사용할 때, 이 속성은 헤더가 전송될 때 클라이언트에게 보낼 상태 코드를 제어합니다.

```js
response.statusCode = 404;
```

응답 헤더가 클라이언트에게 전송된 후, 이 속성은 전송된 상태 코드를 나타냅니다.


#### `response.statusMessage`[#](https://nodejs.org/docs/latest/api/http.html#responsestatusmessage)

추가된 버전: v0.11.8

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

암시적 헤더를 사용할 때 (즉, [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)를 명시적으로 호출하지 않을 때), 이 속성은 헤더가 클라이언트로 전송될 때 보낼 상태 메시지를 제어합니다. 이 속성이 `undefined`로 남아 있으면, 상태 코드에 따른 표준 메시지가 사용됩니다.

```js
response.statusMessage = 'Not found';
```

응답 헤더가 클라이언트로 전송된 후, 이 속성은 전송된 상태 메시지를 나타냅니다.


#### `response.strictContentLength`[#](https://nodejs.org/docs/latest/api/http.html#responsestrictcontentlength)

추가된 버전: v18.10.0, v16.18.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) **기본값:** `false`

이 값을 `true`로 설정하면, Node.js는 `Content-Length` 헤더 값과 본문의 크기(바이트 단위)가 일치하는지 확인합니다. `Content-Length` 헤더 값이 일치하지 않을 경우, `code:` [`'ERR_HTTP_CONTENT_LENGTH_MISMATCH'`](https://nodejs.org/docs/latest/api/errors.html#err_http_content_length_mismatch)로 식별되는 `Error`가 발생합니다.


#### `response.uncork()`[#](https://nodejs.org/docs/latest/api/http.html#responseuncork)

추가된 버전: v13.2.0, v12.16.0

[`writable.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork)를 참고하세요.


#### `response.writableEnded`[#](https://nodejs.org/docs/latest/api/http.html#responsewritableended)

v12.9.0 버전에서 추가됨

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`response.end()`가 호출된 후 `true`가 됩니다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다. 이를 확인하려면 `response.writableFinished`를 사용하세요.


#### `response.writableFinished`[#](https://nodejs.org/docs/latest/api/http.html#responsewritablefinished)

추가된 버전: v12.7.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 값은 모든 데이터가 하위 시스템으로 플러시된 직후, [`'finish'`](https://nodejs.org/docs/latest/api/http.html#event-finish) 이벤트가 발생하기 전에 `true`가 됩니다.


#### `response.write(chunk[, encoding][, callback])`

- `chunk` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
- `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값:** `'utf8'`
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
- 반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드를 호출할 때 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)가 아직 호출되지 않았다면, 암시적 헤더 모드로 전환되고 암시적 헤더를 전송합니다.

이 메서드는 응답 본문의 일부를 전송합니다. 본문의 연속적인 부분을 제공하기 위해 여러 번 호출할 수 있습니다.

`createServer`에서 `rejectNonStandardBodyWrites`를 `true`로 설정한 경우, 요청 메서드나 응답 상태가 콘텐츠를 지원하지 않을 때 본문에 쓰는 것이 허용되지 않습니다. HEAD 요청이나 `204` 또는 `304` 응답의 일부로 본문에 쓰려고 시도하면, `ERR_HTTP_BODY_NOT_ALLOWED` 코드와 함께 동기적인 `Error`가 발생합니다.

`chunk`는 문자열이나 버퍼일 수 있습니다. `chunk`가 문자열인 경우, 두 번째 매개변수는 이를 바이트 스트림으로 인코딩하는 방법을 지정합니다. `callback`은 이 데이터 청크가 전송될 때 호출됩니다.

이는 원시 HTTP 본문이며, 더 높은 수준의 멀티파트 본문 인코딩과는 관련이 없습니다.

[`response.write()`](https://nodejs.org/docs/latest/api/http.html#responsewritechunk-encoding-callback)가 처음 호출되면, 버퍼링된 헤더 정보와 본문의 첫 번째 청크를 클라이언트에게 전송합니다. 두 번째로 [`response.write()`](https://nodejs.org/docs/latest/api/http.html#responsewritechunk-encoding-callback)가 호출되면, Node.js는 데이터가 스트리밍될 것이라고 가정하고 새로운 데이터를 별도로 전송합니다. 즉, 응답은 본문의 첫 번째 청크까지 버퍼링됩니다.

모든 데이터가 커널 버퍼로 성공적으로 전송되면 `true`를 반환합니다. 데이터의 일부 또는 전체가 사용자 메모리에 대기 중이면 `false`를 반환합니다. 버퍼가 다시 비워지면 `'drain'` 이벤트가 발생합니다.


#### `response.writeContinue()`[#](https://nodejs.org/docs/latest/api/http.html#responsewritecontinue)

추가된 버전: v0.3.0

클라이언트에게 HTTP/1.1 100 Continue 메시지를 보내어 요청 본문을 전송해야 함을 알립니다. 이는 `Server`의 [`'checkContinue'`](https://nodejs.org/docs/latest/api/http.html#event-checkcontinue) 이벤트와 관련이 있습니다.


#### `response.writeEarlyHints(hints[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#responsewriteearlyhintshints-callback)

-   `hints` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)

클라이언트에게 HTTP/1.1 103 Early Hints 메시지를 보내며, Link 헤더를 통해 사용자 에이전트가 연결된 리소스를 미리 로드하거나 연결할 수 있음을 알립니다. `hints`는 Early Hints 메시지와 함께 보낼 헤더 값을 포함하는 객체입니다. 선택적 인자인 `callback`은 응답 메시지가 작성된 후 호출됩니다.

**예제**

```js
const earlyHintsLink = '; rel=preload; as=style';
response.writeEarlyHints({
    'link': earlyHintsLink,
});

const earlyHintsLinks = [
    '; rel=preload; as=style',
    '; rel=preload; as=script',
];
response.writeEarlyHints({
    'link': earlyHintsLinks,
    'x-trace-id': 'id for diagnostics',
});

const earlyHintsCallback = () => console.log('early hints message sent');
response.writeEarlyHints({
    'link': earlyHintsLinks,
}, earlyHintsCallback);
```


#### `response.writeHead(statusCode[, statusMessage][, headers])`

- `statusCode` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
- `statusMessage` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `headers` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) | [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
- 반환값: [`<http.ServerResponse>`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)

이 메서드는 요청에 대한 응답 헤더를 보냅니다. `statusCode`는 `404`와 같은 3자리 HTTP 상태 코드입니다. 마지막 인자인 `headers`는 응답 헤더를 나타냅니다. 선택적으로 두 번째 인자로 사람이 읽을 수 있는 `statusMessage`를 제공할 수 있습니다.

`headers`는 키와 값이 같은 리스트에 있는 `Array`일 수 있습니다. 이는 튜플 리스트가 아닙니다. 따라서 짝수 인덱스는 키 값이고, 홀수 인덱스는 해당 값입니다. 이 배열은 `request.rawHeaders`와 같은 형식을 따릅니다.

이 메서드는 `ServerResponse`에 대한 참조를 반환하므로, 메서드 체이닝이 가능합니다.

```js
const body = 'hello world';
response
  .writeHead(200, {
    'Content-Length': Buffer.byteLength(body),
    'Content-Type': 'text/plain',
  })
  .end(body);
```

이 메서드는 메시지당 한 번만 호출해야 하며, [`response.end()`](https://nodejs.org/docs/latest/api/http.html#responseenddata-encoding-callback)가 호출되기 전에 호출되어야 합니다.

만약 [`response.write()`](https://nodejs.org/docs/latest/api/http.html#responsewritechunk-encoding-callback)나 [`response.end()`](https://nodejs.org/docs/latest/api/http.html#responseenddata-encoding-callback)가 이 메서드보다 먼저 호출되면, 암시적/변경 가능한 헤더가 계산되고 이 함수가 호출됩니다.

[`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)로 헤더가 설정된 경우, 이 헤더는 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더와 병합되며, [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더가 우선순위를 가집니다.

이 메서드가 호출되고 [`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)가 호출되지 않은 경우, 제공된 헤더 값이 내부적으로 캐시되지 않고 네트워크 채널에 직접 기록됩니다. 따라서 [`response.getHeader()`](https://nodejs.org/docs/latest/api/http.html#responsegetheadername)를 호출해도 예상한 결과를 얻을 수 없습니다. 헤더를 점진적으로 채우고 나중에 검색 및 수정할 가능성이 있다면, 대신 [`response.setHeader()`](https://nodejs.org/docs/latest/api/http.html#responsesetheadername-value)를 사용하세요.

```js
// content-type = text/plain을 반환합니다.
const server = http.createServer((req, res) => {
  res.setHeader('Content-Type', 'text/html');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('ok');
});
```

`Content-Length`는 문자 단위가 아닌 바이트 단위로 읽힙니다. [`Buffer.byteLength()`](https://nodejs.org/docs/latest/api/buffer.html#static-method-bufferbytelengthstring-encoding)를 사용해 본문의 길이를 바이트 단위로 확인하세요. Node.js는 `Content-Length`와 전송된 본문의 길이가 일치하는지 확인합니다.

헤더 필드 이름이나 값에 유효하지 않은 문자가 포함된 경우, \[`Error`\]\[\]가 발생합니다.


#### `response.writeProcessing()`[#](https://nodejs.org/docs/latest/api/http.html#responsewriteprocessing)

**추가된 버전:** v10.0.0

클라이언트에게 HTTP/1.1 102 Processing 메시지를 보내어, 요청 본문을 전송해야 함을 알립니다.

```javascript
response.writeProcessing();
```

이 메서드는 서버가 클라이언트에게 요청을 처리 중임을 알릴 때 사용됩니다. HTTP/1.1 102 상태 코드는 서버가 요청을 받았고, 아직 완료되지 않았음을 나타냅니다. 이를 통해 클라이언트는 요청이 처리 중임을 인지하고, 추가 데이터를 전송할 수 있습니다.


### 클래스: `http.IncomingMessage`[#](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)

-   상속: [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)

`IncomingMessage` 객체는 [`http.Server`](https://nodejs.org/docs/latest/api/http.html#class-httpserver) 또는 [`http.ClientRequest`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)에 의해 생성되며, 각각 [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request)와 [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트의 첫 번째 인자로 전달됩니다. 이 객체는 응답 상태, 헤더, 데이터에 접근하는 데 사용됩니다.

`IncomingMessage`는 [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스인 `socket` 값과 달리, [`<stream.Readable>`](https://nodejs.org/docs/latest/api/stream.html#class-streamreadable)을 상속받습니다. 이 객체는 들어오는 HTTP 헤더와 페이로드를 파싱하고 내보내기 위해 별도로 생성됩니다. 이는 keep-alive 상황에서 기본 소켓이 여러 번 재사용될 수 있기 때문입니다.


#### 이벤트: `'aborted'`[#](https://nodejs.org/docs/latest/api/http.html#event-aborted)

추가된 버전: v0.3.8  
더 이상 사용되지 않음: v17.0.0, v16.12.0

[안정성: 0](https://nodejs.org/docs/latest/api/documentation.html#stability-index) - 더 이상 사용되지 않음. 대신 `'close'` 이벤트를 사용하세요.

이 이벤트는 요청이 중단되었을 때 발생합니다.


#### 이벤트: `'close'`[#](https://nodejs.org/docs/latest/api/http.html#event-close_3)

이 이벤트는 요청이 완료되었을 때 발생합니다.


#### `message.aborted`[#](https://nodejs.org/docs/latest/api/http.html#messageaborted)

추가된 버전: v10.1.0  
사용 중단된 버전: v17.0.0, v16.12.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`message.aborted` 속성은 요청이 중단된 경우 `true` 값을 가집니다.


#### `message.complete`[#](https://nodejs.org/docs/latest/api/http.html#messagecomplete)

추가된 버전: v0.3.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`message.complete` 속성은 완전한 HTTP 메시지가 수신되고 성공적으로 파싱되었을 때 `true`가 됩니다.

이 속성은 클라이언트나 서버가 연결이 종료되기 전에 메시지를 완전히 전송했는지 확인하는 데 특히 유용합니다:

```js
const req = http.request(
    { 
        host: '127.0.0.1', 
        port: 8080, 
        method: 'POST', 
    }, 
    (res) => { 
        res.resume(); 
        res.on('end', () => { 
            if (!res.complete) 
                console.error('메시지가 전송 중일 때 연결이 종료되었습니다'); 
        }); 
    }
);
```


#### `message.connection`[#](https://nodejs.org/docs/latest/api/http.html#messageconnection)

추가된 버전: v0.1.90  
더 이상 사용되지 않음: v16.0.0부터

[`message.socket`](https://nodejs.org/docs/latest/api/http.html#messagesocket)의 별칭입니다.


#### `message.destroy([error])`[#](https://nodejs.org/docs/latest/api/http.html#messagedestroyerror)

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error)
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

`IncomingMessage`를 받은 소켓에서 `destroy()`를 호출합니다. `error`가 제공되면, 소켓에서 `'error'` 이벤트가 발생하고, `error`는 이벤트 리스너에게 인자로 전달됩니다.


#### `message.headers`[#](https://nodejs.org/docs/latest/api/http.html#messageheaders)

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

요청/응답 헤더 객체입니다.

헤더 이름과 값으로 이루어진 키-값 쌍입니다. 헤더 이름은 소문자로 변환됩니다.

```js
// 다음과 같은 형태로 출력됩니다:
// { 'user-agent': 'curl/7.22.0',
//   host: '127.0.0.1:8000',
//   accept: '*/*' }
console.log(request.headers);
```

원시 헤더에서 중복된 값은 헤더 이름에 따라 다음과 같이 처리됩니다:

- `age`, `authorization`, `content-length`, `content-type`, `etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`, `last-modified`, `location`, `max-forwards`, `proxy-authorization`, `referer`, `retry-after`, `server`, `user-agent`와 같은 헤더의 중복 값은 무시됩니다. 위에 나열된 헤더의 중복 값을 연결하려면 [`http.request()`](https://nodejs.org/docs/latest/api/http.html#httprequestoptions-callback)와 [`http.createServer()`](https://nodejs.org/docs/latest/api/http.html#httpcreateserveroptions-requestlistener)에서 `joinDuplicateHeaders` 옵션을 사용하세요. 자세한 내용은 RFC 9110 Section 5.3을 참고하세요.
- `set-cookie`는 항상 배열입니다. 중복된 값은 배열에 추가됩니다.
- 중복된 `cookie` 헤더의 값은 `;`로 연결됩니다.
- 다른 모든 헤더의 값은 `,`로 연결됩니다.


#### `message.headersDistinct`[#](https://nodejs.org/docs/latest/api/http.html#messageheadersdistinct)

추가된 버전: v18.3.0, v16.17.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

[`message.headers`](https://nodejs.org/docs/latest/api/http.html#messageheaders)와 유사하지만, 여기서는 값들을 합치는 로직이 없고, 한 번만 받은 헤더라도 항상 문자열 배열로 반환됩니다.

```js
// 다음과 같은 결과를 출력합니다:
// { 'user-agent': ['curl/7.22.0'], 
//   host: ['127.0.0.1:8000'], 
//   accept: ['*/*'] }
console.log(request.headersDistinct);
```


#### `message.httpVersion`[#](https://nodejs.org/docs/latest/api/http.html#messagehttpversion)

추가된 버전: v0.1.1

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

서버 요청의 경우, 클라이언트가 보낸 HTTP 버전을 나타냅니다. 클라이언트 응답의 경우, 연결된 서버의 HTTP 버전을 나타냅니다. 주로 `'1.1'` 또는 `'1.0'` 중 하나입니다.

또한 `message.httpVersionMajor`는 첫 번째 정수이고, `message.httpVersionMinor`는 두 번째 정수입니다.


#### `message.method`[#](https://nodejs.org/docs/latest/api/http.html#messagemethod)

추가된 버전: v0.1.1

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

**이 속성은 [`http.Server`](https://nodejs.org/docs/latest/api/http.html#class-httpserver)에서 얻은 요청에만 유효합니다.**

요청 메서드를 문자열로 반환합니다. 읽기 전용 속성입니다. 예시: `'GET'`, `'DELETE'`.


#### `message.rawHeaders`[#](https://nodejs.org/docs/latest/api/http.html#messagerawheaders)

추가된 버전: v0.11.6

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

`rawHeaders`는 요청/응답 헤더를 받은 그대로의 형태로 저장한 리스트입니다.

키와 값이 동일한 리스트에 포함되어 있습니다. 튜플 리스트가 아니므로, 짝수 인덱스는 키 값이고 홀수 인덱스는 해당 값입니다.

헤더 이름은 소문자로 변환되지 않으며, 중복된 헤더도 병합되지 않습니다.

```js
// 다음과 같은 형태로 출력됩니다:
// [ 'user-agent',
//   'this is invalid because there can be only one',
//   'User-Agent',
//   'curl/7.22.0',
//   'Host',
//   '127.0.0.1:8000',
//   'ACCEPT',
//   '*/*' ]
console.log(request.rawHeaders);
```


#### `message.rawTrailers`[#](https://nodejs.org/docs/latest/api/http.html#messagerawtrailers)

추가된 버전: v0.11.6

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

요청/응답 트레일러의 키와 값이 수신된 그대로 저장됩니다. 이 값은 `'end'` 이벤트에서만 채워집니다.


#### `message.setTimeout(msecs[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#messagesettimeoutmsecs-callback)

추가된 버전: v0.5.9

-   `msecs` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<http.IncomingMessage>`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)

`message.socket.setTimeout(msecs, callback)`를 호출합니다.


#### `message.socket`[#](https://nodejs.org/docs/latest/api/http.html#messagesocket)

추가된 버전: v0.3.0

-   [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

이 속성은 연결과 관련된 [`net.Socket`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 객체를 나타냅니다.

HTTPS를 사용하는 경우, [`request.socket.getPeerCertificate()`](https://nodejs.org/docs/latest/api/tls.html#tlssocketgetpeercertificatedetailed)를 통해 클라이언트의 인증 정보를 얻을 수 있습니다.

이 속성은 사용자가 [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 이외의 소켓 타입을 지정하거나 내부적으로 null로 설정하지 않는 한, [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket) 클래스의 인스턴스임이 보장됩니다. [`<net.Socket>`](https://nodejs.org/docs/latest/api/net.html#class-netsocket)은 [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)의 하위 클래스입니다.


#### `message.statusCode`[#](https://nodejs.org/docs/latest/api/http.html#messagestatuscode)

추가된 버전: v0.1.1

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

**`http.ClientRequest`에서 얻은 응답에만 유효합니다.**

3자리 HTTP 응답 상태 코드입니다. 예: `404`.


#### `message.statusMessage`[#](https://nodejs.org/docs/latest/api/http.html#messagestatusmessage)

추가된 버전: v0.11.10

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

**`http.ClientRequest`에서 얻은 응답에만 유효합니다.**

HTTP 응답 상태 메시지(이유 구문)를 나타냅니다. 예를 들어, `OK` 또는 `Internal Server Error`와 같은 메시지입니다.


#### `message.trailers`[#](https://nodejs.org/docs/latest/api/http.html#messagetrailers)

추가된 버전: v0.3.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

요청/응답 트레일러 객체입니다. 이 객체는 `'end'` 이벤트에서만 채워집니다.


#### `message.trailersDistinct`[#](https://nodejs.org/docs/latest/api/http.html#messagetrailersdistinct)

추가된 버전: v18.3.0, v16.17.0

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

[`message.trailers`](https://nodejs.org/docs/latest/api/http.html#messagetrailers)와 유사하지만, 여기서는 값을 합치는 로직이 없고, 한 번만 받은 헤더더라도 항상 문자열 배열로 값을 반환합니다. 이 값은 `'end'` 이벤트에서만 채워집니다.


#### `message.url`[#](https://nodejs.org/docs/latest/api/http.html#messageurl)

추가된 버전: v0.1.90

-   [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

**`http.Server`에서 얻은 요청에만 유효합니다.**

요청 URL 문자열입니다. 이 값은 실제 HTTP 요청에 포함된 URL만을 담고 있습니다. 다음 요청을 예로 들어보겠습니다:

```http
GET /status?name=ryan HTTP/1.1 Accept: text/plain
```

URL을 부분으로 나누어 파싱하려면 다음과 같이 합니다:

```js
new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`);
```

`request.url`이 `'/status?name=ryan'`이고 `process.env.HOST`가 정의되지 않았다면:

```console
$ node > new URL(`http://${process.env.HOST ?? 'localhost'}${request.url}`); URL { href: 'http://localhost/status?name=ryan', origin: 'http://localhost', protocol: 'http:', username: '', password: '', host: 'localhost', hostname: 'localhost', port: '', pathname: '/status', search: '?name=ryan', searchParams: URLSearchParams { 'name' => 'ryan' }, hash: '' }
```

`process.env.HOST`를 서버의 호스트 이름으로 설정하거나, 이 부분을 완전히 대체하는 것을 고려하세요. `req.headers.host`를 사용한다면, 클라이언트가 커스텀 `Host` 헤더를 지정할 수 있으므로 적절한 검증을 사용해야 합니다.


### 클래스: `http.OutgoingMessage`[#](https://nodejs.org/docs/latest/api/http.html#class-httpoutgoingmessage)

추가된 버전: v0.1.17

-   상속: [`<Stream>`](https://nodejs.org/docs/latest/api/stream.html#stream)

이 클래스는 [`http.ClientRequest`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)와 [`http.ServerResponse`](https://nodejs.org/docs/latest/api/http.html#class-httpserverresponse)의 부모 클래스 역할을 합니다. HTTP 트랜잭션의 참여자 관점에서 볼 때, 이 클래스는 추상적인 발신 메시지를 나타냅니다.


#### 이벤트: `'drain'`[#](https://nodejs.org/docs/latest/api/http.html#event-drain)

추가된 버전: v0.3.6

메시지 버퍼가 다시 비워졌을 때 발생합니다.


#### 이벤트: `'finish'`[#](https://nodejs.org/docs/latest/api/http.html#event-finish_2)

추가된 버전: v0.1.17

전송이 성공적으로 완료되었을 때 발생합니다.


#### 이벤트: `'prefinish'`[#](https://nodejs.org/docs/latest/api/http.html#event-prefinish)

추가된 버전: v0.11.6

`outgoingMessage.end()`가 호출된 후에 발생합니다. 이 이벤트가 발생할 때, 모든 데이터가 처리되었지만 완전히 플러시되지는 않았을 수 있습니다.


#### `outgoingMessage.addTrailers(headers)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageaddtrailersheaders)

추가된 버전: v0.3.0

-   `headers` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

메시지의 끝에 HTTP 트레일러(헤더지만 메시지의 끝에 위치)를 추가합니다.

트레일러는 메시지가 청크 인코딩된 경우에만 **발생**합니다. 그렇지 않으면 트레일러는 조용히 버려집니다.

HTTP는 트레일러를 발생시키기 위해 `Trailer` 헤더를 보내야 하며, 그 값에는 헤더 필드 이름 목록이 포함되어야 합니다. 예를 들면:

```js
message.writeHead(200, { 'Content-Type': 'text/plain', 'Trailer': 'Content-MD5' });
message.write(fileData);
message.addTrailers({ 'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667' });
message.end();
```

헤더 필드 이름이나 값에 유효하지 않은 문자가 포함되어 있으면 `TypeError`가 발생합니다.


#### `outgoingMessage.appendHeader(name, value)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageappendheadername-value)

추가된 버전: v18.3.0, v16.17.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 헤더 이름
-   `value` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 헤더 값
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

헤더 객체에 단일 헤더 값을 추가합니다.

값이 배열인 경우, 이 메서드를 여러 번 호출하는 것과 동일합니다.

이전에 해당 헤더에 값이 없었다면, 이 메서드는 [`outgoingMessage.setHeader(name, value)`](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesetheadername-value)를 호출하는 것과 동일합니다.

클라이언트 요청 또는 서버가 생성될 때 `options.uniqueHeaders`의 값에 따라, 이 헤더는 여러 번 전송되거나 `;`로 연결된 단일 값으로 전송됩니다.


#### `outgoingMessage.connection`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageconnection)

추가된 버전: v0.3.0  
사용 중단된 버전: v15.12.0, v14.17.1  

[`outgoingMessage.socket`](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesocket)의 별칭입니다.


#### `outgoingMessage.cork()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagecork)

추가된 버전: v13.2.0, v12.16.0

[`writable.cork()`](https://nodejs.org/docs/latest/api/stream.html#writablecork)를 참고하세요.


#### `outgoingMessage.destroy([error])`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagedestroyerror)

v0.3.0 버전에서 추가됨

-   `error` [`<Error>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) (선택 사항): `error` 이벤트와 함께 발생시킬 오류
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

메시지를 파괴합니다. 메시지에 소켓이 연결되어 있고 연결된 상태라면, 해당 소켓도 함께 파괴됩니다.


#### `outgoingMessage.end(chunk[, encoding][, callback])`

-   `chunk` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 선택 사항, **기본값**: `utf8`
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 선택 사항
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

이 메서드는 보내는 메시지를 완료합니다. 아직 전송되지 않은 본문 부분이 있다면, 이를 기반 시스템으로 플러시합니다. 메시지가 청크로 나뉘어 있다면, 종료 청크인 `0\r\n\r\n`을 보내고, 트레일러가 있다면 함께 전송합니다.

`chunk`가 지정된 경우, `outgoingMessage.write(chunk, encoding)`을 호출한 뒤 `outgoingMessage.end(callback)`을 호출하는 것과 동일합니다.

`callback`이 제공되면, 메시지가 완료될 때 호출됩니다. 이는 `'finish'` 이벤트의 리스너와 동일한 역할을 합니다.


#### `outgoingMessage.flushHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageflushheaders)

추가된 버전: v1.6.0

메시지 헤더를 즉시 전송합니다.

성능을 위해 Node.js는 일반적으로 `outgoingMessage.end()`가 호출되거나 메시지 데이터의 첫 번째 청크가 작성될 때까지 메시지 헤더를 버퍼링합니다. 그런 다음 헤더와 데이터를 하나의 TCP 패킷으로 묶으려고 시도합니다.

이 방식은 일반적으로 유용합니다(TCP 왕복 시간을 절약하기 때문). 하지만 첫 번째 데이터가 훨씬 나중에 전송될 가능성이 있는 경우에는 적합하지 않습니다. `outgoingMessage.flushHeaders()`는 이 최적화를 우회하고 메시지 전송을 즉시 시작합니다.


#### `outgoingMessage.getHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagegetheadername)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 헤더 이름
-   반환값: [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<undefined>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Undefined_type)

주어진 이름의 HTTP 헤더 값을 가져옵니다. 해당 헤더가 설정되지 않은 경우, 반환값은 `undefined`가 됩니다.


#### `outgoingMessage.getHeaderNames()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagegetheadernames)

추가된 버전: v7.7.0

-   반환값: [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

현재 전송 중인 헤더의 고유한 이름을 담은 배열을 반환합니다. 모든 이름은 소문자로 표시됩니다.


#### `outgoingMessage.getHeaders()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagegetheaders)

추가된 버전: v7.7.0

-   반환값: [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

현재 전송 중인 헤더의 얕은 복사본을 반환합니다. 얕은 복사가 사용되기 때문에, 배열 값은 다양한 헤더 관련 HTTP 모듈 메서드를 추가로 호출하지 않고도 변경될 수 있습니다. 반환된 객체의 키는 헤더 이름이고, 값은 해당 헤더 값입니다. 모든 헤더 이름은 소문자로 표시됩니다.

`outgoingMessage.getHeaders()` 메서드가 반환하는 객체는 JavaScript `Object`로부터 프로토타입 상속을 받지 않습니다. 이는 `obj.toString()`, `obj.hasOwnProperty()`와 같은 일반적인 `Object` 메서드가 정의되지 않으며 작동하지 않음을 의미합니다.

```js
outgoingMessage.setHeader('Foo', 'bar');
outgoingMessage.setHeader('Set-Cookie', ['foo=bar', 'bar=baz']);
const headers = outgoingMessage.getHeaders();
// headers === { foo: 'bar', 'set-cookie': ['foo=bar', 'bar=baz'] }
```


#### `outgoingMessage.hasHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagehasheadername)

추가된 버전: v7.7.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`name`으로 식별된 헤더가 현재 전송 중인 헤더에 설정되어 있으면 `true`를 반환합니다. 헤더 이름은 대소문자를 구분하지 않습니다.

```js
const hasContentType = outgoingMessage.hasHeader('content-type');
```


#### `outgoingMessage.headersSent`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageheaderssent)

v0.9.3 버전에서 추가됨

- [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

읽기 전용 속성입니다. 헤더가 전송되었으면 `true`, 그렇지 않으면 `false`를 반환합니다.


#### `outgoingMessage.pipe()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagepipe)

추가된 버전: v9.0.0

`http.OutgoingMessage`의 부모 클래스인 레거시 `Stream` 클래스에서 상속된 `stream.pipe()` 메서드를 재정의합니다.

이 메서드를 호출하면 `outgoingMessage`가 쓰기 전용 스트림이기 때문에 `Error`가 발생합니다.


#### `outgoingMessage.removeHeader(name)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageremoveheadername)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 헤더 이름

암시적으로 전송되기 위해 대기 중인 헤더를 제거합니다.

```js
outgoingMessage.removeHeader('Content-Encoding');
```


#### `outgoingMessage.setHeader(name, value)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesetheadername-value)

추가된 버전: v0.4.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 헤더 이름
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types) 헤더 값
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

단일 헤더 값을 설정합니다. 만약 해당 헤더가 이미 전송될 헤더 목록에 존재한다면, 그 값이 대체됩니다. 동일한 이름의 여러 헤더를 보내려면 문자열 배열을 사용할 수 있습니다.


#### `outgoingMessage.setHeaders(headers)`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesetheadersheaders)

추가된 버전: v19.6.0, v18.15.0

-   `headers` [`<Headers>`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) | [`<Map>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

암시적 헤더에 대해 여러 헤더 값을 설정합니다. `headers`는 [`Headers`](https://nodejs.org/docs/latest/api/globals.html#class-headers) 또는 `Map`의 인스턴스여야 합니다. 이미 전송될 헤더에 해당 헤더가 존재한다면, 그 값은 대체됩니다.

```js
const headers = new Headers({ foo: 'bar' });
outgoingMessage.setHeaders(headers);
```

또는

```js
const headers = new Map([['foo', 'bar']]);
outgoingMessage.setHeaders(headers);
```

[`outgoingMessage.setHeaders()`](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesetheadersheaders)로 헤더를 설정한 후, 이 헤더들은 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더와 병합됩니다. 이때 [`response.writeHead()`](https://nodejs.org/docs/latest/api/http.html#responsewriteheadstatuscode-statusmessage-headers)에 전달된 헤더가 우선순위를 가집니다.

```js
// content-type = text/plain을 반환합니다.
const server = http.createServer((req, res) => {
    const headers = new Headers({ 'Content-Type': 'text/html' });
    res.setHeaders(headers);
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('ok');
});
```


#### `outgoingMessage.setTimeout(msesc[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesettimeoutmsesc-callback)

추가된 버전: v0.9.12

-   `msesc` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 타임아웃 발생 시 호출될 선택적 함수. `timeout` 이벤트에 바인딩하는 것과 동일합니다.
-   반환값: [`<this>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this)

메시지에 소켓이 연결되고 연결이 완료되면, [`socket.setTimeout()`](https://nodejs.org/docs/latest/api/net.html#socketsettimeouttimeout-callback)이 `msecs`를 첫 번째 인자로 호출됩니다.


#### `outgoingMessage.socket`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagesocket)

추가된 버전: v0.3.0

-   [`<stream.Duplex>`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex)

기본 소켓을 참조합니다. 일반적으로 사용자는 이 속성에 접근할 필요가 없습니다.

`outgoingMessage.end()`를 호출한 후에는 이 속성이 `null`로 설정됩니다.


#### `outgoingMessage.uncork()`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessageuncork)

**추가된 버전**: v13.2.0, v12.16.0

[`writable.uncork()`](https://nodejs.org/docs/latest/api/stream.html#writableuncork)를 참고하세요.


#### `outgoingMessage.writableCorked`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritablecorked)

추가된 버전: v13.2.0, v12.16.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`outgoingMessage.cork()` 메서드가 호출된 횟수를 나타냅니다.


#### `outgoingMessage.writableEnded`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritableended)

v12.9.0에서 추가됨

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

`outgoingMessage.end()`가 호출되었을 경우 `true`를 반환합니다. 이 속성은 데이터가 플러시되었는지 여부를 나타내지 않습니다. 데이터 플러시 여부를 확인하려면 `message.writableFinished`를 사용하세요.


#### `outgoingMessage.writableFinished`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritablefinished)

추가된 버전: v12.7.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

모든 데이터가 하위 시스템으로 플러시(flush)되었을 경우 `true`를 반환합니다.


#### `outgoingMessage.writableHighWaterMark`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritablehighwatermark)

v12.9.0 버전에서 추가됨

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

`outgoingMessage.writableHighWaterMark`는 기본 소켓의 `highWaterMark` 값을 반환합니다. 만약 소켓이 할당되지 않았다면, [`writable.write()`](https://nodejs.org/docs/latest/api/stream.html#writablewritechunk-encoding-callback)가 `false`를 반환하기 시작하는 기본 버퍼 레벨인 `16384`를 반환합니다.


#### `outgoingMessage.writableLength`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritablelength)

추가된 버전: v12.9.0

- [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

버퍼링된 바이트 수를 나타냅니다.


#### `outgoingMessage.writableObjectMode`[#](https://nodejs.org/docs/latest/api/http.html#outgoingmessagewritableobjectmode)

추가된 버전: v12.9.0

-   [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

항상 `false`입니다.


#### `outgoingMessage.write(chunk[, encoding][, callback])`

-   `chunk` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<Buffer>`](https://nodejs.org/docs/latest/api/buffer.html#class-buffer) | [`<Uint8Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array)
-   `encoding` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) **기본값**: `utf8`
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type)

이 메서드는 본문의 일부를 전송합니다. 여러 번 호출할 수 있습니다.

`encoding` 인자는 `chunk`가 문자열일 때만 유효합니다. 기본값은 `'utf8'`입니다.

`callback` 인자는 선택 사항이며, 이 데이터 청크가 플러시될 때 호출됩니다.

전체 데이터가 커널 버퍼로 성공적으로 플러시되면 `true`를 반환합니다. 데이터의 일부 또는 전체가 사용자 메모리에 대기 중이라면 `false`를 반환합니다. 버퍼가 다시 비워지면 `'drain'` 이벤트가 발생합니다.


### `http.METHODS`[#](https://nodejs.org/docs/latest/api/http.html#httpmethods)

추가된 버전: v0.11.8

-   [`<string\[\]>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)

파서가 지원하는 HTTP 메서드 목록입니다.


### `http.STATUS_CODES`[#](https://nodejs.org/docs/latest/api/http.html#httpstatus_codes)

추가된 버전: v0.1.22

-   [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)

이 객체는 모든 표준 HTTP 응답 상태 코드와 각 코드에 대한 간단한 설명을 담고 있습니다. 예를 들어, `http.STATUS_CODES[404] === 'Not Found'`와 같이 사용할 수 있습니다.


### `http.createServer([options][, requestListener])`

- `options` [`<Object>`]
    - `connectionsCheckingInterval`: 불완전한 요청에서 요청 및 헤더 타임아웃을 확인하기 위한 간격을 밀리초 단위로 설정. **기본값:** `30000`.
    - `headersTimeout`: 클라이언트로부터 완전한 HTTP 헤더를 받기 위한 타임아웃 값을 밀리초 단위로 설정. 자세한 내용은 [`server.headersTimeout`](https://nodejs.org/docs/latest/api/http.html#serverheaderstimeout) 참조. **기본값:** `60000`.
    - `highWaterMark` [`<number>`]: 모든 `socket`의 `readableHighWaterMark`와 `writableHighWaterMark`를 선택적으로 덮어씀. 이는 `IncomingMessage`와 `ServerResponse`의 `highWaterMark` 속성에 영향을 미침. **기본값:** [`stream.getDefaultHighWaterMark()`](https://nodejs.org/docs/latest/api/stream.html#streamgetdefaulthighwatermarkobjectmode) 참조.
    - `insecureHTTPParser` [`<boolean>`]: `true`로 설정하면, 관대한 플래그가 활성화된 HTTP 파서를 사용. 보안에 취약한 파서 사용은 피해야 함. 자세한 내용은 [`--insecure-http-parser`](https://nodejs.org/docs/latest/api/cli.html#--insecure-http-parser) 참조. **기본값:** `false`.
    - `IncomingMessage` [`<http.IncomingMessage>`]: 사용할 `IncomingMessage` 클래스를 지정. 원래 `IncomingMessage`를 확장할 때 유용. **기본값:** `IncomingMessage`.
    - `joinDuplicateHeaders` [`<boolean>`]: `true`로 설정하면, 요청에서 중복된 헤더의 필드 라인 값을 쉼표(`,`)로 결합. 자세한 내용은 [`message.headers`](https://nodejs.org/docs/latest/api/http.html#messageheaders) 참조. **기본값:** `false`.
    - `keepAlive` [`<boolean>`]: `true`로 설정하면, 새로운 연결이 수신된 직후 소켓에서 keep-alive 기능을 활성화. 이는 [`socket.setKeepAlive([enable][, initialDelay])`]와 유사. **기본값:** `false`.
    - `keepAliveInitialDelay` [`<number>`]: 양수로 설정하면, 유휴 소켓에서 첫 번째 keepalive 프로브를 보내기 전의 초기 지연 시간을 설정. **기본값:** `0`.
    - `keepAliveTimeout`: 서버가 마지막 응답을 완료한 후 추가 데이터를 기다리는 동안의 비활성 시간을 밀리초 단위로 설정. 자세한 내용은 [`server.keepAliveTimeout`](https://nodejs.org/docs/latest/api/http.html#serverkeepalivetimeout) 참조. **기본값:** `5000`.
    - `maxHeaderSize` [`<number>`]: 이 서버가 받는 요청에 대해 [`--max-http-header-size`](https://nodejs.org/docs/latest/api/cli.html#--max-http-header-sizesize) 값을 선택적으로 덮어씀. 즉, 요청 헤더의 최대 길이를 바이트 단위로 설정. **기본값:** 16384 (16 KiB).
    - `noDelay` [`<boolean>`]: `true`로 설정하면, 새로운 연결이 수신된 직후 Nagle 알고리즘 사용을 비활성화. **기본값:** `true`.
    - `requestTimeout`: 클라이언트로부터 전체 요청을 받기 위한 타임아웃 값을 밀리초 단위로 설정. 자세한 내용은 [`server.requestTimeout`](https://nodejs.org/docs/latest/api/http.html#serverrequesttimeout) 참조. **기본값:** `300000`.
    - `requireHostHeader` [`<boolean>`]: `true`로 설정하면, Host 헤더가 없는 HTTP/1.1 요청 메시지에 대해 서버가 400 (Bad Request) 상태 코드로 응답. **기본값:** `true`.
    - `ServerResponse` [`<http.ServerResponse>`]: 사용할 `ServerResponse` 클래스를 지정. 원래 `ServerResponse`를 확장할 때 유용. **기본값:** `ServerResponse`.
    - `uniqueHeaders` [`<Array>`]: 한 번만 전송되어야 하는 응답 헤더 목록. 헤더 값이 배열인 경우, 항목은 `;`로 결합.
    - `rejectNonStandardBodyWrites` [`<boolean>`]: `true`로 설정하면, 본문이 없는 HTTP 응답에 쓰기를 시도할 때 오류를 발생. **기본값:** `false`.
- `requestListener` [`<Function>`]
- 반환값: [`<http.Server>`]

[`http.Server`](https://nodejs.org/docs/latest/api/http.html#class-httpserver)의 새 인스턴스를 반환.

`requestListener`는 [`'request'`](https://nodejs.org/docs/latest/api/http.html#event-request) 이벤트에 자동으로 추가되는 함수.

```js
import http from 'node:http';

// 데이터를 받을 로컬 서버 생성
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ data: 'Hello World!' }));
});

server.listen(8000);
```

```js
import http from 'node:http';

// 데이터를 받을 로컬 서버 생성
const server = http.createServer();

// request 이벤트 리스닝
server.on('request', (request, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({ data: 'Hello World!' }));
});

server.listen(8000);
```


### `http.get(options[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#httpgetoptions-callback)





### `http.get(url[, options][, callback])`

-   `url` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)
-   `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) [`http.request()`](https://nodejs.org/docs/latest/api/http.html#httprequestoptions-callback)와 동일한 `options`를 받으며, 기본적으로 메소드는 GET으로 설정됩니다.
-   `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
-   반환값: [`<http.ClientRequest>`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)

대부분의 요청이 본문(body) 없이 GET 요청이기 때문에, Node.js는 이 편의 메소드를 제공합니다. 이 메소드와 [`http.request()`](https://nodejs.org/docs/latest/api/http.html#httprequestoptions-callback)의 유일한 차이점은 기본적으로 메소드를 GET으로 설정하고 `req.end()`를 자동으로 호출한다는 것입니다. 콜백은 [`http.ClientRequest`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest) 섹션에서 설명한 이유로 응답 데이터를 소비해야 합니다.

`callback`은 [`http.IncomingMessage`](https://nodejs.org/docs/latest/api/http.html#class-httpincomingmessage)의 인스턴스인 단일 인자와 함께 호출됩니다.

JSON 데이터를 가져오는 예제:

```js
http.get('http://localhost:8000/', (res) => {
    const { statusCode } = res;
    const contentType = res.headers['content-type'];
    let error;

    // 2xx 상태 코드는 성공적인 응답을 의미하지만,
    // 여기서는 200만 확인합니다.
    if (statusCode !== 200) {
        error = new Error('요청 실패.\n' + `상태 코드: ${statusCode}`);
    } else if (!/^application\/json/.test(contentType)) {
        error = new Error('잘못된 콘텐츠 타입.\n' + `application/json을 기대했지만 ${contentType}을 받았습니다.`);
    }

    if (error) {
        console.error(error.message);
        // 메모리를 확보하기 위해 응답 데이터를 소비합니다.
        res.resume();
        return;
    }

    res.setEncoding('utf8');
    let rawData = '';
    res.on('data', (chunk) => {
        rawData += chunk;
    });
    res.on('end', () => {
        try {
            const parsedData = JSON.parse(rawData);
            console.log(parsedData);
        } catch (e) {
            console.error(e.message);
        }
    });
}).on('error', (e) => {
    console.error(`에러 발생: ${e.message}`);
});

// 데이터를 받을 로컬 서버를 생성합니다.
const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    res.end(JSON.stringify({
        data: 'Hello World!',
    }));
});

server.listen(8000);
```


### `http.globalAgent`[#](https://nodejs.org/docs/latest/api/http.html#httpglobalagent)

-   [`<http.Agent>`](https://nodejs.org/docs/latest/api/http.html#class-httpagent)

`http.globalAgent`는 모든 HTTP 클라이언트 요청에 기본적으로 사용되는 `Agent`의 전역 인스턴스입니다. 이 인스턴스는 기본 `Agent` 설정과 달리 `keepAlive`가 활성화되어 있고, `timeout`이 5초로 설정되어 있습니다.


### `http.maxHeaderSize`[#](https://nodejs.org/docs/latest/api/http.html#httpmaxheadersize)

추가된 버전: v11.6.0, v10.15.0

-   [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type)

HTTP 헤더의 최대 허용 크기를 바이트 단위로 지정하는 읽기 전용 속성입니다. 기본값은 16 KiB입니다. [`--max-http-header-size`](https://nodejs.org/docs/latest/api/cli.html#--max-http-header-sizesize) 커맨드라인 옵션을 사용하여 설정할 수 있습니다.

이 값은 서버와 클라이언트 요청에서 `maxHeaderSize` 옵션을 전달하여 재정의할 수 있습니다.


### `http.request(options[, callback])`[#](https://nodejs.org/docs/latest/api/http.html#httprequestoptions-callback)





### `http.request(url[, options][, callback])`

- `url` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) | [`<URL>`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)
- `options` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)
  - `agent` [`<http.Agent>`](https://nodejs.org/docs/latest/api/http.html#class-httpagent) | [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) [`Agent`](https://nodejs.org/docs/latest/api/http.html#class-httpagent) 동작을 제어합니다. 가능한 값:
    - `undefined` (기본값): 해당 호스트와 포트에 대해 [`http.globalAgent`](https://nodejs.org/docs/latest/api/http.html#httpglobalagent)를 사용합니다.
    - `Agent` 객체: 명시적으로 전달된 `Agent`를 사용합니다.
    - `false`: 기본값을 가진 새로운 `Agent`를 사용합니다.
  - `auth` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Basic 인증(`'user:password'`)을 사용하여 Authorization 헤더를 계산합니다.
  - `createConnection` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) `agent` 옵션이 사용되지 않을 때 요청에 사용할 소켓/스트림을 생성하는 함수입니다. 기본 `createConnection` 함수를 재정의하기 위해 커스텀 `Agent` 클래스를 생성하지 않아도 됩니다. 자세한 내용은 [`agent.createConnection()`](https://nodejs.org/docs/latest/api/http.html#agentcreateconnectionoptions-callback)을 참조하세요. 모든 [`Duplex`](https://nodejs.org/docs/latest/api/stream.html#class-streamduplex) 스트림이 유효한 반환값입니다.
  - `defaultPort` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 프로토콜의 기본 포트입니다. **기본값:** `Agent`가 사용되면 `agent.defaultPort`, 그렇지 않으면 `undefined`.
  - `family` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) `host` 또는 `hostname`을 해결할 때 사용할 IP 주소 체계입니다. 유효한 값은 `4` 또는 `6`입니다. 지정되지 않으면 IP v4와 v6 모두 사용됩니다.
  - `headers` [`<Object>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object) 요청 헤더를 포함하는 객체입니다.
  - `hints` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 선택적 [`dns.lookup()` hints](https://nodejs.org/docs/latest/api/dns.html#supported-getaddrinfo-flags).
  - `host` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청을 보낼 서버의 도메인 이름 또는 IP 주소입니다. **기본값:** `'localhost'`.
  - `hostname` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) `host`의 별칭입니다. [`url.parse()`](https://nodejs.org/docs/latest/api/url.html#urlparseurlstring-parsequerystring-slashesdenotehost)를 지원하기 위해 `host`와 `hostname`이 모두 지정되면 `hostname`이 사용됩니다.
  - `insecureHTTPParser` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) `true`로 설정하면 leniency 플래그가 활성화된 HTTP 파서를 사용합니다. 보안에 취약한 파서 사용은 피해야 합니다. 자세한 내용은 [`--insecure-http-parser`](https://nodejs.org/docs/latest/api/cli.html#--insecure-http-parser)를 참조하세요. **기본값:** `false`
  - `joinDuplicateHeaders` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type) 요청에서 중복된 헤더의 필드 라인 값을 `,`로 결합합니다. 자세한 내용은 [`message.headers`](https://nodejs.org/docs/latest/api/http.html#messageheaders)를 참조하세요. **기본값:** `false`.
  - `localAddress` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 네트워크 연결을 위한 로컬 인터페이스입니다.
  - `localPort` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 연결할 로컬 포트입니다.
  - `lookup` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function) 커스텀 lookup 함수입니다. **기본값:** [`dns.lookup()`](https://nodejs.org/docs/latest/api/dns.html#dnslookuphostname-options-callback).
  - `maxHeaderSize` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 서버로부터 받은 응답 헤더의 최대 길이를 바이트 단위로 재정의합니다. **기본값:** 16384 (16 KiB).
  - `method` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) HTTP 요청 메서드를 지정하는 문자열입니다. **기본값:** `'GET'`.
  - `path` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 요청 경로입니다. 쿼리 문자열이 있다면 포함해야 합니다. 예: `'/index.html?page=12'`. 요청 경로에 잘못된 문자가 포함되면 예외가 발생합니다. 현재는 공백만 거부되지만, 추후 변경될 수 있습니다. **기본값:** `'/'`.
  - `port` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) 원격 서버의 포트입니다. **기본값:** `defaultPort`가 설정되면 해당 값, 그렇지 않으면 `80`.
  - `protocol` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 사용할 프로토콜입니다. **기본값:** `'http:'`.
  - `setDefaultHeaders` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type): `Connection`, `Content-Length`, `Transfer-Encoding`, `Host`와 같은 기본 헤더를 자동으로 추가할지 여부를 지정합니다. `false`로 설정하면 모든 필요한 헤더를 수동으로 추가해야 합니다. 기본값은 `true`입니다.
  - `setHost` [`<boolean>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type): `Host` 헤더를 자동으로 추가할지 여부를 지정합니다. 제공되면 `setDefaultHeaders`를 재정의합니다. 기본값은 `true`입니다.
  - `signal` [`<AbortSignal>`](https://nodejs.org/docs/latest/api/globals.html#class-abortsignal): 진행 중인 요청을 중단하는 데 사용할 수 있는 AbortSignal입니다.
  - `socketPath` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) Unix 도메인 소켓입니다. `host` 또는 `port`가 지정된 경우 사용할 수 없습니다.
  - `timeout` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type): 소켓 타임아웃을 밀리초 단위로 지정합니다. 이 값은 소켓이 연결되기 전에 타임아웃을 설정합니다.
  - `uniqueHeaders` [`<Array>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) 한 번만 전송해야 하는 요청 헤더 목록입니다. 헤더 값이 배열인 경우 `;`로 결합됩니다.
- `callback` [`<Function>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)
- 반환값: [`<http.ClientRequest>`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest)

[`socket.connect()`](https://nodejs.org/docs/latest/api/net.html#socketconnectoptions-connectlistener)의 `options`도 지원됩니다.

Node.js는 HTTP 요청을 위해 서버당 여러 연결을 유지합니다. 이 함수를 사용하면 요청을 투명하게 발행할 수 있습니다.

`url`은 문자열 또는 [`URL`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api) 객체일 수 있습니다. `url`이 문자열인 경우 [`new URL()`](https://nodejs.org/docs/latest/api/url.html#new-urlinput-base)로 자동 파싱됩니다. [`URL`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api) 객체인 경우 일반 `options` 객체로 자동 변환됩니다.

`url`과 `options`가 모두 지정되면 객체가 병합되며, `options` 속성이 우선합니다.

선택적 `callback` 매개변수는 [`'response'`](https://nodejs.org/docs/latest/api/http.html#event-response) 이벤트에 대한 일회성 리스너로 추가됩니다.

`http.request()`는 [`http.ClientRequest`](https://nodejs.org/docs/latest/api/http.html#class-httpclientrequest) 클래스의 인스턴스를 반환합니다. `ClientRequest` 인스턴스는 쓰기 가능한 스트림입니다. POST 요청으로 파일을 업로드해야 한다면 `ClientRequest` 객체에 쓰기를 수행합니다.

```js
import http from 'node:http';
import { Buffer } from 'node:buffer';

const postData = JSON.stringify({ 'msg': 'Hello World!' });

const options = {
  hostname: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': Buffer.byteLength(postData),
  },
};

const req = http.request(options, (res) => {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding('utf8');
  res.on('data', (chunk) => {
    console.log(`BODY: ${chunk}`);
  });
  res.on('end', () => {
    console.log('No more data in response.');
  });
});

req.on('error', (e) => {
  console.error(`problem with request: ${e.message}`);
});

// 요청 본문에 데이터 쓰기
req.write(postData);
req.end();
```

예제에서 `req.end()`가 호출되었습니다. `http.request()`를 사용할 때는 요청 본문에 데이터를 쓰지 않더라도 항상 `req.end()`를 호출하여 요청의 끝을 표시해야 합니다.

요청 중에 오류가 발생하면(예: DNS 해결, TCP 레벨 오류, HTTP 파싱 오류) 반환된 요청 객체에서 `'error'` 이벤트가 발생합니다. 모든 `'error'` 이벤트와 마찬가지로 리스너가 등록되지 않으면 오류가 발생합니다.

특별히 주의해야 할 몇 가지 헤더가 있습니다.

- `'Connection: keep-alive'`를 보내면 Node.js에 서버와의 연결을 다음 요청까지 유지하도록 알립니다.
- `'Content-Length'` 헤더를 보내면 기본 청크 인코딩이 비활성화됩니다.
- `'Expect'` 헤더를 보내면 요청 헤더를 즉시 전송합니다. 일반적으로 `'Expect: 100-continue'`를 보낼 때는 타임아웃과 `'continue'` 이벤트 리스너를 설정해야 합니다. 자세한 내용은 RFC 2616 Section 8.2.3을 참조하세요.
- `Authorization` 헤더를 보내면 `auth` 옵션을 사용한 기본 인증 계산을 재정의합니다.

[`URL`](https://nodejs.org/docs/latest/api/url.html#the-whatwg-url-api)을 `options`로 사용하는 예제:

```js
const options = new URL('http://abc:xyz@example.com');
const req = http.request(options, (res) => {
  // ...
});
```

성공적인 요청에서 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- `'response'`
  - `'data'` (응답 본문이 비어 있지 않으면 여러 번 발생)
  - `'end'`
- `'close'`

연결 오류가 발생하면 다음 이벤트가 발생합니다:

- `'socket'`
- `'error'`
- `'close'`

응답을 받기 전에 연결이 조기 종료되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- `'error'` (메시지: `'Error: socket hang up'`, 코드: `'ECONNRESET'`)
- `'close'`

응답을 받은 후 연결이 조기 종료되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- `'response'`
  - `'data'` (여러 번 발생)
- (연결 종료)
- `'aborted'`
- `'close'`
- `'error'` (메시지: `'Error: aborted'`, 코드: `'ECONNRESET'`)
- `'close'`

소켓이 할당되기 전에 `req.destroy()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- (`req.destroy()` 호출)
- `'error'` (메시지: `'Error: socket hang up'`, 코드: `'ECONNRESET'` 또는 `req.destroy()`에 전달된 오류)
- `'close'`

연결이 성공하기 전에 `req.destroy()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- (`req.destroy()` 호출)
- `'error'` (메시지: `'Error: socket hang up'`, 코드: `'ECONNRESET'` 또는 `req.destroy()`에 전달된 오류)
- `'close'`

응답을 받은 후 `req.destroy()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- `'response'`
  - `'data'` (여러 번 발생)
- (`req.destroy()` 호출)
- `'aborted'`
- `'close'`
- `'error'` (메시지: `'Error: aborted'`, 코드: `'ECONNRESET'` 또는 `req.destroy()`에 전달된 오류)
- `'close'`

소켓이 할당되기 전에 `req.abort()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- (`req.abort()` 호출)
- `'abort'`
- `'close'`

연결이 성공하기 전에 `req.abort()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- (`req.abort()` 호출)
- `'abort'`
- `'error'` (메시지: `'Error: socket hang up'`, 코드: `'ECONNRESET'`)
- `'close'`

응답을 받은 후 `req.abort()`가 호출되면 다음 이벤트가 순서대로 발생합니다:

- `'socket'`
- `'response'`
  - `'data'` (여러 번 발생)
- (`req.abort()` 호출)
- `'abort'`
- `'aborted'`
- `'error'` (메시지: `'Error: aborted'`, 코드: `'ECONNRESET'`)
- `'close'`
- `'close'`

`timeout` 옵션을 설정하거나 `setTimeout()` 함수를 사용하면 요청을 중단하지 않고 `'timeout'` 이벤트만 추가됩니다.

`AbortSignal`을 전달한 후 해당 `AbortController`에서 `abort()`를 호출하면 `.destroy()`를 호출한 것과 동일하게 동작합니다. 특히 `'error'` 이벤트가 발생하며, 메시지는 `'AbortError: The operation was aborted'`, 코드는 `'ABORT_ERR'`, 그리고 `cause`가 제공된 경우 해당 값이 포함됩니다.


### `http.validateHeaderName(name[, label])`

- `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
- `label` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type) 오류 메시지에 사용될 라벨. **기본값:** `'Header name'`.

이 메서드는 `res.setHeader(name, value)`가 호출될 때 수행되는 저수준 검증을 제공된 `name`에 대해 실행합니다.

잘못된 값을 `name`으로 전달하면 `code: 'ERR_INVALID_HTTP_TOKEN'`로 식별되는 [`TypeError`](https://nodejs.org/docs/latest/api/errors.html#class-typeerror)가 발생합니다.

HTTP 요청이나 응답에 헤더를 전달하기 전에 이 메서드를 사용할 필요는 없습니다. HTTP 모듈이 자동으로 헤더를 검증합니다.

예제:

```js
import { validateHeaderName } from 'node:http';

try {
    validateHeaderName('');
} catch (err) {
    console.error(err instanceof TypeError); // --> true
    console.error(err.code); // --> 'ERR_INVALID_HTTP_TOKEN'
    console.error(err.message); // --> 'Header name must be a valid HTTP token [""]'
}
```


### `http.validateHeaderValue(name, value)`[#](https://nodejs.org/docs/latest/api/http.html#httpvalidateheadervaluename-value)

추가된 버전: v14.3.0

-   `name` [`<string>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type)
-   `value` [`<any>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Data_types)

이 메서드는 `res.setHeader(name, value)`가 호출될 때 수행되는 저수준의 유효성 검사를 제공된 `value`에 대해 실행합니다.

`value`로 잘못된 값을 전달하면 [`TypeError`](https://nodejs.org/docs/latest/api/errors.html#class-typeerror)가 발생합니다.

-   `undefined` 값 오류는 `code: 'ERR_HTTP_INVALID_HEADER_VALUE'`로 식별됩니다.
-   유효하지 않은 문자 오류는 `code: 'ERR_INVALID_CHAR'`로 식별됩니다.

HTTP 요청이나 응답에 헤더를 전달하기 전에 이 메서드를 사용할 필요는 없습니다. HTTP 모듈이 자동으로 헤더를 검증합니다.

예제:

```js
import { validateHeaderValue } from 'node:http';

try {
    validateHeaderValue('x-my-header', undefined);
} catch (err) {
    console.error(err instanceof TypeError); // --> true
    console.error(err.code === 'ERR_HTTP_INVALID_HEADER_VALUE'); // --> true
    console.error(err.message); // --> 'Invalid value "undefined" for header "x-my-header"'
}

try {
    validateHeaderValue('x-my-header', 'oʊmɪɡə');
} catch (err) {
    console.error(err instanceof TypeError); // --> true
    console.error(err.code === 'ERR_INVALID_CHAR'); // --> true
    console.error(err.message); // --> 'Invalid character in header content ["x-my-header"]'
}
```


### `http.setMaxIdleHTTPParsers(max)`[#](https://nodejs.org/docs/latest/api/http.html#httpsetmaxidlehttpparsersmax)

추가된 버전: v18.8.0, v16.18.0

-   `max` [`<number>`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type) **기본값:** `1000`.

유휴 상태의 HTTP 파서 최대 개수를 설정합니다.


### `WebSocket`[#](https://nodejs.org/docs/latest/api/http.html#websocket)

추가된 버전: v22.5.0

브라우저와 호환되는 [`WebSocket`](https://nodejs.org/docs/latest/api/http.html#websocket) 구현체입니다.


