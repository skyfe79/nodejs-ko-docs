# 이벤트 루프와 워커 풀을 차단하지 않는 방법

## 이 가이드를 읽어야 하는 사람

간단한 커맨드라인 스크립트 이상의 복잡한 프로그램을 작성한다면, 이 문서를 통해 더 높은 성능과 안전한 애플리케이션을 만드는 데 도움을 받을 수 있다.

이 문서는 Node.js 서버를 중심으로 작성했지만, 복잡한 Node.js 애플리케이션에도 동일한 개념이 적용된다.
운영체제별로 세부사항이 다른 경우 리눅스를 기준으로 설명한다.

## 요약

Node.js는 이벤트 루프에서 자바스크립트 코드(초기화와 콜백)를 실행하고, 파일 입출력과 같은 무거운 작업을 처리하기 위한 워커 풀을 제공한다.
Node.js는 Apache와 같은 무거운 접근 방식보다 때로는 더 나은 확장성을 보여준다.
Node.js의 확장성이 뛰어난 비결은 적은 수의 스레드로 많은 클라이언트를 처리한다는 점이다.
Node.js가 적은 스레드로 작업할 수 있다면, 스레드 관리에 필요한 시스템 자원(메모리, 컨텍스트 스위칭)을 클라이언트 요청 처리에 더 많이 사용할 수 있다.
하지만 Node.js는 적은 수의 스레드만 사용하기 때문에, 이를 현명하게 활용할 수 있도록 애플리케이션을 구조화해야 한다.

Node.js 서버의 속도를 유지하기 위한 좋은 규칙은 다음과 같다:
_"특정 시점에 각 클라이언트와 관련된 작업이 '작을' 때 Node.js는 빠르게 동작한다"_

이는 이벤트 루프의 콜백과 워커 풀의 작업 모두에 적용된다.

## 왜 이벤트 루프와 워커 풀을 차단하지 말아야 하는가?

Node.js는 적은 수의 스레드로 많은 클라이언트를 처리한다.
Node.js에는 두 종류의 스레드가 있다: 하나의 이벤트 루프(메인 루프, 메인 스레드, 이벤트 스레드라고도 함)와 워커 풀(스레드풀이라고도 함)의 `k`개 워커다.

스레드가 콜백(이벤트 루프)이나 작업(워커)을 실행하는 데 오랜 시간이 걸린다면, 이를 "차단됨(blocked)"이라고 한다.
스레드가 한 클라이언트의 작업을 처리하느라 차단되면, 다른 클라이언트의 요청을 처리할 수 없게 된다.
이는 이벤트 루프나 워커 풀을 차단하지 말아야 하는 두 가지 이유를 제시한다:

1. 성능: 어느 한 종류의 스레드에서 무거운 작업을 자주 수행하면, 서버의 _처리량_(초당 요청 수)이 저하된다.
2. 보안: 특정 입력으로 인해 스레드가 차단될 수 있다면, 악의적인 클라이언트가 이런 "악성 입력"을 보내 스레드를 차단하고 다른 클라이언트 처리를 방해할 수 있다. 이는 [서비스 거부 공격](https://en.wikipedia.org/wiki/Denial-of-service_attack)이 된다.

## Node.js 동작 방식의 간단한 복습

Node.js는 이벤트 기반 아키텍처를 사용한다: 작업 조율을 위한 이벤트 루프와 무거운 작업을 위한 워커 풀이 있다.

### 이벤트 루프에서 실행되는 코드는?

Node.js 애플리케이션은 시작할 때 먼저 초기화 단계를 거친다. 이 단계에서는 모듈을 `require`하고 이벤트에 대한 콜백을 등록한다.
그 다음 이벤트 루프로 진입하여 들어오는 클라이언트 요청에 대해 적절한 콜백을 실행하며 응답한다.
이 콜백은 동기적으로 실행되며, 처리가 완료된 후 추가 비동기 요청을 등록할 수 있다.
이러한 비동기 요청에 대한 콜백도 이벤트 루프에서 실행된다.

이벤트 루프는 콜백이 등록한 비차단 비동기 요청(예: 네트워크 입출력)도 처리한다.

요약하면, 이벤트 루프는 이벤트에 등록된 자바스크립트 콜백을 실행하고, 네트워크 입출력과 같은 비차단 비동기 요청을 처리하는 역할을 한다.

### 워커 풀에서 실행되는 코드는?

Node.js의 워커 풀은 libuv([문서](http://docs.libuv.org/en/v1.x/threadpool.html))로 구현되어 있으며, 일반적인 작업 제출 API를 제공한다.

Node.js는 "무거운" 작업을 처리하기 위해 워커 풀을 사용한다.
여기에는 운영체제가 비차단 버전을 제공하지 않는 입출력 작업과 특히 CPU 집약적인 작업이 포함된다.

워커 풀을 사용하는 Node.js 모듈 API는 다음과 같다:

1. 입출력 집약적 작업
   1. [DNS](https://nodejs.org/api/dns.html): `dns.lookup()`, `dns.lookupService()`
   2. [파일 시스템](https://nodejs.org/api/fs.html#fs_threadpool_usage): `fs.FSWatcher()`와 명시적으로 동기식인 API를 제외한 모든 파일 시스템 API는 libuv의 스레드풀을 사용한다.
2. CPU 집약적 작업
   1. [암호화](https://nodejs.org/api/crypto.html): `crypto.pbkdf2()`, `crypto.scrypt()`, `crypto.randomBytes()`, `crypto.randomFill()`, `crypto.generateKeyPair()`
   2. [압축](https://nodejs.org/api/zlib.html#zlib_threadpool_usage): 명시적으로 동기식인 API를 제외한 모든 zlib API는 libuv의 스레드풀을 사용한다.

많은 Node.js 애플리케이션에서 이러한 API가 워커 풀에 작업을 보내는 유일한 소스다. [C++ 애드온](https://nodejs.org/api/addons.html)을 사용하는 애플리케이션과 모듈은 워커 풀에 다른 작업을 제출할 수 있다.

완벽을 기하기 위해, 이벤트 루프의 콜백에서 이러한 API를 호출할 때 이벤트 루프가 해당 API에 대한 Node.js C++ 바인딩으로 들어가고 워커 풀에 작업을 제출하는 약간의 설정 비용이 든다는 점을 언급한다.
이 비용은 작업의 전체 비용에 비하면 무시할 만하기 때문에 이벤트 루프가 이를 오프로드하는 것이다.
워커 풀에 이러한 작업 중 하나를 제출할 때, Node.js는 Node.js C++ 바인딩의 해당 C++ 함수에 대한 포인터를 제공한다.

### Node.js는 다음에 실행할 코드를 어떻게 결정하는가?

추상적으로 보면, 이벤트 루프와 워커 풀은 각각 대기 중인 이벤트와 작업에 대한 큐를 유지한다.

실제로는 이벤트 루프가 큐를 직접 관리하지는 않는다.
대신 [epoll](http://man7.org/linux/man-pages/man7/epoll.7.html)(리눅스), [kqueue](https://developer.apple.com/library/content/documentation/Darwin/Conceptual/FSEvents_ProgGuide/KernelQueues/KernelQueues.html)(OSX), event ports(솔라리스), [IOCP](https://msdn.microsoft.com/en-us/library/windows/desktop/aa365198.aspx)(윈도우)와 같은 메커니즘을 사용하여 운영체제에 모니터링을 요청할 파일 디스크립터 모음을 가지고 있다.
이러한 파일 디스크립터는 네트워크 소켓, 감시 중인 파일 등에 해당한다.
운영체제가 이러한 파일 디스크립터 중 하나가 준비되었다고 알리면, 이벤트 루프는 이를 적절한 이벤트로 변환하고 해당 이벤트와 연관된 콜백을 호출한다.
이 과정에 대해 [여기](https://www.youtube.com/watch?v=P9csgxBgaZ8)에서 더 자세히 알아볼 수 있다.

반면 워커 풀은 처리할 작업들이 들어있는 실제 큐를 사용한다.
워커는 이 큐에서 작업을 꺼내 처리하고, 완료되면 "최소 하나의 작업이 완료됨" 이벤트를 이벤트 루프에 발생시킨다.

### 이는 애플리케이션 설계에 어떤 의미가 있는가?

Apache와 같은 클라이언트당 하나의 스레드를 사용하는 시스템에서는 각 대기 중인 클라이언트에 전용 스레드가 할당된다.
한 클라이언트를 처리하는 스레드가 차단되면, 운영체제가 이를 중단하고 다른 클라이언트에게 차례를 넘긴다.
따라서 운영체제가 적은 작업이 필요한 클라이언트가 많은 작업이 필요한 클라이언트 때문에 불이익을 받지 않도록 보장한다.

Node.js는 적은 수의 스레드로 많은 클라이언트를 처리하기 때문에, 한 클라이언트의 요청을 처리하는 스레드가 차단되면 해당 콜백이나 작업이 완료될 때까지 대기 중인 다른 클라이언트 요청들이 차례를 받지 못할 수 있다.
_따라서 클라이언트를 공정하게 처리하는 것은 애플리케이션의 책임이 된다_.
이는 어떤 클라이언트를 위해서도 단일 콜백이나 작업에서 너무 많은 작업을 수행하지 말아야 한다는 것을 의미한다.

이것이 Node.js가 잘 확장될 수 있는 이유 중 하나이지만, 공정한 스케줄링을 보장하는 것은 개발자의 책임이 된다.
다음 섹션에서는 이벤트 루프와 워커 풀에서 공정한 스케줄링을 보장하는 방법에 대해 설명한다.

## 이벤트 루프 차단하지 않기

이벤트 루프는 새로운 클라이언트 연결을 감지하고 응답 생성을 조율한다.
모든 수신 요청과 발신 응답은 이벤트 루프를 통과한다.
따라서 이벤트 루프가 어느 한 지점에서 오랫동안 작업을 수행하면, 현재와 새로운 모든 클라이언트가 처리 순서를 받지 못한다.

따라서 이벤트 루프를 절대 차단하지 않도록 주의해야 한다.
즉, 자바스크립트 콜백은 빠르게 완료되어야 한다.
물론 이는 `await`, `Promise.then` 등에도 적용된다.

콜백의 ["계산 복잡도"](https://en.wikipedia.org/wiki/Time_complexity)를 고려하는 것이 좋은 방법이다.
콜백이 인자에 관계없이 일정한 단계 수를 수행한다면, 대기 중인 모든 클라이언트에게 공정한 순서를 보장할 수 있다.
만약 콜백이 인자에 따라 다른 단계 수를 수행한다면, 인자의 길이가 얼마나 될 수 있는지 고려해야 한다.

예제 1: 상수 시간 콜백

```javascript
app.get('/constant-time', (req, res) => {
  res.sendStatus(200);
});
```

예제 2: `O(n)` 콜백. 이 콜백은 `n`이 작을 때는 빠르게 실행되지만 `n`이 클 때는 더 느리게 실행된다.

```javascript
app.get('/countToN', (req, res) => {
  let n = req.query.n;

  // 다른 작업에 순서를 넘기기 전 n번 반복
  for (let i = 0; i < n; i++) {
    console.log(`반복 ${i}`);
  }

  res.sendStatus(200);
});
```

예제 3: `O(n^2)` 콜백. 이 콜백도 `n`이 작을 때는 빠르게 실행되지만, `n`이 클 때는 이전의 `O(n)` 예제보다 훨씬 더 느리게 실행된다.

```javascript
app.get('/countToN2', (req, res) => {
  let n = req.query.n;

  // 다른 작업에 순서를 넘기기 전 n^2번 반복
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      console.log(`반복 ${i}.${j}`);
    }
  }

  res.sendStatus(200);
});
```

### 얼마나 주의해야 하는가?

Node.js는 자바스크립트 엔진으로 Google V8을 사용하며, V8은 대부분의 일반적인 연산에서 매우 빠른 성능을 보인다.
단, 정규식과 JSON 연산은 예외이며 이는 아래에서 설명한다.

그러나 복잡한 작업의 경우 입력의 크기를 제한하고 너무 긴 입력은 거부하는 것을 고려해야 한다.
이렇게 하면 콜백이 큰 복잡도를 가지더라도, 입력을 제한함으로써 허용 가능한 가장 긴 입력에 대해서도 콜백이 최악의 경우보다 오래 걸리지 않도록 할 수 있다.
그런 다음 이 콜백의 최악의 비용을 평가하고 해당 맥락에서 실행 시간이 허용 가능한지 판단할 수 있다.

### 이벤트 루프 차단: REDOS

이벤트 루프를 치명적으로 차단하는 일반적인 방법 중 하나는 "취약한" [정규식](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)을 사용하는 것이다.

#### 취약한 정규식 피하기

정규식(regexp)은 입력 문자열을 패턴과 대조한다.
일반적으로 정규식 매칭은 입력 문자열을 한 번만 통과하면 된다고 생각한다 --- 입력 문자열의 길이가 `n`일 때 `O(n)` 시간이 걸린다.
실제로 많은 경우 한 번의 통과로 충분하다.
하지만 안타깝게도 일부 경우에는 정규식 매칭이 입력 문자열을 지수적인 횟수로 통과해야 할 수 있다 --- `O(2^n)` 시간이 걸린다.
이는 엔진이 매칭을 결정하는 데 `x`번의 통과가 필요하다면, 입력 문자열에 문자 하나만 추가해도 `2*x`번의 통과가 필요하다는 뜻이다.
통과 횟수가 필요한 시간과 선형적 관계가 있으므로, 이런 평가는 이벤트 루프를 차단하는 결과를 초래한다.

_취약한 정규식_은 "악의적인 입력"에 대해 정규식 엔진이 지수적인 시간이 걸릴 수 있어 [REDOS](https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS)에 노출되는 패턴을 말한다.
정규식 패턴이 취약한지(즉, 정규식 엔진이 지수적인 시간이 걸릴 수 있는지)를 판단하는 것은 실제로 어려운 문제이며, Perl, Python, Ruby, Java, JavaScript 등의 언어에 따라 다르다. 하지만 다음과 같은 경험적 규칙은 이러한 모든 언어에 적용된다:

1. `(a+)*`와 같은 중첩된 한정자(quantifier)를 피한다. V8의 정규식 엔진은 이중 일부를 빠르게 처리할 수 있지만, 다른 것들은 취약하다.
2. `(a|a)*`와 같이 겹치는 절을 가진 OR 연산을 피한다. 이것들도 때때로 빠르게 처리된다.
3. `(a.*) \1`과 같은 역참조(backreference) 사용을 피한다. 어떤 정규식 엔진도 이를 선형 시간에 평가할 수 있다고 보장할 수 없다.
4. 단순한 문자열 매칭을 할 때는 `indexOf`나 이와 동등한 로컬 함수를 사용한다. 이는 비용이 적게 들고 `O(n)` 이상 걸리지 않는다.

정규식이 취약한지 확실하지 않다면, 취약한 정규식이라도 Node.js가 일반적으로 긴 입력 문자열에 대해 _매칭_을 보고하는 데는 문제가 없다는 점을 기억하자.
지수적 동작은 매칭이 실패할 때 발생하지만, Node.js는 입력 문자열의 여러 경로를 시도해 보기 전까지는 확신할 수 없다.

#### REDOS 예제

다음은 서버를 REDOS에 노출시키는 취약한 정규식 예제다:

```javascript
app.get('/redos-me', (req, res) => {
  let filePath = req.query.filePath;

  // REDOS
  if (filePath.match(/(\/.+)+$/)) {
    console.log('유효한 경로');
  } else {
    console.log('유효하지 않은 경로');
  }

  res.sendStatus(200);
});
```

이 예제의 취약한 정규식은 리눅스에서 유효한 경로인지 확인하는 (잘못된!) 방법이다.
"/a/b/c"와 같이 "/"로 구분된 이름들의 시퀀스와 매칭된다.
이는 규칙 1을 위반하여 이중 중첩된 한정자를 가지고 있기 때문에 위험하다.

만약 클라이언트가 filePath를 `///.../\n`(100개의 '/' 다음에 정규식의 "."이 매칭하지 않는 개행 문자)로 요청하면, 이벤트 루프는 사실상 영원히 실행될 것이며 이벤트 루프를 차단한다.
이 클라이언트의 REDOS 공격으로 인해 정규식 매칭이 완료될 때까지 다른 모든 클라이언트가 차례를 받지 못한다.

이러한 이유로 사용자 입력을 검증할 때 복잡한 정규식 사용을 조심해야 한다.

#### REDOS 대응 리소스

정규식의 안전성을 확인하는 몇 가지 도구가 있다:

- [safe-regex](https://github.com/davisjam/safe-regex)
- [rxxr2](https://github.com/superhuman/rxxr2)

하지만 이 도구들도 모든 취약한 정규식을 찾아내지는 못한다.

다른 접근 방법은 다른 정규식 엔진을 사용하는 것이다.
Google의 매우 빠른 [RE2](https://github.com/google/re2) 정규식 엔진을 사용하는 [node-re2](https://github.com/uhop/node-re2) 모듈을 사용할 수 있다.
하지만 RE2는 V8의 정규식과 100% 호환되지 않으므로, node-re2 모듈로 정규식을 처리하도록 변경할 때 회귀가 있는지 확인해야 한다는 점에 주의하자.
또한 특별히 복잡한 정규식은 node-re2에서 지원되지 않는다.

URL이나 파일 경로와 같이 "명백한" 것을 매칭하려고 한다면, [정규식 라이브러리](http://www.regexlib.com)에서 예제를 찾거나 [ip-regex](https://www.npmjs.com/package/ip-regex)와 같은 npm 모듈을 사용하자.

### 이벤트 루프 차단: Node.js 핵심 모듈

여러 Node.js 핵심 모듈은 동기식 고비용 API를 포함한다:

- [암호화](https://nodejs.org/api/crypto.html)
- [압축](https://nodejs.org/api/zlib.html)
- [파일 시스템](https://nodejs.org/api/fs.html)
- [자식 프로세스](https://nodejs.org/api/child_process.html)

이러한 API는 상당한 계산(암호화, 압축)이나 입출력(파일 입출력)을 필요로 하거나, 때로는 둘 다(자식 프로세스) 필요로 하기 때문에 비용이 많이 든다. 이 API들은 스크립팅의 편의를 위해 만들어졌으며, 서버 환경에서 사용하도록 의도된 것이 아니다. 이벤트 루프에서 이들을 실행하면 일반적인 자바스크립트 명령어보다 훨씬 더 오래 걸려 이벤트 루프를 차단한다.

서버에서는 _이러한 모듈의 다음과 같은 동기식 API를 사용하지 않아야 한다_:

- 암호화:
  - `crypto.randomBytes` (동기식 버전)
  - `crypto.randomFillSync`
  - `crypto.pbkdf2Sync`
  - 암호화와 복호화 루틴에 큰 입력을 제공할 때도 주의해야 한다.
- 압축:
  - `zlib.inflateSync`
  - `zlib.deflateSync`
- 파일 시스템:
  - 동기식 파일 시스템 API는 사용하지 않는다. 예를 들어, 접근하는 파일이 [NFS](https://en.wikipedia.org/wiki/Network_File_System)와 같은 [분산 파일 시스템](https://en.wikipedia.org/wiki/Clustered_file_system#Distributed_file_systems)에 있다면 접근 시간이 크게 달라질 수 있다.
- 자식 프로세스:
  - `child_process.spawnSync`
  - `child_process.execSync`
  - `child_process.execFileSync`

이 목록은 Node.js v9 기준으로 합리적으로 완성된 것이다.

### 이벤트 루프 차단: JSON DOS

`JSON.parse`와 `JSON.stringify`도 잠재적으로 비용이 많이 드는 연산이다.
입력 길이 `n`에 대해 `O(n)` 복잡도를 가지지만, 큰 `n`에 대해서는 놀라울 정도로 오래 걸릴 수 있다.

서버가 JSON 객체를 다룬다면, 특히 클라이언트에서 온 것이라면 이벤트 루프에서 다루는 객체나 문자열의 크기에 주의해야 한다.

예제: JSON 차단. 크기가 2^21인 객체 `obj`를 만들고 `JSON.stringify`로 변환한 다음, 문자열에서 `indexOf`를 실행하고 다시 JSON.parse한다. `JSON.stringify`된 문자열은 50MB다. 객체를 문자열화하는 데 0.7초, 50MB 문자열에서 indexOf를 수행하는 데 0.03초, 문자열을 파싱하는 데 1.3초가 걸린다.

```javascript
let obj = { a: 1 };
let niter = 20;

let before, str, pos, res, took;

for (let i = 0; i < niter; i++) {
  obj = { obj1: obj, obj2: obj }; // 매 반복마다 크기가 두 배로 증가
}

before = process.hrtime();
str = JSON.stringify(obj);
took = process.hrtime(before);
console.log('JSON.stringify 소요 시간: ' + took);

before = process.hrtime();
pos = str.indexOf('nomatch');
took = process.hrtime(before);
console.log('순수 indexOf 소요 시간: ' + took);

before = process.hrtime();
res = JSON.parse(str);
took = process.hrtime(before);
console.log('JSON.parse 소요 시간: ' + took);
```

비동기 JSON API를 제공하는 npm 모듈들이 있다. 예를 들면:

- [JSONStream](https://www.npmjs.com/package/JSONStream): 스트림 API를 제공한다.
- [Big-Friendly JSON](https://www.npmjs.com/package/bfj): 스트림 API와 함께 아래에서 설명하는 이벤트 루프 분할 패러다임을 사용하는 표준 JSON API의 비동기 버전을 제공한다.

### 이벤트 루프를 차단하지 않고 복잡한 계산하기

자바스크립트로 이벤트 루프를 차단하지 않고 복잡한 계산을 수행하고 싶다면 두 가지 선택지가 있다: 분할(partitioning)과 오프로딩(offloading)이다.

#### 분할

계산을 _분할_하여 각각이 이벤트 루프에서 실행되지만 정기적으로 다른 대기 중인 이벤트에 순서를 양보하도록 할 수 있다.
자바스크립트에서는 아래 예제 2와 같이 클로저를 사용해 진행 중인 작업의 상태를 쉽게 저장할 수 있다.

간단한 예로, 1부터 n까지 숫자의 평균을 계산한다고 가정해보자.

예제 1: 분할되지 않은 평균 계산, 비용은 `O(n)`

```javascript
for (let i = 0; i < n; i++) sum += i;
let avg = sum / n;
console.log('평균: ' + avg);
```

예제 2: 분할된 평균 계산, `n`개의 비동기 단계 각각의 비용은 `O(1)`

```javascript
function asyncAvg(n, avgCB) {
  // 진행 중인 합계를 JS 클로저에 저장
  let sum = 0;
  function help(i, cb) {
    sum += i;
    if (i == n) {
      cb(sum);
      return;
    }

    // "비동기 재귀"
    // 다음 연산을 비동기적으로 스케줄링
    setImmediate(help.bind(null, i + 1, cb));
  }

  // avgCB를 호출할 CB로 helper 시작
  help(1, function (sum) {
    let avg = sum / n;
    avgCB(avg);
  });
}

asyncAvg(n, function (avg) {
  console.log('1-n의 평균: ' + avg);
});
```

이 원칙은 배열 순회 등에도 적용할 수 있다.

#### 오프로딩

더 복잡한 작업을 수행해야 한다면 분할은 좋은 선택이 아니다.
분할은 이벤트 루프만 사용하기 때문에 시스템에서 거의 확실히 사용 가능한 여러 코어의 이점을 활용하지 못하기 때문이다.
_이벤트 루프는 클라이언트 요청을 조율해야 하며, 직접 처리해서는 안 된다는 점을 기억하자._
복잡한 작업의 경우, 작업을 이벤트 루프에서 워커 풀로 옮기면 된다.

##### 오프로딩 방법

작업을 옮길 워커 풀로 두 가지 선택지가 있다.

1. Node.js의 내장 워커 풀을 사용하려면 [C++ 애드온](https://nodejs.org/api/addons.html)을 개발하면 된다. Node.js의 구 버전에서는 [NAN](https://github.com/nodejs/nan)을 사용해 C++ 애드온을 빌드하고, 새 버전에서는 [N-API](https://nodejs.org/api/n-api.html)를 사용한다. [node-webworker-threads](https://www.npmjs.com/package/webworker-threads)는 자바스크립트만으로 Node.js 워커 풀에 접근하는 방법을 제공한다.

2. Node.js의 입출력 중심 워커 풀이 아닌, 계산 전용 워커 풀을 직접 생성하고 관리할 수 있다. 가장 간단한 방법은 [Child Process](https://nodejs.org/api/child_process.html)나 [Cluster](https://nodejs.org/api/cluster.html)를 사용하는 것이다.

클라이언트마다 [자식 프로세스](https://nodejs.org/api/child_process.html)를 생성하는 것은 _피해야 한다_.
자식 프로세스를 생성하고 관리하는 것보다 더 빠르게 클라이언트 요청을 받을 수 있어서, 서버가 [포크 폭탄](https://en.wikipedia.org/wiki/Fork_bomb)이 될 수 있다.

##### 오프로딩의 단점

오프로딩 방식의 단점은 _통신 비용_ 형태의 오버헤드가 발생한다는 점이다.
오직 이벤트 루프만이 애플리케이션의 "네임스페이스"(자바스크립트 상태)를 볼 수 있다.
워커에서는 이벤트 루프의 네임스페이스에 있는 자바스크립트 객체를 직접 조작할 수 없다.
대신 공유하려는 객체를 직렬화하고 역직렬화해야 한다.
그러면 워커는 이 객체의 자체 복사본에 대해 작업하고 수정된 객체(또는 "패치")를 이벤트 루프에 반환할 수 있다.

직렬화와 관련된 우려사항은 JSON DOS 섹션을 참조하면 된다.

##### 오프로딩을 위한 제안

CPU 집약적인 작업과 입출력 집약적인 작업은 뚜렷하게 다른 특성을 가지므로 구분하는 것이 좋다.

CPU 집약적인 작업은 워커가 스케줄링될 때만 진행되며, 워커는 시스템의 [논리적 코어](https://nodejs.org/api/os.html#os_os_cpus) 중 하나에 스케줄링되어야 한다.
논리적 코어가 4개이고 워커가 5개라면, 이 워커 중 하나는 진행할 수 없다.
결과적으로 이 워커에 대한 오버헤드(메모리와 스케줄링 비용)는 발생하지만 아무런 이득도 얻지 못한다.

입출력 집약적인 작업은 외부 서비스 제공자(DNS, 파일 시스템 등)에 질의하고 응답을 기다리는 것을 포함한다.
입출력 집약적인 작업을 수행하는 워커가 응답을 기다리는 동안에는 할 일이 없으므로 운영체제가 스케줄에서 제외할 수 있고, 이때 다른 워커가 요청을 제출할 기회를 갖는다.
따라서 _입출력 집약적인 작업은 연관된 스레드가 실행되고 있지 않더라도 진행된다_.
데이터베이스나 파일 시스템과 같은 외부 서비스 제공자는 많은 대기 중인 요청을 동시에 처리하도록 고도로 최적화되어 있다.
예를 들어, 파일 시스템은 많은 대기 중인 쓰기와 읽기 요청을 검토하여 충돌하는 업데이트를 병합하고 최적의 순서로 파일을 검색한다.

Node.js 워커 풀과 같은 하나의 워커 풀에만 의존한다면, CPU 바운드 작업과 입출력 바운드 작업의 서로 다른 특성이 애플리케이션의 성능을 해칠 수 있다.

이러한 이유로 별도의 계산 워커 풀을 유지하는 것을 고려할 수 있다.

#### 오프로딩: 결론

임의로 긴 배열의 요소를 순회하는 것과 같은 간단한 작업의 경우 분할이 좋은 선택일 수 있다.
계산이 더 복잡하다면 오프로딩이 더 나은 접근 방식이다. 이벤트 루프와 워커 풀 사이에서 직렬화된 객체를 주고받는 통신 비용, 즉 오버헤드는 여러 코어를 사용하는 이점으로 상쇄된다.

하지만 서버가 복잡한 계산에 크게 의존한다면 Node.js가 정말 좋은 선택인지 다시 생각해봐야 한다. Node.js는 입출력 바운드 작업에서는 뛰어나지만, 비용이 많이 드는 계산에는 최선의 선택이 아닐 수 있다.

오프로딩 접근 방식을 택한다면 워커 풀을 차단하지 않는 방법에 대한 섹션을 참고하면 된다.

## 워커 풀을 차단하지 않기

Node.js는 `k`개의 워커로 구성된 워커 풀을 가지고 있다.
위에서 논의한 오프로딩 패러다임을 사용한다면 별도의 계산 워커 풀을 가질 수 있으며, 이 경우에도 같은 원칙이 적용된다.
어떤 경우든 `k`가 동시에 처리할 수 있는 클라이언트 수보다 훨씬 작다고 가정하자.
이는 Node.js의 확장성의 비결인 "하나의 스레드로 많은 클라이언트 처리" 철학과 일치한다.

위에서 설명했듯이, 각 워커는 워커 풀 큐에서 다음 작업으로 진행하기 전에 현재 작업을 완료한다.

이제 클라이언트 요청을 처리하는 데 필요한 작업의 비용에 변동이 있을 것이다.
어떤 작업은 빠르게 완료할 수 있고(예: 짧거나 캐시된 파일 읽기, 또는 적은 수의 난수 생성), 다른 작업은 더 오래 걸린다(예: 더 크거나 캐시되지 않은 파일 읽기, 또는 더 많은 난수 생성).
목표는 _작업 시간의 변동을 최소화하는 것_이어야 하며, 이를 위해 _작업 분할_을 사용해야 한다.

### 작업 시간 변동 최소화하기

워커가 현재 수행 중인 작업이 다른 작업보다 훨씬 더 많은 비용이 든다면, 해당 워커는 다른 대기 중인 작업을 처리할 수 없다.
다시 말해, _상대적으로 긴 작업 하나가 완료될 때까지 워커 풀의 크기를 실질적으로 1만큼 감소시키는 효과가 있다_.
이는 바람직하지 않다. 어느 정도까지는 워커 풀의 워커 수가 많을수록 워커 풀의 처리량(초당 작업 수)이 증가하고, 따라서 서버의 처리량(초당 클라이언트 요청 수)도 증가하기 때문이다.
상대적으로 비용이 많이 드는 작업을 가진 클라이언트 하나가 워커 풀의 처리량을 감소시키고, 이는 서버의 처리량 감소로 이어진다.

이를 방지하려면 워커 풀에 제출하는 작업의 길이 변동을 최소화해야 한다.
입출력 요청이 접근하는 외부 시스템(데이터베이스, 파일 시스템 등)을 블랙박스로 취급하는 것이 적절하지만, 이러한 입출력 요청의 상대적 비용을 인지하고 특별히 오래 걸릴 것으로 예상되는 요청은 피해야 한다.

두 가지 예제를 통해 작업 시간의 변동 가능성을 살펴보자.

#### 변동 예제 1: 오래 실행되는 파일 시스템 읽기

서버가 일부 클라이언트 요청을 처리하기 위해 파일을 읽어야 한다고 가정하자.
Node.js [파일 시스템](https://nodejs.org/api/fs.html) API를 검토한 후 단순성을 위해 `fs.readFile()`을 사용하기로 했다.
하지만 `fs.readFile()`은 ([현재](https://github.com/nodejs/node/pull/17054)) 분할되지 않는다: 파일 전체를 포괄하는 단일 `fs.read()` 작업을 제출한다.
일부 사용자에게는 짧은 파일을, 다른 사용자에게는 긴 파일을 읽는다면, `fs.readFile()`이 작업 길이에 상당한 변동을 초래할 수 있어 워커 풀의 처리량에 나쁜 영향을 미친다.

최악의 시나리오로, 공격자가 서버로 하여금 _임의의_ 파일을 읽도록 설득할 수 있다고 가정해보자(이는 [디렉터리 순회 취약점](https://www.owasp.org/index.php/Path_Traversal)이다).
서버가 리눅스에서 실행 중이라면, 공격자는 극도로 느린 파일을 지정할 수 있다: [`/dev/random`](http://man7.org/linux/man-pages/man4/random.4.html).
실질적으로 `/dev/random`은 무한히 느리며, `/dev/random`에서 읽도록 지시받은 모든 워커는 그 작업을 절대 완료하지 못한다.
공격자가 각 워커에 대해 하나씩, `k`개의 요청을 제출하면 워커 풀을 사용하는 다른 클라이언트 요청은 전혀 진행되지 않는다.

#### 변동 예제 2: 오래 실행되는 암호화 연산

서버가 [`crypto.randomBytes()`](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)를 사용하여 암호학적으로 안전한 난수 바이트를 생성한다고 가정하자.
`crypto.randomBytes()`는 분할되지 않는다: 요청한 만큼의 바이트를 생성하는 단일 `randomBytes()` 작업을 생성한다.
일부 사용자에게는 적은 수의 바이트를, 다른 사용자에게는 더 많은 바이트를 생성한다면, `crypto.randomBytes()`도 작업 길이의 변동을 초래하는 또 다른 원인이 된다.

### 작업 분할

시간 비용이 변동하는 작업은 워커 풀의 처리량을 저하시킬 수 있다.
작업 시간의 변동을 최소화하려면, 가능한 한 각 작업을 비슷한 비용의 하위 작업으로 _분할_해야 한다.
각 하위 작업이 완료되면 다음 하위 작업을 제출하고, 마지막 하위 작업이 완료되면 제출자에게 알려야 한다.

`fs.readFile()` 예제로 돌아가서, 대신 `fs.read()`(수동 분할)나 `ReadStream`(자동 분할)을 사용해야 한다.

같은 원칙이 CPU 바운드 작업에도 적용된다. `asyncAvg` 예제는 이벤트 루프에는 적합하지 않을 수 있지만, 워커 풀에는 잘 맞는다.

작업을 하위 작업으로 분할하면, 짧은 작업은 적은 수의 하위 작업으로 확장되고 긴 작업은 더 많은 수의 하위 작업으로 확장된다.
긴 작업의 하위 작업들 사이에서 해당 작업이 할당된 워커가 다른 짧은 작업의 하위 작업을 처리할 수 있어, 워커 풀의 전체적인 작업 처리량이 향상된다.

완료된 하위 작업의 수는 워커 풀의 처리량을 측정하는 데 유용한 지표가 아니라는 점에 유의하자.
대신 완료된 _작업_ 수에 집중해야 한다.

### 작업 분할 피하기

작업 분할의 목적은 작업 시간의 변동을 최소화하는 것임을 상기하자.
짧은 작업과 긴 작업을 구분할 수 있다면(예: 배열의 합계 계산과 정렬), 각 작업 클래스에 대해 별도의 워커 풀을 생성할 수 있다.
짧은 작업과 긴 작업을 별도의 워커 풀로 라우팅하는 것도 작업 시간 변동을 최소화하는 또 다른 방법이다.

이 접근 방식의 장점으로, 작업 분할은 오버헤드(워커 풀 작업 표현을 생성하고 워커 풀 큐를 조작하는 비용)를 수반하며, 분할을 피하면 워커 풀을 추가로 방문하는 비용을 절약할 수 있다.
또한 작업 분할 시 실수를 방지할 수 있다.

이 접근 방식의 단점은 이러한 모든 워커 풀의 워커가 공간과 시간 오버헤드를 발생시키고 CPU 시간을 놓고 서로 경쟁한다는 점이다.
각 CPU 바운드 작업은 스케줄링될 때만 진행된다는 점을 기억하자.
따라서 신중한 분석 후에만 이 접근 방식을 고려해야 한다.

## npm 모듈 사용 시 위험성

Node.js 핵심 모듈은 다양한 애플리케이션을 위한 기본 구성 요소를 제공하지만, 때로는 그 이상이 필요하다. Node.js 개발자는 [npm 생태계](https://www.npmjs.com/)의 수십만 개 모듈을 통해 개발 과정을 가속화할 수 있어 큰 혜택을 받는다.

하지만 이러한 모듈 대부분은 서드파티 개발자가 작성했으며, 일반적으로 최선의 노력을 기반으로 한 보증만 제공한다는 점을 기억해야 한다. npm 모듈을 사용하는 개발자는 두 가지 사항을 고려해야 하는데, 후자는 흔히 간과된다.

1. API를 제대로 준수하는가?
2. API가 이벤트 루프나 워커를 차단할 가능성은 없는가?
   많은 모듈이 API의 비용을 명시하지 않아 커뮤니티에 악영향을 미친다.

간단한 API의 경우 API 비용을 추정할 수 있다. 문자열 조작의 비용은 쉽게 짐작할 수 있기 때문이다.
하지만 많은 경우 API가 얼마나 비용이 많이 들지 명확하지 않다.

_비용이 많이 들 수 있는 API를 호출한다면 비용을 다시 한번 확인하라. 개발자에게 문서화를 요청하거나 소스 코드를 직접 검토하고 (비용을 문서화하는 PR을 제출하라)._

API가 비동기식이더라도 각 분할에서 워커나 이벤트 루프에서 얼마나 시간을 보낼지 알 수 없다는 점을 기억하라.
예를 들어, 위에서 본 `asyncAvg` 예제에서 도우미 함수가 숫자 하나가 아닌 _절반의_ 숫자를 합산한다고 가정해보자.
이 함수는 여전히 비동기식이지만 각 분할의 비용이 `O(1)`이 아닌 `O(n)`이 되어 임의의 `n` 값에 대해 안전하게 사용하기가 훨씬 어려워진다.

## 결론

Node.js에는 두 종류의 스레드가 있다: 하나의 이벤트 루프와 `k`개의 워커다.
이벤트 루프는 자바스크립트 콜백과 비차단 입출력을 담당하고, 워커는 비동기 요청을 완료하는 C++ 코드에 해당하는 작업(차단 입출력과 CPU 집약적 작업 포함)을 실행한다.
두 종류의 스레드 모두 한 번에 하나의 활동만 수행한다.
콜백이나 작업이 오래 걸리면 해당 스레드는 _차단_된다.
애플리케이션이 차단하는 콜백이나 작업을 만든다면, 이는 최선의 경우 처리량(초당 클라이언트 수) 저하로 이어지고 최악의 경우 완전한 서비스 거부로 이어질 수 있다.

높은 처리량과 DoS에 더 강한 웹 서버를 작성하려면, 정상 입력과 악의적인 입력 모두에 대해 이벤트 루프나 워커가 차단되지 않도록 해야 한다.