# Table of Contents

- [[Security Best Practices](https://nodejs.org/ko/learn/getting-started/security-best-practices#security-best-practices)](#security-best-practiceshttpsnodejsorgkolearngetting-startedsecurity-best-practicessecurity-best-practices)
  - [[의도](https://nodejs.org/ko/learn/getting-started/security-best-practices#intent)](#의도httpsnodejsorgkolearngetting-startedsecurity-best-practicesintent)
  - [[문서 내용](https://nodejs.org/ko/learn/getting-started/security-best-practices#document-content)](#문서-내용httpsnodejsorgkolearngetting-startedsecurity-best-practicesdocument-content)
  - [[Threat List](https://nodejs.org/ko/learn/getting-started/security-best-practices#threat-list)](#threat-listhttpsnodejsorgkolearngetting-startedsecurity-best-practicesthreat-list)
    - [[HTTP 서버의 서비스 거부 공격 (CWE-400)](https://nodejs.org/ko/learn/getting-started/security-best-practices#denial-of-service-of-http-server-cwe-400)](#http-서버의-서비스-거부-공격-cwe-400httpsnodejsorgkolearngetting-startedsecurity-best-practicesdenial-of-service-of-http-server-cwe-400)
    - [[DNS 리바인딩 (CWE-346)](https://nodejs.org/ko/learn/getting-started/security-best-practices#dns-rebinding-cwe-346)](#dns-리바인딩-cwe-346httpsnodejsorgkolearngetting-startedsecurity-best-practicesdns-rebinding-cwe-346)
    - [[민감한 정보가 권한 없는 사용자에게 노출되는 문제 (CWE-552)](https://nodejs.org/ko/learn/getting-started/security-best-practices#exposure-of-sensitive-information-to-an-unauthorized-actor-cwe-552)](#민감한-정보가-권한-없는-사용자에게-노출되는-문제-cwe-552httpsnodejsorgkolearngetting-startedsecurity-best-practicesexposure-of-sensitive-information-to-an-unauthorized-actor-cwe-552)
    - [[HTTP Request Smuggling (CWE-444)](https://nodejs.org/ko/learn/getting-started/security-best-practices#http-request-smuggling-cwe-444)](#http-request-smuggling-cwe-444httpsnodejsorgkolearngetting-startedsecurity-best-practiceshttp-request-smuggling-cwe-444)
    - [[타이밍 공격을 통한 정보 노출 (CWE-208)](https://nodejs.org/ko/learn/getting-started/security-best-practices#information-exposure-through-timing-attacks-cwe-208)](#타이밍-공격을-통한-정보-노출-cwe-208httpsnodejsorgkolearngetting-startedsecurity-best-practicesinformation-exposure-through-timing-attacks-cwe-208)
    - [[악성 서드파티 모듈 (CWE-1357)](https://nodejs.org/ko/learn/getting-started/security-best-practices#malicious-third-party-modules-cwe-1357)](#악성-서드파티-모듈-cwe-1357httpsnodejsorgkolearngetting-startedsecurity-best-practicesmalicious-third-party-modules-cwe-1357)
      - [[공급망 공격](https://nodejs.org/ko/learn/getting-started/security-best-practices#supply-chain-attacks)](#공급망-공격httpsnodejsorgkolearngetting-startedsecurity-best-practicessupply-chain-attacks)
    - [[메모리 접근 위반 (CWE-284)](https://nodejs.org/ko/learn/getting-started/security-best-practices#memory-access-violation-cwe-284)](#메모리-접근-위반-cwe-284httpsnodejsorgkolearngetting-startedsecurity-best-practicesmemory-access-violation-cwe-284)
    - [[Monkey Patching (CWE-349)](https://nodejs.org/ko/learn/getting-started/security-best-practices#monkey-patching-cwe-349)](#monkey-patching-cwe-349httpsnodejsorgkolearngetting-startedsecurity-best-practicesmonkey-patching-cwe-349)
    - [[프로토타입 오염 공격 (CWE-1321)](https://nodejs.org/ko/learn/getting-started/security-best-practices#prototype-pollution-attacks-cwe-1321)](#프로토타입-오염-공격-cwe-1321httpsnodejsorgkolearngetting-startedsecurity-best-practicesprototype-pollution-attacks-cwe-1321)
    - [[제어되지 않은 검색 경로 엘리먼트 (CWE-427)](https://nodejs.org/ko/learn/getting-started/security-best-practices#uncontrolled-search-path-element-cwe-427)](#제어되지-않은-검색-경로-엘리먼트-cwe-427httpsnodejsorgkolearngetting-startedsecurity-best-practicesuncontrolled-search-path-element-cwe-427)
  - [[프로덕션 환경에서 실험적 기능 사용](https://nodejs.org/ko/learn/getting-started/security-best-practices#experimental-features-in-production)](#프로덕션-환경에서-실험적-기능-사용httpsnodejsorgkolearngetting-startedsecurity-best-practicesexperimental-features-in-production)
  - [[OpenSSF 도구](https://nodejs.org/ko/learn/getting-started/security-best-practices#openssf-tools)](#openssf-도구httpsnodejsorgkolearngetting-startedsecurity-best-practicesopenssf-tools)

# [Security Best Practices](https://nodejs.org/ko/learn/getting-started/security-best-practices#security-best-practices)





## [의도](https://nodejs.org/ko/learn/getting-started/security-best-practices#intent)

이 문서는 현재의 [위협 모델](https://github.com/nodejs/node/security/policy#the-nodejs-threat-model)을 확장하고, Node.js 애플리케이션을 보호하는 방법에 대한 포괄적인 가이드라인을 제공하기 위해 작성되었습니다.


## [문서 내용](https://nodejs.org/ko/learn/getting-started/security-best-practices#document-content)

- **모범 사례**: 모범 사례를 간략하게 요약한 내용입니다. [이 이슈](https://github.com/nodejs/security-wg/issues/488)나 [이 가이드라인](https://github.com/goldbergyoni/nodebestpractices)을 시작점으로 활용할 수 있습니다. 이 문서는 Node.js에 특화된 내용이므로, 더 넓은 범위의 정보를 원한다면 [OSSF 모범 사례](https://github.com/ossf/wg-best-practices-os-developers)를 참고하세요.
  
- **공격 설명**: 위협 모델에서 언급한 공격들을 평이한 영어로 설명하고, 가능한 경우 코드 예제를 함께 제공합니다.

- **서드파티 라이브러리**: 노드 모듈 의존성과 관련된 위협(타이포스쿼팅 공격, 악성 패키지 등)과 모범 사례를 정의합니다.


## [Threat List](https://nodejs.org/ko/learn/getting-started/security-best-practices#threat-list)





### [HTTP 서버의 서비스 거부 공격 (CWE-400)](https://nodejs.org/ko/learn/getting-started/security-best-practices#denial-of-service-of-http-server-cwe-400)

이 공격은 애플리케이션이 들어오는 HTTP 요청을 처리하는 방식 때문에 의도한 목적에 맞게 사용할 수 없게 되는 상황을 말합니다. 이러한 요청은 악의적인 행위자가 의도적으로 만들 필요가 없습니다. 잘못 구성되었거나 버그가 있는 클라이언트도 서버에 서비스 거부를 유발하는 패턴의 요청을 보낼 수 있습니다.

Node.js HTTP 서버는 HTTP 요청을 받아 등록된 요청 핸들러를 통해 애플리케이션 코드로 전달합니다. 서버는 요청 본문의 내용을 파싱하지 않습니다. 따라서 요청 핸들러로 전달된 후 본문의 내용으로 인해 발생하는 서비스 거부는 Node.js 자체의 취약점이 아닙니다. 이를 올바르게 처리하는 것은 애플리케이션 코드의 책임입니다.

웹 서버가 소켓 오류를 올바르게 처리하는지 확인해야 합니다. 예를 들어, 오류 핸들러 없이 서버를 생성하면 서비스 거부 공격에 취약해질 수 있습니다.

```javascript
import net from 'node:net';

const server = net.createServer(function (socket) {
  // socket.on('error', console.error) // 이 코드를 추가하면 서버가 크래시되지 않음
  socket.write('Echo server\r\n');
  socket.pipe(socket);
});

server.listen(5000, '0.0.0.0');
```

잘못된 요청이 발생하면 서버가 크래시될 수 있습니다.

요청의 내용과 무관하게 발생하는 서비스 거부 공격의 예로 [Slowloris](https://en.wikipedia.org/wiki/Slowloris_(computer_security))가 있습니다. 이 공격에서는 HTTP 요청을 느리게 조각내어 보냅니다. 전체 요청이 전달될 때까지 서버는 진행 중인 요청에 리소스를 할당합니다. 동시에 충분한 수의 요청이 보내지면 동시 연결 수가 곧 최대치에 도달하여 서비스 거부가 발생합니다. 이 공격은 요청의 내용이 아니라 요청의 타이밍과 패턴에 의존합니다.

**대응 방안**

- 리버스 프록시를 사용하여 요청을 받아 Node.js 애플리케이션으로 전달합니다. 리버스 프록시는 캐싱, 로드 밸런싱, IP 블랙리스트 등을 제공하여 서비스 거부 공격의 가능성을 줄입니다.
- 서버 타임아웃을 올바르게 구성하여 유휴 상태이거나 요청이 너무 느리게 도착하는 연결을 끊을 수 있도록 합니다. [`http.Server`](https://nodejs.org/api/http.html#class-httpserver)의 `headersTimeout`, `requestTimeout`, `timeout`, `keepAliveTimeout` 등의 다양한 타임아웃 설정을 참고하세요.
- 호스트당 및 전체적으로 열린 소켓의 수를 제한합니다. [http 문서](https://nodejs.org/api/http.html)의 `agent.maxSockets`, `agent.maxTotalSockets`, `agent.maxFreeSockets`, `server.maxRequestsPerSocket`를 참고하세요.


### [DNS 리바인딩 (CWE-346)](https://nodejs.org/ko/learn/getting-started/security-best-practices#dns-rebinding-cwe-346)

이 공격은 [\--inspect 스위치](https://nodejs.org/ko/learn/getting-started/debugging)를 사용해 디버깅 인스펙터를 활성화한 상태에서 실행 중인 Node.js 애플리케이션을 대상으로 할 수 있습니다.

웹 브라우저에서 열린 웹사이트는 WebSocket 및 HTTP 요청을 보낼 수 있기 때문에, 로컬에서 실행 중인 디버깅 인스펙터를 공격할 수 있습니다. 이는 일반적으로 현대 브라우저에서 구현된 [동일 출처 정책](https://nodejs.org/ko/learn/getting-started/debugging)에 의해 방지됩니다. 이 정책은 스크립트가 다른 오리진의 리소스에 접근하는 것을 금지하므로, 악성 웹사이트가 로컬 IP 주소에서 요청한 데이터를 읽을 수 없습니다.

하지만 DNS 리바인딩을 통해 공격자는 일시적으로 요청의 출처를 제어하여 로컬 IP 주소에서 온 것처럼 보이게 할 수 있습니다. 이는 웹사이트와 해당 IP 주소를 해석하는 DNS 서버를 모두 제어함으로써 가능합니다. 자세한 내용은 [DNS 리바인딩 위키](https://en.wikipedia.org/wiki/DNS_rebinding)를 참고하세요.

**대응 방안**

-   `process.on(‘SIGUSR1’, …)` 리스너를 추가해 *SIGUSR1* 신호가 발생할 때 인스펙터를 비활성화합니다.
-   프로덕션 환경에서 인스펙터 프로토콜을 실행하지 않습니다.


### [민감한 정보가 권한 없는 사용자에게 노출되는 문제 (CWE-552)](https://nodejs.org/ko/learn/getting-started/security-best-practices#exposure-of-sensitive-information-to-an-unauthorized-actor-cwe-552)

패키지를 배포할 때 현재 디렉토리에 포함된 모든 파일과 폴더가 npm 레지스트리로 푸시됩니다. 

이러한 동작을 제어하기 위해 `.npmignore`와 `.gitignore`를 사용해 차단 목록을 정의하거나, `package.json`에서 허용 목록을 정의할 수 있습니다.

**해결 방법**

- `npm publish --dry-run`을 사용해 배포할 파일 목록을 확인합니다. 패키지를 배포하기 전에 내용을 꼼꼼히 검토하세요.
- `.gitignore`와 `.npmignore` 같은 무시 파일을 생성하고 유지하는 것도 중요합니다. 이 파일들을 통해 배포하지 않아야 할 파일이나 폴더를 지정할 수 있습니다. `package.json`의 [files 속성](https://docs.npmjs.com/cli/configuring-npm/package-json#files)은 반대로 허용 목록을 정의할 수 있게 해줍니다.
- 정보가 노출된 경우, [패키지 배포를 취소](https://docs.npmjs.com/unpublishing-packages-from-the-registry)하세요.


### [HTTP Request Smuggling (CWE-444)](https://nodejs.org/ko/learn/getting-started/security-best-practices#http-request-smuggling-cwe-444)

이 공격은 두 개의 HTTP 서버(보통 프록시와 Node.js 애플리케이션)를 대상으로 합니다. 클라이언트가 HTTP 요청을 보내면, 이 요청은 먼저 프론트엔드 서버(프록시)를 거친 후 백엔드 서버(애플리케이션)로 전달됩니다. 프론트엔드와 백엔드가 모호한 HTTP 요청을 다르게 해석할 경우, 공격자가 프론트엔드에서는 보이지 않지만 백엔드에서는 보이는 악성 메시지를 보낼 수 있습니다. 이로 인해 프록시 서버를 우회하여 메시지를 "밀어넣는" 효과가 발생합니다.

자세한 설명과 예제는 [CWE-444](https://cwe.mitre.org/data/definitions/444.html)를 참고하세요.

이 공격은 Node.js가 (임의의) HTTP 서버와 다르게 HTTP 요청을 해석하는 데 의존하기 때문에, 성공적인 공격은 Node.js, 프론트엔드 서버 또는 둘 모두의 취약점으로 인해 발생할 수 있습니다. Node.js가 요청을 해석하는 방식이 HTTP 명세([RFC7230](https://datatracker.ietf.org/doc/html/rfc7230#section-3))와 일치한다면, 이는 Node.js의 취약점으로 간주되지 않습니다.

**대응 방안**

-   HTTP 서버를 생성할 때 `insecureHTTPParser` 옵션을 사용하지 마세요.
-   프론트엔드 서버를 설정하여 모호한 요청을 정규화하세요.
-   Node.js와 선택한 프론트엔드 서버에서 새로운 HTTP 요청 밀어넣기 취약점을 지속적으로 모니터링하세요.
-   가능하다면 HTTP/2를 끝까지 사용하고 HTTP 다운그레이드를 비활성화하세요.


### [타이밍 공격을 통한 정보 노출 (CWE-208)](https://nodejs.org/ko/learn/getting-started/security-best-practices#information-exposure-through-timing-attacks-cwe-208)

이 공격은 공격자가 애플리케이션이 요청에 응답하는 데 걸리는 시간을 측정함으로써 민감한 정보를 알아낼 수 있게 합니다. 이 공격은 Node.js에만 국한되지 않으며 거의 모든 런타임을 대상으로 할 수 있습니다.

이 공격은 애플리케이션이 타이밍에 민감한 작업(예: 분기)에서 비밀 값을 사용할 때 가능합니다. 일반적인 애플리케이션에서 인증을 처리하는 경우를 생각해 보겠습니다. 여기서 기본적인 인증 방법은 이메일과 비밀번호를 자격 증명으로 사용합니다. 사용자 정보는 사용자가 입력한 정보를 통해 DBMS에서 가져옵니다. 사용자 정보를 가져온 후, 비밀번호를 데이터베이스에서 가져온 사용자 정보와 비교합니다. 내장된 문자열 비교 함수는 같은 길이의 값에 대해 더 오랜 시간이 걸립니다. 이 비교 작업은 허용 가능한 시간 동안 실행되면서 요청의 응답 시간을 늘리게 됩니다. 공격자는 요청 응답 시간을 비교하여 대량의 요청을 통해 비밀번호의 길이와 값을 추측할 수 있습니다.

**완화 방법**

-   crypto API는 `timingSafeEqual` 함수를 제공하여 상수 시간 알고리즘을 사용해 실제 값과 예상 값을 비교합니다.
    
-   비밀번호 비교를 위해 네이티브 crypto 모듈에서 제공하는 [scrypt](https://nodejs.org/api/crypto.html#cryptoscryptpassword-salt-keylen-options-callback)를 사용할 수 있습니다.
    
-   더 일반적으로, 비밀 값을 가변 시간 작업에서 사용하지 않도록 합니다. 이는 비밀 값에 대한 분기 작업과, 공격자가 동일한 인프라(예: 동일한 클라우드 머신)에 있을 경우 메모리 인덱스로 비밀 값을 사용하는 것을 포함합니다. JavaScript에서 상수 시간 코드를 작성하는 것은 어렵습니다(부분적으로 JIT 때문입니다). 암호화 애플리케이션의 경우 내장된 crypto API나 WebAssembly(네이티브로 구현되지 않은 알고리즘의 경우)를 사용하세요.


### [악성 서드파티 모듈 (CWE-1357)](https://nodejs.org/ko/learn/getting-started/security-best-practices#malicious-third-party-modules-cwe-1357)

현재 Node.js에서는 모든 패키지가 네트워크 접근과 같은 강력한 리소스에 접근할 수 있습니다. 또한 파일 시스템에 접근할 수 있기 때문에, 데이터를 어디로든 전송할 수 있습니다.

Node 프로세스에서 실행되는 모든 코드는 `eval()`(또는 이와 동등한 기능)을 사용해 추가적인 임의의 코드를 로드하고 실행할 수 있습니다. 파일 시스템에 쓰기 권한이 있는 모든 코드는 새로운 파일을 생성하거나 기존 파일을 수정하여 동일한 작업을 수행할 수 있습니다.

Node.js는 로드된 리소스를 신뢰할 수 없거나 신뢰할 수 있는 것으로 선언할 수 있는 실험적인 [정책 메커니즘](https://nodejs.org/api/permissions.html#policies)을 제공합니다. 하지만 이 정책은 기본적으로 활성화되어 있지 않습니다. 따라서 의존성 버전을 고정하고, 일반적인 워크플로우나 npm 스크립트를 사용해 취약점에 대한 자동 검사를 실행해야 합니다. 패키지를 설치하기 전에 해당 패키지가 관리되고 있으며, 예상한 모든 내용을 포함하고 있는지 확인하세요. 주의할 점은 GitHub 소스 코드가 항상 배포된 코드와 동일하지 않을 수 있으므로, *node_modules*에서 이를 검증해야 합니다.


#### [공급망 공격](https://nodejs.org/ko/learn/getting-started/security-best-practices#supply-chain-attacks)

Node.js 애플리케이션에서 공급망 공격은 직접적이거나 간접적인 의존성 중 하나가 손상되었을 때 발생합니다. 이는 애플리케이션이 의존성 지정에 너무 느슨하거나(원치 않는 업데이트를 허용) 의존성 지정에 흔한 오타가 있을 때([타이포스쿼팅](https://en.wikipedia.org/wiki/Typosquatting)에 취약) 발생할 수 있습니다.

공격자가 상위 패키지를 제어하면 악성 코드가 포함된 새 버전을 배포할 수 있습니다. Node.js 애플리케이션이 안전한 버전을 엄격히 지정하지 않고 해당 패키지에 의존하면, 패키지가 자동으로 최신 악성 버전으로 업데이트되어 애플리케이션이 손상될 수 있습니다.

`package.json` 파일에 지정된 의존성은 정확한 버전 번호나 범위를 가질 수 있습니다. 그러나 의존성을 정확한 버전으로 고정하더라도, 그 의존성의 간접 의존성은 고정되지 않습니다. 이는 여전히 애플리케이션을 원치 않거나 예상치 못한 업데이트에 취약하게 만듭니다.

가능한 공격 벡터:

-   타이포스쿼팅 공격
-   Lockfile 오염
-   유지 관리자 계정 해킹
-   악성 패키지
-   의존성 혼동

**완화 방법**

-   `--ignore-scripts`를 사용해 npm이 임의의 스크립트를 실행하지 못하게 합니다.
    -   추가적으로, 전역적으로 비활성화하려면 `npm config set ignore-scripts true`를 사용합니다.
-   의존성 버전을 특정 불변 버전으로 고정합니다. 범위나 변경 가능한 소스의 버전은 피합니다.
-   모든 의존성(직접 및 간접)을 고정하는 lockfile을 사용합니다.
    -   [Lockfile 오염 완화 방법](https://blog.ulisesgascon.com/lockfile-posioned)을 참고합니다.
-   CI를 사용해 새로운 취약점을 자동으로 검사합니다. [`npm-audit`](https://docs.npmjs.com/cli/commands/npm-audit)과 같은 도구를 활용합니다.
    -   [`Socket`](https://socket.dev/)과 같은 도구를 사용해 패키지를 정적 분석으로 검사하여 네트워크나 파일 시스템 접근과 같은 위험한 동작을 찾습니다.
-   `npm install` 대신 [`npm ci`](https://docs.npmjs.com/cli/v8/commands/npm-ci)를 사용합니다. 이는 lockfile을 강제로 적용하여 *package.json* 파일과의 불일치가 발생할 때 오류를 발생시킵니다(lockfile을 무시하고 *package.json*을 우선하지 않습니다).
-   *package.json* 파일에서 의존성 이름의 오류나 오타를 주의 깊게 확인합니다.


### [메모리 접근 위반 (CWE-284)](https://nodejs.org/ko/learn/getting-started/security-best-practices#memory-access-violation-cwe-284)

메모리 기반 또는 힙 기반 공격은 메모리 관리 오류와 악용 가능한 메모리 할당자의 조합에 의존합니다. 모든 런타임과 마찬가지로, 여러분의 프로젝트가 공유 머신에서 실행된다면 Node.js도 이러한 공격에 취약합니다. **보안 힙(secure heap)**을 사용하면 포인터 오버런과 언더런으로 인한 민감한 정보 유출을 방지하는 데 도움이 됩니다.

하지만, Windows에서는 보안 힙을 사용할 수 없습니다. 더 자세한 정보는 Node.js의 [보안 힙 문서](https://nodejs.org/dist/latest-v18.x/docs/api/cli.html#--secure-heapn)에서 확인할 수 있습니다.

**대응 방안**

- 애플리케이션에 따라 `--secure-heap=n`을 사용하세요. 여기서 *n*은 할당할 최대 바이트 크기입니다.
- 프로덕션 앱을 공유 머신에서 실행하지 마세요.


### [Monkey Patching (CWE-349)](https://nodejs.org/ko/learn/getting-started/security-best-practices#monkey-patching-cwe-349)

Monkey patching은 런타임에서 프로퍼티를 수정하여 기존 동작을 변경하는 것을 의미합니다. 예를 들어:

```javascript
// eslint-disable-next-line no-extend-native
Array.prototype.push = function (item) {
  // 전역 [].push를 오버라이딩
};
```

**완화 방법**

`--frozen-intrinsics` 플래그는 실험적인 기능으로, 모든 내장 JavaScript 객체와 함수를 재귀적으로 고정시킵니다. 따라서 다음 코드는 `Array.prototype.push`의 기본 동작을 오버라이드하지 못합니다.

```javascript
// eslint-disable-next-line no-extend-native
Array.prototype.push = function (item) {
  // 전역 [].push를 오버라이딩
};

// Uncaught:
// TypeError >>:
// Cannot assign to read only property 'push' of object ''
```

그러나 여전히 `globalThis`를 사용하여 새로운 전역 변수를 정의하거나 기존 전역 변수를 교체할 수 있습니다.

```javascript
> globalThis.foo = 3; foo; // 새로운 전역 변수 정의 가능
3
> globalThis.Array = 4; Array; // 기존 전역 변수 교체 가능
4
```

따라서 `Object.freeze(globalThis)`를 사용하면 전역 변수가 교체되지 않도록 보장할 수 있습니다.


### [프로토타입 오염 공격 (CWE-1321)](https://nodejs.org/ko/learn/getting-started/security-best-practices#prototype-pollution-attacks-cwe-1321)

프로토타입 오염은 자바스크립트의 내장 프로토타입에서 상속된 `__proto__`, `constructor`, `prototype` 등의 속성을 악용하여 자바스크립트 객체의 속성을 수정하거나 주입할 수 있는 가능성을 말합니다.

```javascript
const a = { a: 1, b: 2 };
const data = JSON.parse('{"__proto__": { "polluted": true}}');

const c = Object.assign({}, a, data);
console.log(c.polluted); // true

// 잠재적인 서비스 거부(DoS) 공격
const data2 = JSON.parse('{"__proto__": null}');
const d = Object.assign(a, data2);
d.hasOwnProperty('b'); // Uncaught TypeError: d.hasOwnProperty is not a function
```

이 취약점은 자바스크립트 언어 자체에서 상속된 잠재적인 문제입니다.

**예시**:

-   [CVE-2022-21824](https://www.cvedetails.com/cve/CVE-2022-21824/) (Node.js)
-   [CVE-2018-3721](https://www.cvedetails.com/cve/CVE-2018-3721/) (서드파티 라이브러리: Lodash)

**대응 방안**

-   [안전하지 않은 재귀 병합](https://gist.github.com/DaniAkash/b3d7159fddcff0a9ee035bd10e34b277#file-unsafe-merge-js)을 피하세요. [CVE-2018-16487](https://www.cve.org/CVERecord?id=CVE-2018-16487)를 참고하세요.
-   외부 또는 신뢰할 수 없는 요청에 대해 JSON 스키마 검증을 구현하세요.
-   `Object.create(null)`을 사용하여 프로토타입이 없는 객체를 생성하세요.
-   프로토타입을 고정하세요: `Object.freeze(MyObject.prototype)`.
-   `--disable-proto` 플래그를 사용하여 `Object.prototype.__proto__` 속성을 비활성화하세요.
-   `Object.hasOwn(obj, keyFromObj)`를 사용하여 속성이 프로토타입이 아닌 객체에 직접 존재하는지 확인하세요.
-   `Object.prototype`의 메서드 사용을 피하세요.


### [제어되지 않은 검색 경로 엘리먼트 (CWE-427)](https://nodejs.org/ko/learn/getting-started/security-best-practices#uncontrolled-search-path-element-cwe-427)

Node.js는 [모듈 해결 알고리즘(Module Resolution Algorithm)](https://nodejs.org/api/modules.html#modules_all_together)에 따라 모듈을 로드합니다. 따라서 모듈이 요청된(require) 디렉토리를 신뢰한다고 가정합니다.

이로 인해 다음과 같은 애플리케이션 동작이 예상됩니다. 아래와 같은 디렉토리 구조를 가정해 보겠습니다.

-   *app/*
    -   *server.js*
    -   *auth.js*
    -   *auth*

만약 `server.js`에서 `require('./auth')`를 사용하면, 모듈 해결 알고리즘에 따라 *auth.js* 대신 *auth*를 로드합니다.

**완화 방법**

실험적인 [무결성 검사가 포함된 정책 메커니즘](https://nodejs.org/api/permissions.html#integrity-checks)을 사용하면 위의 위협을 피할 수 있습니다. 위에서 설명한 디렉토리 구조에 대해 다음과 같은 `policy.json`을 사용할 수 있습니다.

```json
{
  "resources": {
    "./app/auth.js": {
      "integrity": "sha256-iuGZ6SFVFpMuHUcJciQTIKpIyaQVigMZlvg9Lx66HV8="
    },
    "./app/server.js": {
      "dependencies": {
        "./auth": "./app/auth.js"
      },
      "integrity": "sha256-NPtLCQ0ntPPWgfVEgX46ryTNpdvTWdQPoZO3kHo0bKI="
    }
  }
}
```

따라서 *auth* 모듈을 요청할 때, 시스템은 무결성을 검증하고 예상된 값과 일치하지 않으면 오류를 발생시킵니다.

```bash
» node --experimental-policy=policy.json app/server.js
node:internal/policy/sri:65
      throw new ERR_SRI_PARSE(str, str[prevIndex], prevIndex);
      ^

SyntaxError [ERR_SRI_PARSE]: Subresource Integrity string "sha256-iuGZ6SFVFpMuHUcJciQTIKpIyaQVigMZlvg9Lx66HV8=%" had an unexpected "%" at position 51
    at new NodeError (node:internal/errors:393:5)
    at Object.parse (node:internal/policy/sri:65:13)
    at processEntry (node:internal/policy/manifest:581:38)
    at Manifest.assertIntegrity (node:internal/policy/manifest:588:32)
    at Module._compile (node:internal/modules/cjs/loader:1119:21)
    at Module._extensions..js (node:internal/modules/cjs/loader:1213:10)
    at Module.load (node:internal/modules/cjs/loader:1037:32)
    at Module._load (node:internal/modules/cjs/loader:878:12)
    at Module.require (node:internal/modules/cjs/loader:1061:19)
    at require (node:internal/modules/cjs/helpers:99:18) {
  code: 'ERR_SRI_PARSE'
}
```

참고로, 정책 뮤테이션을 피하기 위해 항상 `--policy-integrity` 사용을 권장합니다.


## [프로덕션 환경에서 실험적 기능 사용](https://nodejs.org/ko/learn/getting-started/security-best-practices#experimental-features-in-production)

프로덕션 환경에서 실험적 기능을 사용하는 것은 권장하지 않습니다. 실험적 기능은 필요에 따라 중대한 변경이 발생할 수 있으며, 기능이 안정적으로 고정되지 않았습니다. 다만, 피드백은 매우 환영합니다.


## [OpenSSF 도구](https://nodejs.org/ko/learn/getting-started/security-best-practices#openssf-tools)

[OpenSSF](https://openssf.org/)는 여러 유용한 프로젝트를 주도하고 있습니다. 특히 npm 패키지를 배포할 계획이라면 더욱 도움이 될 수 있습니다. 주요 프로젝트는 다음과 같습니다:

-   [OpenSSF Scorecard](https://securityscorecards.dev/)  
    Scorecard는 자동화된 보안 위험 검사를 통해 오픈소스 프로젝트를 평가합니다. 이를 활용하면 코드베이스의 취약점과 의존성을 사전에 점검하고, 취약점 수용 여부에 대한 정보를 바탕으로 결정을 내릴 수 있습니다.
  
-   [OpenSSF Best Practices Badge Program](https://bestpractices.coreinfrastructure.org/en)  
    프로젝트는 각각의 모범 사례를 준수하는 방법을 설명하여 자발적으로 인증을 받을 수 있습니다. 이를 통해 프로젝트에 추가할 수 있는 배지를 생성할 수 있습니다.


