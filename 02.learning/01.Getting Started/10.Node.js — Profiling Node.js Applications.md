# Table of Contents

- [Node.js 애플리케이션 프로파일링](#nodejs-애플리케이션-프로파일링)

# Node.js 애플리케이션 프로파일링

Node.js 애플리케이션을 프로파일링하는 것은 애플리케이션이 실행 중일 때 CPU, 메모리 및 기타 런타임 메트릭을 분석하여 성능을 측정하는 과정입니다. 이를 통해 애플리케이션의 효율성, 응답성 및 확장성에 영향을 미칠 수 있는 병목 현상, 높은 CPU 사용량, 메모리 누수 또는 느린 함수 호출을 식별할 수 있습니다.

Node.js 애플리케이션을 프로파일링하기 위해 여러 서드파티 도구가 있지만, 많은 경우 가장 쉬운 방법은 Node.js에 내장된 프로파일러를 사용하는 것입니다. 내장 프로파일러는 V8 내부의 프로파일러를 사용하며, 프로그램 실행 중에 정기적으로 스택을 샘플링합니다. 이 샘플링 결과와 JIT 컴파일과 같은 중요한 최적화 이벤트를 틱(tick)으로 기록합니다:

```javascript
code-creation,LazyCompile,0,0x2d5000a337a0,396,"bp native array.js:1153:16",0x289f644df68,~
code-creation,LazyCompile,0,0x2d5000a33940,716,"hasOwnProperty native v8natives.js:198:30",0x289f64438d0,~
code-creation,LazyCompile,0,0x2d5000a33c20,284,"ToName native runtime.js:549:16",0x289f643bb28,~
code-creation,Stub,2,0x2d5000a33d40,182,"DoubleToIStub"
code-creation,Stub,2,0x2d5000a33e00,507,"NumberToStringStub"
```

과거에는 이러한 틱을 해석하기 위해 V8 소스 코드가 필요했습니다. 다행히 Node.js 4.4.0 이후부터는 V8 소스를 별도로 빌드하지 않고도 이 정보를 쉽게 사용할 수 있는 도구가 도입되었습니다. 이제 내장 프로파일러가 애플리케이션 성능에 대한 통찰력을 어떻게 제공하는지 살펴보겠습니다.

틱 프로파일러 사용법을 설명하기 위해 간단한 Express 애플리케이션을 사용하겠습니다. 이 애플리케이션은 시스템에 새로운 사용자를 추가하는 핸들러와 사용자 인증을 검증하는 핸들러를 가지고 있습니다:

```javascript
app.get('/newUser', (req, res) => {
  let username = req.query.username || '';
  const password = req.query.password || '';

  username = username.replace(/[!@#$%^&*]/g, '');

  if (!username || !password || users[username]) {
    return res.sendStatus(400);
  }

  const salt = crypto.randomBytes(128).toString('base64');
  const hash = crypto.pbkdf2Sync(password, salt, 10000, 512, 'sha512');

  users[username] = { salt, hash };

  res.sendStatus(200);
});
```

```javascript
app.get('/auth', (req, res) => {
  let username = req.query.username || '';
  const password = req.query.password || '';

  username = username.replace(/[!@#$%^&*]/g, '');

  if (!username || !password || !users[username]) {
    return res.sendStatus(400);
  }

  const { salt, hash } = users[username];
  const encryptHash = crypto.pbkdf2Sync(password, salt, 10000, 512, 'sha512');

  if (crypto.timingSafeEqual(hash, encryptHash)) {
    res.sendStatus(200);
  } else {
    res.sendStatus(401);
  }
});
```

*이 핸들러들은 Node.js 애플리케이션에서 사용자 인증을 위해 권장되는 방법이 아니며, 단순히 설명을 위한 예제입니다. 일반적으로 직접 암호화 인증 메커니즘을 설계하려고 하지 말고, 기존에 검증된 인증 솔루션을 사용하는 것이 훨씬 좋습니다.*

이제 애플리케이션을 배포했고 사용자들이 요청에 대한 높은 지연 시간을 호소한다고 가정해봅시다. 내장 프로파일러를 사용해 애플리케이션을 쉽게 실행할 수 있습니다:

```bash
NODE_ENV=production node --prof app.js
```

그리고 `ab`(ApacheBench)를 사용해 서버에 부하를 줄 수 있습니다:

```bash
curl -X GET "http://localhost:8080/newUser?username=matt&password=password"
ab -k -c 20 -n 250 "http://localhost:8080/auth?username=matt&password=password"
```

`ab` 출력 결과는 다음과 같습니다:

```
Concurrency Level:      20
Time taken for tests:   46.932 seconds
Complete requests:      250
Failed requests:        0
Keep-Alive requests:    250
Total transferred:      50250 bytes
HTML transferred:       500 bytes
Requests per second:    5.33 [#/sec] (mean)
Time per request:       3754.556 [ms] (mean)
Time per request:       187.728 [ms] (mean, across all concurrent requests)
Transfer rate:          1.05 [Kbytes/sec] received

...

Percentage of the requests served within a certain time (ms)
  50%   3755
  66%   3804
  75%   3818
  80%   3825
  90%   3845
  95%   3858
  98%   3874
  99%   3875
 100%   4225 (longest request)
```

이 출력에서 초당 약 5개의 요청만 처리하고 있으며, 평균 요청 시간이 약 4초 정도 걸린다는 것을 알 수 있습니다. 실제 예제에서는 사용자 요청을 처리하기 위해 많은 함수에서 작업을 수행할 수 있지만, 이 간단한 예제에서도 정규 표현식 컴파일, 랜덤 솔트 생성, 사용자 비밀번호로부터 고유 해시 생성 또는 Express 프레임워크 자체에서 시간이 소요될 수 있습니다.

`--prof` 옵션을 사용해 애플리케이션을 실행했기 때문에, 애플리케이션을 실행한 디렉토리에 틱 파일이 생성됩니다. 이 파일은 `isolate-0xnnnnnnnnnnnn-v8.log` 형식을 가집니다(여기서 `n`은 숫자).

이 파일을 이해하기 위해 Node.js 바이너리에 포함된 틱 프로세서를 사용해야 합니다. 프로세서를 실행하려면 `--prof-process` 플래그를 사용합니다:

```bash
node --prof-process isolate-0xnnnnnnnnnnnn-v8.log > processed.txt
```

`processed.txt`를 텍스트 편집기에서 열면 여러 가지 정보를 확인할 수 있습니다. 파일은 섹션으로 나뉘며, 각 섹션은 언어별로 다시 구분됩니다. 먼저 요약 섹션을 보면 다음과 같습니다:

```
 [Summary]:
   ticks  total  nonlib   name
     79    0.2%    0.2%  JavaScript
  36703   97.2%   99.2%  C++
      7    0.0%    0.0%  GC
    767    2.0%          Shared libraries
    215    0.6%          Unaccounted
```

이 결과는 모든 샘플의 97%가 C++ 코드에서 발생했으며, 처리된 출력의 다른 섹션을 볼 때 C++에서 수행되는 작업에 가장 주의를 기울여야 한다는 것을 알려줍니다. 이를 염두에 두고, 다음으로 \[C++\] 섹션을 찾아 가장 많은 CPU 시간을 소모하는 C++ 함수에 대한 정보를 확인합니다:

```
 [C++]:
   ticks  total  nonlib   name
  19557   51.8%   52.9%  node::crypto::PBKDF2(v8::FunctionCallbackInfo const&)
   4510   11.9%   12.2%  _sha1_block_data_order
   3165    8.4%    8.6%  _malloc_zone_malloc
```

상위 3개 항목이 프로그램의 CPU 시간 중 72.1%를 차지한다는 것을 알 수 있습니다. 이 출력에서 적어도 51.8%의 CPU 시간이 사용자 비밀번호로부터 해시를 생성하는 PBKDF2 함수에 소요된다는 것을 즉시 알 수 있습니다. 그러나 하위 두 항목이 애플리케이션에 어떻게 영향을 미치는지는 즉시 명확하지 않을 수 있습니다(또는 예제를 위해 그렇다고 가정하겠습니다). 이러한 함수 간의 관계를 더 잘 이해하기 위해, 다음으로 각 함수의 주요 호출자에 대한 정보를 제공하는 \[Bottom up (heavy) profile\] 섹션을 살펴봅니다:

```
   ticks parent  name
  19557   51.8%  node::crypto::PBKDF2(v8::FunctionCallbackInfo const&)
  19557  100.0%    v8::internal::Builtins::~Builtins()
  19557  100.0%      LazyCompile: ~pbkdf2 crypto.js:557:16

   4510   11.9%  _sha1_block_data_order
   4510  100.0%    LazyCompile: *pbkdf2 crypto.js:557:16
   4510  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30

   3165    8.4%  _malloc_zone_malloc
   3161   99.9%    LazyCompile: *pbkdf2 crypto.js:557:16
   3161  100.0%      LazyCompile: *exports.pbkdf2Sync crypto.js:552:30
```

이 섹션을 해석하는 것은 위의 틱 카운트보다 조금 더 많은 작업이 필요합니다. 각 "호출 스택"에서 parent 열의 백분율은 현재 행의 함수가 위 행의 함수에 의해 호출된 샘플의 비율을 나타냅니다. 예를 들어, `_sha1_block_data_order`에 대한 중간 "호출 스택"에서 `_sha1_block_data_order`가 샘플의 11.9%에서 발생했다는 것을 알 수 있습니다. 그러나 여기서는 이 함수가 항상 Node.js crypto 모듈 내의 pbkdf2 함수에 의해 호출되었다는 것도 알 수 있습니다. 마찬가지로 `_malloc_zone_malloc`도 거의 동일한 pbkdf2 함수에 의해 호출되었음을 알 수 있습니다. 따라서 이 뷰의 정보를 통해 사용자 비밀번호로부터 해시를 계산하는 작업이 위의 51.8%뿐만 아니라 상위 3개 샘플링된 함수의 모든 CPU 시간을 차지한다는 것을 알 수 있습니다.

이 시점에서 비밀번호 기반 해시 생성이 최적화의 대상이 되어야 한다는 것이 매우 명확합니다. 다행히 여러분은 [비동기 프로그래밍의 이점](https://nodesource.com/blog/why-asynchronous)을 완전히 이해하고 있으며, 사용자 비밀번호로부터 해시를 생성하는 작업이 동기적으로 수행되어 이벤트 루프를 차단하고 있다는 것을 깨달았습니다. 이로 인해 해시를 계산하는 동안 다른 들어오는 요청을 처리할 수 없게 됩니다.

이 문제를 해결하기 위해 위의 핸들러를 약간 수정하여 비동기 버전의 pbkdf2 함수를 사용합니다:

```javascript
app.get('/auth', (req, res) => {
  let username = req.query.username || '';
  const password = req.query.password || '';

  username = username.replace(/[!@#$%^&*]/g, '');

  if (!username || !password || !users[username]) {
    return res.sendStatus(400);
  }

  crypto.pbkdf2(
    password,
    users[username].salt,
    10000,
    512,
    'sha512',
    (err, hash) => {
      if (users[username].hash.toString() === hash.toString()) {
        res.sendStatus(200);
      } else {
        res.sendStatus(401);
      }
    }
  );
});
```

비동기 버전의 애플리케이션으로 `ab` 벤치마크를 다시 실행하면 다음과 같은 결과를 얻습니다:

```
Concurrency Level:      20
Time taken for tests:   12.846 seconds
Complete requests:      250
Failed requests:        0
Keep-Alive requests:    250
Total transferred:      50250 bytes
HTML transferred:       500 bytes
Requests per second:    19.46 [#/sec] (mean)
Time per request:       1027.689 [ms] (mean)
Time per request:       51.384 [ms] (mean, across all concurrent requests)
Transfer rate:          3.82 [Kbytes/sec] received

...

Percentage of the requests served within a certain time (ms)
  50%   1018
  66%   1035
  75%   1041
  80%   1043
  90%   1049
  95%   1063
  98%   1070
  99%   1071
 100%   1079 (longest request)
```

이제 애플리케이션이 초당 약 20개의 요청을 처리하며, 동기적 해시 생성보다 약 4배 더 많은 요청을 처리할 수 있습니다. 또한 평균 지연 시간이 4초에서 1초 초반으로 줄었습니다.

이 (인위적인) 예제를 통해 V8 틱 프로세서가 Node.js 애플리케이션의 성능을 더 잘 이해하는 데 어떻게 도움이 되는지 확인했기를 바랍니다.

[플레임 그래프 생성 방법](https://nodejs.org/ko/learn/diagnostics/flame-graphs)도 도움이 될 수 있습니다.


