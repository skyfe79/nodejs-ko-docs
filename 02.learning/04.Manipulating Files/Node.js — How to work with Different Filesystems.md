# 다양한 파일 시스템 작업 방법

Node.js는 파일 시스템의 다양한 기능을 제공합니다. 하지만 모든 파일 시스템이 동일하지는 않습니다. 아래는 여러분이 다양한 파일 시스템을 다룰 때 코드를 간단하고 안전하게 유지하기 위한 권장 사항입니다.


## 파일시스템 동작 방식

파일시스템을 다루기 전에, 먼저 파일시스템이 어떻게 동작하는지 이해해야 합니다. 각 파일시스템은 서로 다르게 동작하며, 지원하는 기능도 다릅니다. 대소문자 구분, 대소문자 무시, 대소문자 유지, 유니코드 형식 유지, 타임스탬프 정밀도, 확장 속성, inode, Unix 권한, 대체 데이터 스트림 등이 그 예입니다.

`process.platform`을 통해 파일시스템 동작 방식을 추론하는 데 주의해야 합니다. 예를 들어, 프로그램이 Darwin에서 실행된다고 해서 대소문자를 구분하지 않는 파일시스템(HFS+)을 사용한다고 가정해서는 안 됩니다. 사용자가 대소문자를 구분하는 파일시스템(HFSX)을 사용할 수도 있습니다. 마찬가지로, 프로그램이 Linux에서 실행된다고 해서 Unix 권한과 inode를 지원하는 파일시스템을 사용한다고 가정해서는 안 됩니다. 특정 외장 드라이브, USB, 네트워크 드라이브에서는 이러한 기능을 지원하지 않을 수 있습니다.

운영체제가 파일시스템 동작 방식을 쉽게 추론할 수 있도록 해주지 않을 수도 있지만, 모든 것이 손실된 것은 아닙니다. 알려진 모든 파일시스템과 동작 방식을 목록으로 유지하는 대신(이는 항상 불완전할 수밖에 없습니다), 파일시스템을 직접 탐색하여 실제 동작 방식을 확인할 수 있습니다. 탐색하기 쉬운 특정 기능의 유무를 통해, 탐색하기 어려운 다른 기능의 동작 방식을 추론하는 데 충분한 경우가 많습니다.

일부 사용자는 작업 트리의 다양한 경로에 다른 파일시스템을 마운트했을 수 있다는 점을 기억하세요.


## [최소 공통 분모 접근 방식 피하기](https://nodejs.org/en/learn/asynchronous-work/asynchronous-flow-control#avoid-a-lowest-common-denominator-approach)

여러분은 모든 파일 이름을 대문자로 정규화하거나, 모든 파일 이름을 NFC 유니코드 형식으로 정규화하거나, 모든 파일 타임스탬프를 1초 단위로 정규화하는 등 프로그램을 최소 공통 분모 파일 시스템처럼 동작하도록 만들고 싶을 수 있습니다. 이는 최소 공통 분모 접근 방식입니다.

이렇게 하지 마세요. 이 방식은 모든 면에서 동일한 최소 공통 분모 특성을 가진 파일 시스템과만 안전하게 상호작용할 수 있습니다. 사용자가 기대하는 방식으로 더 발전된 파일 시스템과 작업할 수 없게 되며, 파일 이름이나 타임스탬프 충돌이 발생할 수 있습니다. 복잡한 종속 이벤트를 통해 사용자 데이터를 잃거나 손상시킬 가능성이 높으며, 해결하기 어렵거나 불가능한 버그를 만들게 됩니다.

나중에 2초 또는 24시간 단위의 타임스탬프 해상도를 가진 파일 시스템을 지원해야 한다면 어떻게 될까요? 유니코드 표준이 약간 다른 정규화 알고리즘을 포함하도록 발전한다면(과거에 그랬던 것처럼) 어떻게 될까요?

최소 공통 분모 접근 방식은 "이식 가능한" 시스템 호출만 사용하여 이식 가능한 프로그램을 만들려고 시도합니다. 이는 실제로 이식 가능하지 않고 문제가 많은 프로그램을 만듭니다.


## 슈퍼셋 접근 방식 채택하기

여러분이 지원하는 각 플랫폼의 장점을 최대한 활용하려면 슈퍼셋 접근 방식을 도입하세요. 예를 들어, 휴대용 백업 프로그램은 Windows 시스템 간에 btimes(파일이나 폴더의 생성 시간)를 정확히 동기화해야 하며, Linux 시스템에서는 btimes를 지원하지 않더라도 이를 파괴하거나 변경해서는 안 됩니다. 동일한 휴대용 백업 프로그램은 Linux 시스템 간에 Unix 권한을 정확히 동기화해야 하며, Windows 시스템에서는 Unix 권한을 지원하지 않더라도 이를 파괴하거나 변경해서는 안 됩니다.

여러분의 프로그램이 더 발전된 파일 시스템처럼 동작하도록 만들어 다양한 파일 시스템을 처리하세요. 가능한 모든 기능의 슈퍼셋을 지원하세요: 대소문자 구분, 대소문자 보존, Unicode 형식 구분, Unicode 형식 보존, Unix 권한, 고해상도 나노초 타임스탬프, 확장 속성 등.

프로그램에서 대소문자 보존을 구현했다면, 대소문자를 구분하지 않는 파일 시스템과 상호작용해야 할 때 언제든지 대소문자 구분을 구현할 수 있습니다. 하지만 프로그램에서 대소문자 보존을 포기한다면, 대소문자를 보존하는 파일 시스템과 안전하게 상호작용할 수 없습니다. 이는 Unicode 형식 보존과 타임스탬프 해상도 보존에도 동일하게 적용됩니다.

파일 시스템이 소문자와 대문자가 혼합된 파일 이름을 제공한다면, 주어진 대소문자를 그대로 유지하세요. 파일 시스템이 혼합된 Unicode 형식이나 NFC, NFD(또는 NFKC, NFKD)로 파일 이름을 제공한다면, 주어진 바이트 시퀀스를 그대로 유지하세요. 파일 시스템이 밀리초 단위의 타임스탬프를 제공한다면, 밀리초 해상도로 타임스탬프를 유지하세요.

덜 발전된 파일 시스템을 다룰 때는, 프로그램이 실행 중인 파일 시스템의 동작에 필요한 비교 함수를 사용해 적절히 다운샘플링할 수 있습니다. 파일 시스템이 Unix 권한을 지원하지 않는다면, 작성한 Unix 권한을 동일하게 읽을 것으로 기대하지 마세요. 파일 시스템이 대소문자를 보존하지 않는다면, 프로그램이 `abc`를 생성했을 때 디렉토리 목록에서 `ABC`를 볼 준비를 해야 합니다. 하지만 파일 시스템이 대소문자를 보존한다면, 파일 이름 변경을 감지하거나 파일 시스템이 대소문자를 구분할 때 `ABC`와 `abc`를 다른 파일 이름으로 간주해야 합니다.


## [대소문자 보존](https://nodejs.org/en/learn/asynchronous-work/asynchronous-flow-control#case-preservation)

여러분이 `test/abc`라는 디렉토리를 생성했을 때, 가끔 `fs.readdir('test')`가 `['ABC']`를 반환하는 것을 보고 놀랄 수 있습니다. 이는 Node의 버그가 아닙니다. Node는 파일 시스템이 저장한 대로 파일 이름을 반환하며, 모든 파일 시스템이 대소문자 보존을 지원하지는 않습니다. 일부 파일 시스템은 모든 파일 이름을 대문자(또는 소문자)로 변환합니다.


## [유니코드 형식 보존](https://nodejs.org/en/learn/asynchronous-work/asynchronous-flow-control#unicode-form-preservation)

*대소문자 보존과 유니코드 형식 보존은 비슷한 개념입니다. 유니코드 형식을 왜 보존해야 하는지 이해하려면, 먼저 대소문자를 왜 보존해야 하는지 이해해야 합니다. 유니코드 형식 보존은 올바르게 이해하면 매우 간단합니다.*

유니코드는 동일한 문자를 여러 다른 바이트 시퀀스로 인코딩할 수 있습니다. 여러 문자열이 동일해 보일 수 있지만, 실제로는 다른 바이트 시퀀스를 가질 수 있습니다. UTF-8 문자열을 다룰 때는 여러분의 기대가 유니코드가 작동하는 방식과 일치하는지 주의해야 합니다. 모든 UTF-8 문자가 단일 바이트로 인코딩될 것이라고 기대하지 않는 것처럼, 사람의 눈에 동일해 보이는 여러 UTF-8 문자열이 동일한 바이트 표현을 가질 것이라고 기대해서는 안 됩니다. 이는 ASCII에서는 기대할 수 있지만, UTF-8에서는 그렇지 않습니다.

예를 들어, `test/café`라는 디렉토리를 생성할 수 있습니다. 이 디렉토리는 NFC 유니코드 형식으로 바이트 시퀀스 `<63 61 66 c3 a9>`를 가지며, `string.length === 5`입니다. 그러나 때로는 `fs.readdir('test')`가 `['café']`를 반환하는 것을 보고 놀랄 수 있습니다. 이는 NFD 유니코드 형식으로 바이트 시퀀스 `<63 61 66 65 cc 81>`을 가지며, `string.length === 6`입니다. 이는 Node의 버그가 아닙니다. Node.js는 파일 시스템이 저장한 대로 파일 이름을 반환하며, 모든 파일 시스템이 유니코드 형식 보존을 지원하는 것은 아닙니다.

예를 들어, HFS+는 거의 항상 NFD 형식과 동일한 형식으로 모든 파일 이름을 정규화합니다. HFS+가 NTFS나 EXT4와 동일하게 동작할 것이라고 기대하지 마세요. 반대의 경우도 마찬가지입니다. 파일 시스템 간의 유니코드 차이를 덮기 위해 정규화를 통해 데이터를 영구적으로 변경하려고 시도하지 마세요. 이는 문제를 해결하지 못한 채 새로운 문제를 만들 뿐입니다. 대신, 유니코드 형식을 보존하고 정규화를 비교 함수로만 사용하세요.


## 유니코드 형식 무감각성(Unicode Form Insensitivity)

유니코드 형식 무감각성과 유니코드 형식 보존은 종종 혼동되는 두 가지 파일 시스템 동작입니다. 대소문자 무감각성이 파일을 저장하고 전송할 때 파일 이름을 영구적으로 대문자로 정규화하는 방식으로 잘못 구현되곤 했던 것처럼, 유니코드 형식 무감각성도 파일을 저장하고 전송할 때 파일 이름을 특정 유니코드 형식(예: HFS+의 경우 NFD)으로 영구적으로 정규화하는 방식으로 잘못 구현되곤 했습니다. 유니코드 형식 보존을 희생하지 않으면서도 유니코드 형식 무감각성을 구현하는 것이 가능하며, 이는 비교를 위해서만 유니코드 정규화를 사용함으로써 훨씬 더 나은 방법입니다.


## [다양한 유니코드 형태 비교](https://nodejs.org/en/learn/asynchronous-work/asynchronous-flow-control#comparing-different-unicode-forms)

Node.js는 UTF-8 문자열을 NFC 또는 NFD로 정규화할 수 있는 `string.normalize('NFC' / 'NFD')`를 제공합니다. 이 함수의 출력을 저장하지 말고, 두 UTF-8 문자열이 사용자에게 동일하게 보이는지 테스트하는 비교 함수의 일부로만 사용해야 합니다.

비교 함수로 `string1.normalize('NFC') === string2.normalize('NFC')` 또는 `string1.normalize('NFD') === string2.normalize('NFD')`를 사용할 수 있습니다. 어떤 형태를 사용하든 상관없습니다.

정규화는 빠르지만, 동일한 문자열을 여러 번 정규화하지 않도록 비교 함수에 캐시를 사용하는 것이 좋습니다. 캐시에 문자열이 없으면 정규화한 후 캐시에 저장합니다. 캐시를 저장하거나 지속적으로 사용하지 않도록 주의하세요. 캐시는 임시로만 사용해야 합니다.

`normalize()`를 사용하려면 Node.js 버전에 ICU가 포함되어 있어야 합니다(그렇지 않으면 `normalize()`는 원본 문자열을 반환합니다). Node.js 웹사이트에서 최신 버전을 다운로드하면 ICU가 포함됩니다.


## [타임스탬프 해상도](https://nodejs.org/en/learn/asynchronous-work/asynchronous-flow-control#timestamp-resolution)

파일의 `mtime`(수정 시간)을 `1444291759414`(밀리초 단위 해상도)로 설정했을 때, `fs.stat`이 반환하는 새로운 mtime이 `1444291759000`(1초 단위 해상도) 또는 `1444291758000`(2초 단위 해상도)로 나오는 경우가 있습니다. 이는 Node의 버그가 아닙니다. Node.js는 파일시스템이 저장한 타임스탬프를 그대로 반환하며, 모든 파일시스템이 나노초, 밀리초 또는 1초 단위의 타임스탬프 해상도를 지원하지는 않습니다. 특히 일부 FAT 파일시스템은 `atime` 타임스탬프에 대해 매우 낮은 해상도(예: 24시간)를 가질 수 있습니다.


## 파일 이름과 타임스탬프를 정규화로 손상시키지 마세요

파일 이름과 타임스탬프는 사용자 데이터입니다. 사용자 파일 데이터를 자동으로 대문자로 바꾸거나 `CRLF`를 `LF` 줄바꿈으로 정규화하지 않는 것처럼, 파일 이름이나 타임스탬프를 대소문자/유니코드 형식/타임스탬프 정규화를 통해 변경하거나 손상시켜서는 안 됩니다. 정규화는 비교를 위해서만 사용해야 하며, 데이터를 변경하는 데 사용해서는 안 됩니다.

정규화는 사실상 손실이 있는 해시 코드와 같습니다. 이를 사용하여 특정 종류의 동등성을 테스트할 수 있지만(예: 여러 문자열이 바이트 시퀀스가 다르더라도 동일하게 보이는지), 실제 데이터의 대체물로 사용할 수는 없습니다. 여러분의 프로그램은 파일 이름과 타임스탬프 데이터를 있는 그대로 전달해야 합니다.

여러분의 프로그램은 NFC(또는 선호하는 유니코드 형식 조합)로 새 데이터를 생성하거나, 소문자 또는 대문자 파일 이름으로, 또는 2초 단위의 타임스탬프로 생성할 수 있습니다. 하지만 기존 사용자 데이터를 대소문자/유니코드 형식/타임스탬프 정규화를 통해 손상시켜서는 안 됩니다. 대신, 상위 집합 접근 방식을 채택하고 프로그램에서 대소문자, 유니코드 형식, 타임스탬프 정밀도를 보존하세요. 이렇게 하면 동일한 방식으로 동작하는 파일 시스템과 안전하게 상호작용할 수 있습니다.


## 정규화 비교 함수를 적절히 사용하기

파일 이름 비교 시 대소문자를 구분하지 않는 함수를 사용하지 마세요. 특히 대소문자를 구분하는 파일 시스템에서 작업 중이라면 더욱 주의해야 합니다. 유니코드 형식에 민감한 파일 시스템(예: NTFS와 대부분의 Linux 파일 시스템은 NFC와 NFD 또는 혼합된 유니코드 형식을 모두 보존함)에서 작업할 때는 유니코드 형식에 민감하지 않은 비교 함수를 사용하지 마세요. 또한 나노초 단위의 타임스탬프 해상도를 지원하는 파일 시스템에서 작업할 때는 2초 단위의 타임스탬프 해상도로 비교하지 마세요.


## 비교 함수의 미묘한 차이에 대비하기

파일 시스템의 비교 함수와 일치하는지 주의하세요. 가능하다면 파일 시스템을 직접 확인하여 실제로 어떻게 비교하는지 살펴보는 것이 좋습니다. 예를 들어, 대소문자 구분 없이 비교하는 것은 단순히 `toLowerCase()`를 사용하는 것보다 복잡합니다. 사실, `toUpperCase()`가 `toLowerCase()`보다 일반적으로 더 나은 선택입니다. 특정 외국어 문자를 다르게 처리하기 때문입니다. 하지만 가장 좋은 방법은 파일 시스템을 직접 확인하는 것입니다. 모든 파일 시스템은 자체적인 대소문자 비교 테이블을 가지고 있기 때문입니다.

예를 들어, Apple의 HFS+는 파일 이름을 NFD 형식으로 정규화합니다. 하지만 이 NFD 형식은 현재의 NFD 형식보다 오래된 버전일 수 있으며, 최신 Unicode 표준의 NFD 형식과 약간 다를 수 있습니다. HFS+의 NFD가 항상 Unicode의 NFD와 정확히 같을 것이라고 기대하지 마세요.


